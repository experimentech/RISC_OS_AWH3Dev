/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "Licence").
 * You may not use this file except in compliance with the Licence.
 *
 * You can obtain a copy of the licence at
 * cddl/RiscOS/Sources/FileSys/SDFS/SDFS/LICENCE.
 * See the Licence for the specific language governing permissions
 * and limitations under the Licence.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the Licence file. If applicable, add the
 * following below this CDDL HEADER, with the fields enclosed by
 * brackets "[]" replaced with your own identifying information:
 * Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2012 Ben Avison.  All rights reserved.
 * Portions Copyright 2012 Jeffrey Lee.
 * Use is subject to license terms.
 */

/** \file module.c
 * Module entry point dispatch.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"

#include "Global/CMOS.h"
#include "Global/FSNumbers.h"
#include "Global/OsBytes.h"
#include "Global/ModHand.h"
#include "Global/RISCOS.h"
#include "Global/SWIs.h"
#include "Interface/FileCore.h"
#include "Interface/FileCoreErr.h"
#include "Interface/SDFSErr.h"
#include "Interface/SDIO.h"
#include "Interface/SDHCIDevice.h"

#include "SyncLib/synclib.h"

#undef Module_Title /* unfortunate clash between CMHG and Hdr:ModHand */
#include "SDFSHdr.h"
#include "command.h"
#include "discop.h"
#include "free.h"
#include "globals.h"
#include "message.h"
#include "miscop.h"
#include "service.h"
#include "swi.h"

#include "gpiodebug.h"

/* This function is autogenerated by ResGen, and returns a pointer to a
 * ResourceFS resource file data block */
extern void *Resources(void);

_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *e;
  uint32_t default_drive = 0;
  IGNORE(cmd_tail);
  IGNORE(podule_base);
  
  g_module_pw = pw;
  
#ifndef ROM_MODULE
  e = _swix(ResourceFS_RegisterFiles, _IN(0), Resources());
  if (e != NULL)
    return e;
#else
  /* In ROM builds, all resource files live in the Messages module instead */
#endif

  e = _swix(MessageTrans_OpenFile, _INR(0,2), &g_message_fd, "Resources:$.Resources.SDFS.Messages", 0);
  if (e != NULL)
  {
#ifndef ROM_MODULE
    _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif
    return e;
  }

  synclib_init();
  free_init();
  gpiodebug_init();
  
  /* Initialise global variables */
  message_lookup_buffer("Card", g_media_type_name, MEDIA_TYPE_NAME_LEN);
  for (uint32_t i = 0; i < NUM_FLOPPIES + NUM_WINNIES; i++)
  {
    g_drive[i].sequence_lock = (spinlock_t) SPIN_INITIALISER;
    g_drive[i].certainty_lock = (spinlock_t) SPIN_INITIALISER;
  }

  /* Register with Free */
  _swix(Free_Register, _INR(0,2), fsnumber_SDFS, free_veneer, &free_handle);

  /* Check for compatible FileCore */
  uint32_t filecore_features;
  if (_swix(FileCore_Features, _OUT(0), &filecore_features) ||
      ((Feature_NewErrors | Feature_FloppyDiscsCanMountLikeFixed) &~ filecore_features) != 0)
  {
    e = MESSAGE_ERRORLOOKUP(true, BadFileCore, 0);
    goto failed_init;
  }

  /* Some machines (such as the Compute Module) have non-removable eMMC or eSD
   * so the natural default drive is 4, but they run the same ROM as machines for
   * which the natural default drive is 0. Solve this by inverting bit 2 of the
   * CMOS if there is a HAL device with the IntegratedMem flag set. We can't ask
   * SDIODriver because that would have to wait until callbacks have triggered.
   */
  uint32_t handle = 0;
  while (true)
  {
    sdhcidevice_t *device;
    uint32_t sloti;
    _kernel_oserror *e = _swix(OS_Hardware, _INR(0,1)|_IN(8)|_OUTR(1,2),
                               HALDeviceType_ExpCtl + HALDeviceExpCtl_SDIO,
                               handle, 5, &handle, &device);
    if (e != NULL || handle == -1u)
      break;
    for (sloti = 0; sloti < device->slots; sloti++)
    {
      if (device->slotinfo[sloti].flags & HALDeviceSDHCI_SlotFlag_IntegratedMem)
        break;
    }
    if (sloti < device->slots)
    {
      g_default_drive_toggle = 4;
      break;
    }
  }

  /* Read default drive from CMOS byte 17, bits 4-6 */
  _swix(OS_Byte, _INR(0,1)|_OUT(2), OsByte_ReadCMOS, DEFAULT_DRIVE_BYTE, &default_drive);
  default_drive = ((default_drive & DEFAULT_DRIVE_MASK) >> DEFAULT_DRIVE_SHIFT) ^ g_default_drive_toggle;

  /* Register with FileCore */
  e = _swix(FileCore_Create, _INR(0,6)|_OUTR(0,2),
          (uint32_t []) {
              /* not CreateFlag_FixedDiscNeedsFIQ */
              /* not CreateFlag_FloppyNeedsFIQ */
              /* not CreateFlag_NoBigBuf - only currently used by RAMFS, probably
               *     most useful there because you don't get a speed benefit by
               *     doing additional RAM buffering of a RAM filing system */
              /* not CreateFlag_FixedDiscsMountLikeFloppy - all drives behave the
               *     same, and we let FileCore work out the geometry from the
               *     boot block for all drives rather than hard-wiring it */
              CreateFlag_FixedDiscPollChangeSupport | /* discs in drives 4-7 can be removed */
              /* not CreateFlag_FloppyEjects */
              /* not CreateFlag_FixedDiscEjects */
              CreateFlag_DriveStatusWorks |
              CreateFlag_BigDiscSupport |
              CreateFlag_NewErrorSupport |
              CreateFlag_FloppyDiscsMountLikeFixed |
              ((uint32_t)fsnumber_SDFS << (Create_Id * 8)),
              FILING_SYSTEM_TITLE - MODULE_BASE_ADDRESS,
              FILING_SYSTEM_AUTHOR " " FILING_SYSTEM_TITLE - MODULE_BASE_ADDRESS,
              (const char *)module_discop_veneer - MODULE_BASE_ADDRESS,
              (const char *)module_miscop_veneer - MODULE_BASE_ADDRESS
          },
          MODULE_BASE_ADDRESS,
          g_module_pw,
          NUM_FLOPPIES | (NUM_WINNIES << 8) | (default_drive << 16),
          255 * 1024, /* directory cache size \ any machine with SD slots will have at least 64 MB, so the default for both of these */
#ifdef ENABLE_BACKGROUND_TRANSFERS
          255,        /* 1K file buffers      / would be 255K for ADFS/SCSIFS anyway; don't yet trust FileCore to handle larger numbers */
#else
          0,          /* 0 => disable file buffering */
#endif
          -1,         /* obsolete parameter - pass -1 for consistency with ADFS etc */
          &g_filecore_pw,
          &g_filecore_callback_floppy_op_completed,
          &g_filecore_callback_winnie_op_completed);
  if (e) goto failed_init;

  /* Find any existing SDIO slots / cards */
  {
    uint32_t slot_handle = 0;
    uint32_t slot_spec;
    while (!_swix(SDIO_Enumerate, _INR(0,1)|_OUTR(1,2),
        SDIOEnumerate_Slots, slot_handle,
        &slot_handle, &slot_spec) && slot_handle != 0)
    {
      service_SDIOSlotAttached((slot_spec & SDIOEnumerate_BusMask) >> SDIOEnumerate_BusShift,
                               (slot_spec & SDIOEnumerate_SlotMask) >> SDIOEnumerate_SlotShift,
                               slot_spec & SDIOEnumerate_Integrated,
                               slot_spec & SDIOEnumerate_NoCardDetect,
                               slot_spec & SDIOEnumerate_IntegratedMem);
      uint32_t unit_handle = 0;
      uint32_t unit_spec[2];
      uint32_t unit_size[2];
      while (!_swix(SDIO_Enumerate, _INR(0,2)|_OUTR(1,5),
          SDIOEnumerate_Units, unit_handle, slot_spec,
          &unit_handle, &unit_spec[0], &unit_spec[1], &unit_size[0], &unit_size[1]) && unit_handle != 0)
      {
        service_SDIOUnitAttached((unit_spec[0] & SDIOEnumerate_BusMask) >> SDIOEnumerate_BusShift,
                                 (unit_spec[0] & SDIOEnumerate_SlotMask) >> SDIOEnumerate_SlotShift,
                                 (unit_spec[0] & SDIOEnumerate_RCAMask) >> SDIOEnumerate_RCAShift,
                                 (unit_spec[1] & SDIOEnumerate_UnitMask) >> SDIOEnumerate_UnitShift,
                                 (unit_spec[1] & SDIOEnumerate_FICMask) >> SDIOEnumerate_FICShift,
                                 unit_spec[1] & SDIOEnumerate_WriteProtect,
                                 unit_spec[1] & SDIOEnumerate_MMC,
                                 (uint64_t) unit_size[1] << 32 | unit_size[0],
                                 true);
      }
    }
  }

  /* The module needs to be on TickerV the whole time */
  e = _swix(OS_Claim, _INR(0,2), TickerV, module_tickerv_veneer, g_module_pw);
  if (e) goto failed_init;

  return NULL;

failed_init:
  _swix(OS_Module, _INR(0,1), ModHandReason_Delete, "FileCore%" FILING_SYSTEM_TITLE);
  _swix(Free_DeRegister, _INR(0,2), fsnumber_SDFS, free_veneer, &free_handle);
  _swix(MessageTrans_CloseFile, _IN(0), &g_message_fd);
#ifndef ROM_MODULE
  _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif
  return e;
}

_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{
  IGNORE(fatal);
  IGNORE(podule);
  IGNORE(pw);
  
  _swix(OS_Release, _INR(0,2), TickerV, module_tickerv_veneer, g_module_pw);

  /* Kill our supporting FileCore instantiation */
  _swix(OS_Module, _INR(0,1), ModHandReason_Delete, "FileCore%" FILING_SYSTEM_TITLE);

  /* Free dynamic memory allocations */
  for (uint32_t drive = 0; drive < NUM_FLOPPIES + NUM_WINNIES; ++drive)
  {
    if (g_drive[drive].block_buffer)
      free(g_drive[drive].block_buffer);
  }

  _swix(Free_DeRegister, _INR(0,2), fsnumber_SDFS, free_veneer, &free_handle);
  _swix(MessageTrans_CloseFile, _IN(0), &g_message_fd);
#ifndef ROM_MODULE
  _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif
  return 0;
}

void module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  
  switch (service_number)
  {
    case Service_SDIOSlotAttached:
      service_SDIOSlotAttached((r->r[2] & SDIOSlotAttached_BusMask) >> SDIOSlotAttached_BusShift,
                               (r->r[2] & SDIOSlotAttached_SlotMask) >> SDIOSlotAttached_SlotShift,
                               r->r[2] & SDIOSlotAttached_Integrated,
                               r->r[2] & SDIOSlotAttached_NoCardDetect,
                               r->r[2] & SDIOSlotAttached_IntegratedMem);
      break;

    case Service_SDIOSlotDetached:
      service_SDIOSlotDetached((r->r[2] & SDIOSlotAttached_BusMask) >> SDIOSlotAttached_BusShift,
                               (r->r[2] & SDIOSlotAttached_SlotMask) >> SDIOSlotAttached_SlotShift,
                               r->r[2] & SDIOSlotAttached_Integrated,
                               r->r[2] & SDIOSlotAttached_NoCardDetect,
                               r->r[2] & SDIOSlotAttached_IntegratedMem);
      break;

    case Service_SDIOUnitAttached:
      service_SDIOUnitAttached((r->r[2] & SDIOUnitAttached_BusMask) >> SDIOUnitAttached_BusShift,
                               (r->r[2] & SDIOUnitAttached_SlotMask) >> SDIOUnitAttached_SlotShift,
                               ((uint32_t) r->r[2] & SDIOUnitAttached_RCAMask) >> SDIOUnitAttached_RCAShift,
                               (r->r[3] & SDIOUnitAttached_UnitMask) >> SDIOUnitAttached_UnitShift,
                               (r->r[3] & SDIOUnitAttached_FICMask) >> SDIOUnitAttached_FICShift,
                               r->r[3] & SDIOUnitAttached_WriteProtect,
                               r->r[3] & SDIOUnitAttached_MMC,
                               (uint64_t) r->r[5] << 32 | (uint32_t) r->r[4],
                               false);
      break;

    case Service_SDIOUnitDetached:
      service_SDIOUnitDetached((r->r[2] & SDIOUnitAttached_BusMask) >> SDIOUnitAttached_BusShift,
                               (r->r[2] & SDIOUnitAttached_SlotMask) >> SDIOUnitAttached_SlotShift,
                               ((uint32_t) r->r[2] & SDIOUnitAttached_RCAMask) >> SDIOUnitAttached_RCAShift,
                               (r->r[3] & SDIOUnitAttached_UnitMask) >> SDIOUnitAttached_UnitShift,
                               (r->r[3] & SDIOUnitAttached_FICMask) >> SDIOUnitAttached_FICShift,
                               r->r[3] & SDIOUnitAttached_WriteProtect,
                               r->r[3] & SDIOUnitAttached_MMC);
      break;

    case Service_SDIOSlotReleased:
      service_SDIOSlotReleased((r->r[2] & SDIOUnitAttached_BusMask) >> SDIOUnitAttached_BusShift,
                               (r->r[2] & SDIOUnitAttached_SlotMask) >> SDIOUnitAttached_SlotShift);
      break;
  }
}

_kernel_oserror *module_command(const char *arg_string, int argc, int cmd_no, void *pw)
{
  IGNORE(pw);
  
  size_t max_args = cmd_no == CMD_SDFSdrive ? 8 : argc; /* argc not valid for *Configure commands */
  char *argv[MAX(max_args,1)];
  char arg_buffer[1024]; /* command line length limit - can't need more than that */

  /* Parse arguments */
  size_t args = 0;
  if (arg_string != arg_CONFIGURE_SYNTAX && arg_string != arg_STATUS)
  {
    const char *in = arg_string;
    char *out = arg_buffer;
    while (args < max_args) /* should always be true, except for *Configure commands with lots of arguments */
    {
      /* Skip leading / separating / trailing spaces */
      while (*in == ' ') ++in;
      if (*in == 0 || *in == 10 || *in == 13)
        break; /* end of command line */
      argv[args++] = out;
      bool arg_is_quoted = *in == '"'; /* quote rules only apply if first char is a quote */
      bool quote_active = false;
      while (true)
      {
        if (*in == 0 || *in == 10 || *in == 13 || (*in == ' ' && !quote_active))
          break; /* end of argument */
        if (arg_is_quoted && *in == '"')
        {
          if (quote_active && in[1] == '"')
            *out++ = '"'; /* two quote characters is an escaped quote */
          --quote_active; /* toggle quote state */
        }
        else
          *out++ = *in;
        ++in;
      }
      *out++ = '\0'; /* terminate our copy of the argument */
    }
  }

  switch (cmd_no)
  {
    case CMD_SDFS:
      return command_sdfs();

    case CMD_SDFSdrive:
      if (arg_string == arg_CONFIGURE_SYNTAX)
        return command_configure_syntax_sdfsdrive();
      if (arg_string == arg_STATUS)
        return command_status_sdfsdrive();
      if (args != 1)
        return command_syntax_sdfsdrive();
      else
        return command_configure_sdfsdrive(argv[0]);
  }
  /* Shouldn't get here */
  return NULL;
}

_kernel_oserror *module_swi(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  
  switch (swi_offset)
  {
    case SDFS_DiscOp - SDFS_00:
    case SDFS_Drives - SDFS_00:
    case SDFS_FreeSpace - SDFS_00:
    case SDFS_DescribeDisc - SDFS_00:
    case SDFS_MiscOp - SDFS_00:
    case SDFS_SectorDiscOp - SDFS_00:
    case SDFS_FreeSpace64 - SDFS_00:
    case SDFS_DiscOp64 - SDFS_00:
    {
      int orig_r8 = r->r[8];
      r->r[8] = (int) g_filecore_pw;
      _kernel_oserror *e = _kernel_swi(FileCoreSWI_Base + swi_offset, r, r);
      r->r[8] = orig_r8;
      return e;
    }

    case SDFS_ReadCardInfo - SDFS_00:
      return swi_ReadCardInfo(r->r[0], r->r[1], r);

    default:
      return MESSAGE_ERRORLOOKUP(false, BadSWI, "SDFS");
  }
  return NULL;
}

_kernel_oserror *module_miscop_handler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);
  
  dprintf("MiscOp %u\n", r->r[0]);

  switch (r->r[0])
  {
    case MiscOp_Mount:
      return miscop_Mount(r->r[1], r->r[2], (uint8_t *) r->r[3], r->r[4], (disc_record_t *) r->r[5]).oserror;

    case MiscOp_PollChanged:
      miscop_PollChanged(r->r[1], (uint32_t *) &r->r[2], (uint32_t *) &r->r[3]);
      return NULL;

    case MiscOp_LockDrive:
      miscop_LockDrive(r->r[1]);
      return NULL;

    case MiscOp_UnlockDrive:
      miscop_UnlockDrive(r->r[1]);
      return NULL;

    case MiscOp_PollPeriod:
      miscop_PollPeriod(r->r[1], (uint32_t *) &r->r[5], (const char **) &r->r[6]);
      return NULL;

    case MiscOp_Eject:
      miscop_Eject(r->r[1]);
      return NULL;

    case MiscOp_DriveStatus:
      miscop_DriveStatus(r->r[1], (uint32_t *) &r->r[2]);
      return NULL;

    case MiscOp_ReadInfo: /* shouldn't be used for low-level MiscOp */
    default:
      return (_kernel_oserror *) BadParmsErr;
  }
}

_kernel_oserror *module_discop_handler(_kernel_swi_regs *r, void *pw)
{
  _kernel_oserror *e;
  uint32_t reason;
  uint32_t flags;
  uint64_t disc_address;
  IGNORE(pw);
  
  dprintf("DiscOp %u, flags %03X, disc address %u/%08X, buffer %08X, length %u\n",
      r->r[1] & DiscOp_Op_Mask,
      r->r[1] &~ DiscOp_Op_Mask,
      (uint32_t) r->r[2] >> 28,
      r->r[2] &~ 0xE0000000,
      r->r[3],
      r->r[4]);

  reason = r->r[1] & DiscOp_Op_Mask;
  switch (reason)
  {
    /* Ops that we support */
    case DiscOp_Verify:
      if (r->r[1] & DiscOp_Op_BackgroundOp_Flag)
        return (_kernel_oserror *) BadParmsErr;
      /* else drop through */
    case DiscOp_ReadSecs:
    case DiscOp_WriteSecs:
      flags = r->r[1] & (DiscOp_Op_ScatterList_Flag | DiscOp_Op_IgnoreEscape_Flag | DiscOp_Op_IgnoreTimeout_Flag | DiscOp_Op_BackgroundOp_Flag);
      flags *= SDIOOp_Scatter / DiscOp_Op_ScatterList_Flag;
      disc_address = ((uint64_t) r->r[2] & LegacyDiscAddress_SectorOffset_Mask) << LOG2_SECTOR_SIZE;
      if (disc_address + r->r[4] >= 1ull << (LegacyDiscAddress_DriveNumber_Shift + LOG2_SECTOR_SIZE))
        /* We won't be able to update the disc address properly on exit, at
         * least in the SectorDiscOp world */
        return (_kernel_oserror *) BadParmsErr;
      e = discop(reason, flags,
                 (uint32_t) r->r[2] >> LegacyDiscAddress_DriveNumber_Shift, &disc_address,
                 (block_or_scatter_t *) &r->r[3], (size_t *) &r->r[4]
                 ).oserror;
      r->r[2] = (r->r[2] &~ LegacyDiscAddress_SectorOffset_Mask) | (uint32_t) (disc_address >> LOG2_SECTOR_SIZE);
      return e;

    /* Ops that we don't support, but lack of support is harmless */
    case DiscOp_Seek:
    case DiscOp_Restore:
    case DiscOp_StepIn:
    case DiscOp_StepOut:
    case DiscOp_Specify:
    case DiscOp_WriteTrk: /* bodge for now to make HForm work */
      return NULL;

    /* Ops that we don't support, but caller would expect to do something */
    case DiscOp_ReadTrk:
    // case DiscOp_WriteTrk: bodge for now to make HForm work
      /* drop through */

    /* Anything else suggests a caller error, including DiscOp_CachedReadSecs which shouldn't get here */
    default:
      return (_kernel_oserror *) BadParmsErr;
  }
}

int module_tickerv_handler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);

  spinrw_read_lock(&g_drive_lock);

  for (uint32_t drive = 0; drive < NUM_FLOPPIES + NUM_WINNIES; drive++)
  {
    spin_lock(&g_drive[drive].certainty_lock);
    uint32_t old_value = g_drive[drive].certainty;
    if (old_value > 0 && !g_drive[drive].slot_claimed)
      g_drive[drive].certainty = old_value - 1;
    spin_unlock(&g_drive[drive].certainty_lock);
  }

  spinrw_read_unlock(&g_drive_lock);

  return 1;
}
