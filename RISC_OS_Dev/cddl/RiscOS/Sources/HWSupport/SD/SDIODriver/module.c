/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "Licence").
 * You may not use this file except in compliance with the Licence.
 *
 * You can obtain a copy of the licence at
 * cddl/RiscOS/Sources/HWSupport/SD/SDIODriver/LICENCE.
 * See the Licence for the specific language governing permissions
 * and limitations under the Licence.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the Licence file. If applicable, add the
 * following below this CDDL HEADER, with the fields enclosed by
 * brackets "[]" replaced with your own identifying information:
 * Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2012 Ben Avison.  All rights reserved.
 * Portions Copyright 2013 Jeffrey Lee.
 * Use is subject to license terms.
 */

/** \file module.c
 * Module entry point dispatch.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "swis.h"

#include "Global/RISCOS.h"
#include "Global/NewErrors.h"
#include "Global/Services.h"
#include "Interface/SDIO.h"

#include "SyncLib/synclib.h"

#include "SDIOHdr.h"
#include "command.h"
#include "device.h"
#include "globals.h"
#include "message.h"
#include "probe.h"
#include "swi.h"
#include "gpiodebug.h"

/** Time between card detect polls, in cs */
#define CARD_DETECT_POLL_INTERVAL (10)

/* This function is autogenerated by ResGen, and returns a pointer to a
 * ResourceFS resource file data block */
extern void *Resources(void);

static void module_post_init(void);

#ifdef DEBUG_ENABLED
static bool module_initialised;
#endif

_kernel_oserror *module_initialise(const char *cmd_tail, int podule_base, void *pw)
{
  _kernel_oserror *e;
  IGNORE(cmd_tail);
  IGNORE(podule_base);

  g_module_pw = pw;

#ifndef ROM_MODULE
  e = _swix(ResourceFS_RegisterFiles, _IN(0), Resources());
  if (e != NULL)
    return e;
#else
  /* In ROM builds, all resource files live in the Messages module instead */
#endif

  e = _swix(MessageTrans_OpenFile, _INR(0,2), &g_message_fd, "Resources:$.Resources.SDIODriver.Messages", 0);
  if (e != NULL)
  {
#ifndef ROM_MODULE
    _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif
    return e;
  }

  synclib_init();
  gpiodebug_init();
#ifdef DEBUGLIB
  /* Set up debugging */
  debug_initialise(Module_Title, "", "");
  debug_set_device(HAL_OUTPUT);
  debug_set_unbuffered_files(TRUE);
#endif

  /* Now a quick bodge to speed up development */
#ifdef BEAGLEBOARD
  extern _kernel_oserror *beagleboard_initialise(void);
  e = beagleboard_initialise();
#endif
#ifdef RASPBERRYPI
  extern _kernel_oserror *raspberrypi_initialise(void);
  e = raspberrypi_initialise();
#endif

  /* The module needs to be on TickerV the whole time */
  if (e == NULL)
    e = _swix(OS_Claim, _INR(0,2), TickerV, module_tickerv_veneer, g_module_pw);

  if (e != NULL)
  {
    module_finalise(0, 0, 0);
    return e;
  }

  return NULL;
}

_kernel_oserror *module_finalise(int fatal, int podule, void *pw)
{
  IGNORE(fatal);
  IGNORE(podule);
  IGNORE(pw);

  /* Cleanup is the same as though all known devices have been removed */
  sdhcidevice_t *device;
  while (true)
  {
    spinrw_read_lock(&g_sdhci_lock);
    if (g_sdhci == NULL)
    {
      spinrw_read_unlock(&g_sdhci_lock);
      break;
    }
    device = g_sdhci->dev;
    spinrw_read_unlock(&g_sdhci_lock);
    device_removed(device);
  }

  _swix(OS_Release, _INR(0,2), TickerV, module_tickerv_veneer, g_module_pw);

#ifdef BEAGLEBOARD
  extern void beagleboard_finalise(void);
  beagleboard_finalise();
#endif
#ifdef RASPBERRYPI
  extern void raspberrypi_finalise(void);
  raspberrypi_finalise();
#endif
  
  _swix(OS_RemoveCallBack, _INR(0,1), module_card_insertion_veneer, g_module_pw);

  _swix(MessageTrans_CloseFile, _IN(0), &g_message_fd);
#ifndef ROM_MODULE
  _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif
  return 0;
}

void module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);
  
  switch (service_number)
  {
    case Service_Hardware:
    {
      uint32_t subreason = r->r[0] & 0xFF;
      struct device *device = (struct device *) r->r[2];
      if (subreason <= 1 && device->type == HALDeviceType_ExpCtl + HALDeviceExpCtl_SDIO)
      {
        switch (subreason)
        {
          case 0: device_added((sdhcidevice_t *) device); break;
          case 1: device_removed((sdhcidevice_t *) device); break;
        }
      }
      break;
    }
    case Service_ModulePostInit:
    {
      if(!strcmp((const char *) r->r[2],Module_Title))
      {
        /* Now that our SWI handler is active, we can scan for devices */
        module_post_init();
      }
      break;
    }
  }
}

_kernel_oserror *module_command(const char *arg_string, int argc, int cmd_no, void *pw)
{
  IGNORE(arg_string);
  IGNORE(argc);
  IGNORE(pw);

  switch (cmd_no)
  {
    case CMD_SDIODevices:
      return command_sdiodevices();
      
    case CMD_SDIOSlots:
      return command_sdioslots();
  }

  return NULL;
}

_kernel_oserror *module_swi(int swi_offset, _kernel_swi_regs *r, void *pw)
{
  IGNORE(pw);
  
  switch (swi_offset)
  {
    case SDIO_Initialise - SDIO_00:
      switch (r->r[0])
      {
        case SDIOInitialise_ResetBus:
          return swi_Initialise_reset_bus((r->r[1] & SDIOResetBus_BusMask) >> SDIOResetBus_BusShift);

        case SDIOInitialise_RescanSlot:
          return swi_Initialise_rescan_slot((r->r[1] & SDIORescanSlot_BusMask) >> SDIORescanSlot_BusShift,
                                            (r->r[1] & SDIORescanSlot_SlotMask) >> SDIORescanSlot_SlotShift);
          
        default:
          return MESSAGE_ERRORLOOKUP(true, SDIO_BadReason, "SDIO_Initialise");
      }
    
    case SDIO_Control - SDIO_00:
      switch (r->r[0])
      {
        case SDIOControl_TryLock:
          return swi_Control_try_lock((r->r[1] & SDIOControl_BusMask) >> SDIOControl_BusShift,
                                      (r->r[1] & SDIOControl_SlotMask) >> SDIOControl_SlotShift);

        case SDIOControl_Lock:
          return swi_Control_lock((r->r[1] & SDIOControl_BusMask) >> SDIOControl_BusShift,
                                  (r->r[1] & SDIOControl_SlotMask) >> SDIOControl_SlotShift);

        case SDIOControl_SleepLock:
          return swi_Control_sleep_lock((r->r[1] & SDIOControl_BusMask) >> SDIOControl_BusShift,
                                        (r->r[1] & SDIOControl_SlotMask) >> SDIOControl_SlotShift);

        case SDIOControl_Unlock:
          return swi_Control_unlock((r->r[1] & SDIOControl_BusMask) >> SDIOControl_BusShift,
                                    (r->r[1] & SDIOControl_SlotMask) >> SDIOControl_SlotShift);

        case SDIOControl_AbortAll:
          return swi_Control_abort_all((r->r[1] & SDIOControl_BusMask) >> SDIOControl_BusShift,
                                       (r->r[1] & SDIOControl_SlotMask) >> SDIOControl_SlotShift);
          
        case SDIOControl_AbortOp:
          return swi_Control_abort_op((r->r[1] & SDIOControl_BusMask) >> SDIOControl_BusShift,
                                      (r->r[1] & SDIOControl_SlotMask) >> SDIOControl_SlotShift,
                                      (sdioop_t *) r->r[2]);

        case SDIOControl_PollCardDetect:
          return swi_Control_poll_card_detect((r->r[1] & SDIOControl_BusMask) >> SDIOControl_BusShift,
                                              (r->r[1] & SDIOControl_SlotMask) >> SDIOControl_SlotShift);
          
        default:
          return MESSAGE_ERRORLOOKUP(true, SDIO_BadReason, "SDIO_Control");
      }
    
    case SDIO_Enumerate - SDIO_00:
      switch (r->r[0])
      {
        case SDIOEnumerate_Slots:
          return swi_Enumerate_slots((uint32_t *) &r->r[1], (uint32_t *) &r->r[2]);

        case SDIOEnumerate_Units:
          return swi_Enumerate_units((r->r[2] & SDIOEnumerate_BusMask) >> SDIOEnumerate_BusShift,
                                     (r->r[2] & SDIOEnumerate_SlotMask) >> SDIOEnumerate_SlotShift,
                                     (uint32_t *) &r->r[1], (uint32_t *) &r->r[2], (uint32_t *) &r->r[3], (uint32_t *) &r->r[4], (uint32_t *) &r->r[5]);

        default:
          return MESSAGE_ERRORLOOKUP(true, SDIO_BadReason, "SDIO_Enumerate");
      }

    case SDIO_ControllerFeatures - SDIO_00:
      return swi_ControllerFeatures((r->r[1] & SDIOController_BusMask) >> SDIOController_BusShift,
                                    (r->r[1] & SDIOController_SlotMask) >> SDIOController_SlotShift,
                                    r->r[0], (uint32_t *) &r->r[2]);

    case SDIO_ReadRegister - SDIO_00:
      return swi_ReadRegister((r->r[1] & SDIORegister_BusMask) >> SDIORegister_BusShift,
                              (r->r[1] & SDIORegister_SlotMask) >> SDIORegister_SlotShift,
                              ((uint32_t) r->r[1] & SDIORegister_RCAMask) >> SDIORegister_RCAShift,
                              r->r[0], (void *) r->r[2]);

    case SDIO_Op - SDIO_00:
      return swi_Op((sdioop_block_t *) r);
      
#if 0
    case SDIO_ClaimDeviceVector - SDIO_00:
      return swi_ClaimDeviceVector((r->r[0] & SDIOCDV_BusMask) >> SDIOCDV_BusShift,
                                   (r->r[0] & SDIOCDV_SlotMask) >> SDIOCDV_SlotShift,
                                   (r->r[0] & SDIOCDV_UnitMask) >> SDIOCDV_UnitShift,
                                   (void *) r->r[1],
                                   (void *) r->r[2]);
    
    case SDIO_ReleaseDeviceVector - SDIO_00:
      return swi_ReleaseDeviceVector((r->r[0] & SDIOCDV_BusMask) >> SDIOCDV_BusShift,
                                     (r->r[0] & SDIOCDV_SlotMask) >> SDIOCDV_SlotShift,
                                     (r->r[0] & SDIOCDV_UnitMask) >> SDIOCDV_UnitShift,
                                     (void *) r->r[1],
                                     (void *) r->r[2]);
#endif
    
    default:
      return MESSAGE_ERRORLOOKUP(false, SDIO_BadSWI, "SDIODriver");
  }
  
  return NULL;
}

_kernel_oserror *module_irq_handler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);
  return NULL;
}

static void module_post_init(void)
{
  uint32_t handle = 0;
  while (true)
  {
    sdhcidevice_t *device;
    _kernel_oserror *e = _swix(OS_Hardware, _INR(0,1)|_IN(8)|_OUTR(1,2),
                               HALDeviceType_ExpCtl + HALDeviceExpCtl_SDIO,
                               handle, 5, &handle, &device);
    if (e && e->errnum == ErrorNumber_HardwareBadReason)
      e = _swix(OS_Hardware, _INR(0,1)|_IN(8)|_OUTR(1,2),
                HALDeviceType_ExpCtl + HALDeviceExpCtl_SDIO,
                handle, 4, &handle, &device);
    if (e != NULL || handle == -1u)
      break;
    device_added(device);
  }
  
#ifdef DEBUG_ENABLED
  module_initialised = true;
#endif
}

_kernel_oserror *module_card_insertion_handler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);

#ifdef DEBUG_ENABLED
  /* Debug builds print to the screen during module init, which triggers callbacks before we're ready */
  if (!module_initialised)
    return NULL;
#endif

  spinrw_read_lock(&g_sdhci_lock);

  for (sdhcinode_t *sdhci = g_sdhci; sdhci != NULL; sdhci = sdhci->next)
  {
    for (uint32_t sloti = 0; sloti < sdhci->dev->slots; sloti++)
    {
      sdmmcslot_t *slot = sdhci->slot + sloti;
      if (slot->insertion_pending)
      {
        slot->insertion_pending = false;
        swi_Control_lock(sdhci->bus, sloti);
        mutex_lock(&slot->doing_card_detect);
        if (probe_bus(sdhci, sloti))
          device_units_attached(sdhci, sloti);
        mutex_unlock(&slot->doing_card_detect);
        swi_Control_unlock(sdhci->bus, sloti);
#ifdef DEBUG_ENABLED
        _swix(OS_CLI, _IN(0), "SDIODevices");
        _swix(OS_CLI, _IN(0), "SDIOSlots");
#endif
      }
    }
  }

  spinrw_read_unlock(&g_sdhci_lock);

  return NULL;
}

int module_tickerv_handler(_kernel_swi_regs *r, void *pw)
{
  IGNORE(r);
  IGNORE(pw);

  spinrw_read_lock(&g_sdhci_lock);

  /* Do card detection */
  static int poll_counter = CARD_DETECT_POLL_INTERVAL;
  if (--poll_counter == 0)
  {
    for (sdhcinode_t *sdhci = g_sdhci; sdhci != NULL; sdhci = sdhci->next)
      for (uint32_t sloti = 0; sloti < sdhci->dev->slots; sloti++)
        swi_Control_poll_card_detect(sdhci->bus, sloti);
    poll_counter = CARD_DETECT_POLL_INTERVAL;
  }

  spinrw_read_unlock(&g_sdhci_lock);

  return 1;
}
