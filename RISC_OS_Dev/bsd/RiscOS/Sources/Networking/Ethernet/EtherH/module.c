/*
 * Copyright (c) 2002, Design IT
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met: 
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of RISC OS Open Ltd nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/**************************************************************************
 * Title:       RISC OS Ethernet Driver Source
 * Author:      Douglas J. Berry, Gary Stephenson
 * File:        module.c
 *
 * Copyright © 1992 PSI Systems Innovations
 * Copyright © 1994 i-cubed Limited
 * Copyright © 1994 Network Solutions
 * Copyright © 2000 Design IT
 *
 ************************************************************************/

/*
 * Initial code supplied by Acorn Computers Ltd
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#include <kernel.h>
#include <swis.h>
#include "Global/Services.h"
#include "AsmUtils/irqs.h"

#include <sys/types.h>
#include <sys/dcistructs.h>
#include <sys/errno.h>
#include <sys/mbuf.h>

#include "if_eh.h"
#include "Init.h"
#include "EtherHHdr.h"
#include "module.h"

/* #define DEBUG */

struct swient {
        int (*swi_call)(_kernel_swi_regs *);      /* swi handler */
};

static struct swient eh_ent[] = {
    eh_dciversion,
    eh_inquire,
    eh_getnetworkmtu,
    eh_setnetworkmtu,
    eh_transmit,
    eh_filter,
    eh_stats,
    eh_multicastrequest,
    NULL
};

/*
 * Public data.
 */
extern void *eh_messages(void); /* Generated by 'resgen' */
volatile int mbuf_present = FALSE;
void *module_wsp = NULL;
struct mbctl MBCTL =
{
        0,                              /* opaque */
        sizeof(struct mbctl),           /* mbcsize */
        MBUF_MANAGER_VERSION,           /* mbcvers */
        0ul,                            /* flags */
        MINCONTIG,                      /* advminubs */
        ETHERMTU,                       /* advmaxubs */
        MINCONTIG,                      /* mincontig */
        0ul,                            /* spare1 */
        /*
         * Rest of the structure gets initialised
         * to zeroes due to the trailing comma
         */
};


/*
 * mb_present - check whether the mbuf manager is present or not,
 * using the Mbuf_Control SWI to do so.  returns 1 if manager
 * present, else 0.
 */
static int mb_present(void)
{
    _kernel_swi_regs r;

    /*
     * the control SWI with reason code 0 should *always*
     * succeed if the mbuf manager is loaded.
     */
    r.r[0] = 0;
    return((_kernel_swi(XOS_Bit | Mbuf_Control, &r, &r) == NULL) ? 1 : 0);
}


/*
 * mbuf memory manager session initialisation
 */
_kernel_oserror *mb_entryinit(void)
{
    _kernel_swi_regs r;
    r.r[0] = (int) &MBCTL;

    return _kernel_swi( XOS_Bit | Mbuf_OpenSession, &r, &r);
}


/*
 * mbuf memory manager session termination
 */
_kernel_oserror *mb_closesession(void)
{
    _kernel_swi_regs r;
    r.r[0] = (int) &MBCTL;

    return _kernel_swi( XOS_Bit | Mbuf_CloseSession, &r, &r);
}


/*
 * mbuf memory manager module initialisation
 */
static _kernel_oserror *init_mmanager(void)
{
    _kernel_oserror *e = NULL;

    /*
     * first see if mbuf manager module is present
     */
    if (mbuf_present == FALSE)
    {
        if (mb_present())
        {
            /* then try to open a session with it */
            e = mb_entryinit();
            if (e == NULL)
            {
              mbuf_present = TRUE;
#ifdef DEBUG
              printf("debug: mbuf session opened &MBCTL:%x\n",(int)&MBCTL);
#endif
            }
        }
    }
    return(e);
}


/*
 * Convert EUI48 to printable representation.
 */
const char *eh_sprint_mac(const u_char *ap)
{
        int i;
        static char etherbuf[18];
        char *cp = etherbuf;
        static const char digits[] = "0123456789abcdef";

        for (i = 0; i < 6; i++) {
                *cp++ = digits[*ap >> 4];
                *cp++ = digits[*ap++ & 0xf];
                *cp++ = ':';
        }
        *--cp = 0;
        return (etherbuf);
}


/*
 * Module Finalization code
 * OSS 4.52 20 Nov 2002 Made into a real module finalisation with new
 * cmhg keyword, not an at_exit() handler.
 */
_kernel_oserror * eh_finalise(int fatal, int podule, void *pw)
{
    _kernel_swi_regs r;

    eh_final(pw);

#ifndef ROM
    /* Deregister the messages for RAM based modules */
    r.r[0] = (int)eh_messages();
    _kernel_swi(XOS_Bit | ResourceFS_DeregisterFiles, &r, &r);
#endif

    UNUSED(fatal);
    UNUSED(podule);
    
    return NULL;
}


/*
 * Module Initialization code.
 */
_kernel_oserror *eh_initialise(const char *cmd_tail, int pbase, void *pw)
{
    _kernel_oserror *e = NULL;
    _kernel_swi_regs r;
    module_wsp = pw;
    /*
     * If module has been loaded from ROM then pbase != 0,
     * so rely on postinit service call to tidy things up later, e.g. setting
     * DCR register on 600 card into proper state
     * unless we have been reinited from a podule in which case there isn't a postinit!
     */
    if (pbase == 0)
       pre_init = FALSE;

#ifndef ROM
    /* Register the messages for RAM based modules */
    r.r[0] = (int)eh_messages();
    e = _kernel_swi(XOS_Bit | ResourceFS_RegisterFiles, &r, &r);
    if (e != NULL) return e;
#endif

    eh_init();
    if (ehcnt == 0)
    {
        e = eh_error(INETERR_IFBAD);
    }

    if (e == NULL)
    {
        e = init_mmanager();
#ifdef DEBUG
        printf("debug: mbuf manager init %s\n", (e == NULL) ? "OK" : "fail");
#endif
    }

#ifndef ROM
    if (e != NULL)
    {
        r.r[0] = (int)eh_messages();
        _kernel_swi(XOS_Bit | ResourceFS_DeregisterFiles, &r, &r);
    }
#endif

    UNUSED(cmd_tail);
    
    return(e);
}


/*
 * Module Service Call handler
 */
void eh_sc_handler(int sn, _kernel_swi_regs *r, void *pw)
{
    struct eh_softc *eh;
    struct chaindib *chdib, *oldhead;
    u_char *private;
    int i, status;

    switch(sn) {
        case Service_EnumerateNetworkDrivers:
            /* only respond to this if pre_init is FALSE because we haven't actually
             * completed the initialisiation yet
             */

            if (pre_init == FALSE)
            {
                oldhead = (ChDibRef) r->r[0];
#ifdef DEBUG
                printf("debug: Service_EnumerateNetworkDrivers pre_init %d oldhead:%x\n", pre_init, (int) oldhead);
#endif

                /* for (i = 0; i < ehcnt; i++) */
                for (i = ehcnt-1; i > -1; i--)
                {
                    eh = eh_softc[i];
                    chdib = (ChDibRef) malloc(sizeof(ChDib));
                    if (chdib != NULL)
                    {
                       chdib->chd_next = oldhead;
                       chdib->chd_dib = eh->eh_dib;
                       oldhead = chdib;
                    }
                }

                r->r[0] = (int)oldhead;
#ifdef DEBUG
                printf("debug: Service_EnumerateNetworkDrivers oldhead:%x\n", (int)oldhead);
#endif
            }
            break;

        case Service_DCIProtocolStatus:
            private = (u_char *) r->r[0];
            status = r->r[2];
#ifdef DEBUG
            printf("debug: Service_DCIProtocolStatus private ptr:%x status:%x\n",(int)private, status);
#endif
            if (status == DCIPROTOCOL_DYING)
            {
                /* protocol module is terminating */
                for (i = 0; i < ehcnt; i++)
                {
#ifdef DEBUG
                    printf("debug: private:%x i:%d\n",(int) private, i);
#endif
                    free_filter(eh_softc[i], -1, private);
                }
            }
            break;

        case Service_MbufManagerStatus:
#ifdef DEBUG
            printf("debug: mbuf manager service call:%x\n",r->r[0]);
#endif
            switch (r->r[0]) {
                case MbufManagerStatus_Started:
                    init_mmanager();
                    break;

                case MbufManagerStatus_Stopping:
                    mb_closesession();
                    mbuf_present = FALSE;
                    break;

                default:
                    break;
            }
            break;

        case Service_PreReset:
            pre_reset = TRUE;
            eh_softreset();
            break;

        case Service_PostInit:
            eh_postinit();
            break;

        default:
            break;
    }
    
    UNUSED(pw);
}


/*
 * Module SWI handler
 */
_kernel_oserror *eh_swi_handler(int swinum, _kernel_swi_regs *r, void *pw)
{
    struct swient *callp;
    int    error, oldstate;

    if (swinum >= (sizeof(eh_ent) / sizeof(struct swient)))
        return error_BAD_SWI;

    if (ehcnt == 0)
    {
        SETDCI4ERRNO(error, ENXIO);
    }
    else
    {
        callp = &eh_ent[swinum];
        oldstate = ensure_irqs_on();
        error = (*(callp->swi_call))(r);
        restore_irqs(oldstate);
    }

    UNUSED(pw);

    return eh_error(error);
}


/*
 * Module CLI handler
 */
_kernel_oserror *eh_cli_handler(const char *arg_string, int arg_count, int cmd_no, void *pw)
{
   if (ehcnt == 0)
       return eh_error(INETERR_IFBAD);
   else
   {
       switch(cmd_no) {
           case CMD_EHInfo:
               eh_statshow();
               break;

           case CMD_EHTest:
               eh_ehtest();
               break;

#ifdef DRIVER16BIT
           case CMD_EHVirtual:
               return eh_cmos_virtual(arg_string, arg_count);

           case CMD_EHConnection:
               /* OSS 16 June 2001 *Configure EHConnection for E600 cards */
               return eh_cmos_connection(arg_string, arg_count);
#endif
           default:
               break;
       }
   }

   UNUSED(pw);
#ifdef DRIVER8BIT
   UNUSED(arg_count);
   UNUSED(arg_string);
#endif
   
   return NULL;
}


/*
 * Module error handler
 */
_kernel_oserror *eh_error(int error)
{
    static _kernel_oserror _eh_errblk = { 0, "" };
    _kernel_swi_regs r;
    int msgtrans_control[4];
    char token[5], number[9];

    if (error)
    {
        /* An error occurred */
        r.r[0] = (int)msgtrans_control;
        r.r[1] = (int)Module_MessagesFile;
        r.r[2] = 0;
        if (_kernel_swi(XOS_Bit | MessageTrans_OpenFile, &r, &r) == NULL)
        {
            /* Lookup the error */
            sprintf(token, "E%d", error & 0xFF);
            sprintf(number, "%X", error);
            r.r[0] = (int)msgtrans_control;
            r.r[1] = (int)token;
            r.r[2] = (int)_eh_errblk.errmess;
            r.r[3] = sizeof(_eh_errblk.errmess);
            r.r[4] = (int)number; /* Catchall internal error */ 
            _kernel_swi(XOS_Bit | MessageTrans_Lookup, &r, &r);

            r.r[0] = (int)msgtrans_control;
            _kernel_swi(XOS_Bit | MessageTrans_CloseFile, &r, &r);
        }
        else
        {
            /* Can't open the messages, use english */
            sprintf(_eh_errblk.errmess, "EtherH module error &%X", error);
        }
        _eh_errblk.errnum = error;
        return &_eh_errblk;
    }
    return NULL;
}


/*
 * Module message lookup
 */
const char *eh_message(int id, const char *arg0, const char *arg1, const char *arg2)
{
    static char string[128];
    _kernel_swi_regs r;
    int msgtrans_control[4];
    char token[5];

    /* An error occurred */
    r.r[0] = (int)msgtrans_control;
    r.r[1] = (int)Module_MessagesFile;
    r.r[2] = 0;
    if (_kernel_swi(XOS_Bit | MessageTrans_OpenFile, &r, &r) == NULL)
    {
        /* Lookup the error */
        sprintf(token, "M%d", id);
        r.r[0] = (int)msgtrans_control;
        r.r[1] = (int)token;
        r.r[2] = (int)string;
        r.r[3] = sizeof(string);
        r.r[4] = (int)arg0;
        r.r[5] = (int)arg1;
        r.r[6] = (int)arg2;
        _kernel_swi(XOS_Bit | MessageTrans_Lookup, &r, &r);

        r.r[0] = (int)msgtrans_control;
        _kernel_swi(XOS_Bit | MessageTrans_CloseFile, &r, &r);
    }
    else
    {
        /* Can't open the messages, return something */
        sprintf(string, "EtherH module message &%X", id);
    }
    return string;
}


/* EOF module.c */
