; This source code in this file is licensed to You by Castle Technology
; Limited ("Castle") and its licensors on contractual terms and conditions
; ("Licence") which entitle you freely to modify and/or to distribute this
; source code subject to Your compliance with the terms of the Licence.
; 
; This source code has been made available to You without any warranties
; whatsoever. Consequently, Your use, modification and distribution of this
; source code is entirely at Your own risk and neither Castle, its licensors
; nor any other person who has contributed to this source code shall be
; liable to You for any loss or damage which You may suffer as a result of
; Your use, modification or distribution of this source code.
; 
; Full details of Your rights and obligations are set out in the Licence.
; You should have received a copy of the Licence with this source code file.
; If You have not received a copy, the text of the Licence is available
; online at www.castle-technology.co.uk/riscosbaselicence.htm
; 
; Title:   s.modulefp
; Purpose: Wrappers to allow floating point use in modules
;

; This function should be called before doing any floating point operations
; in a module. It cannot be called from interrupt routines. Note that if
; the caller was on the verge of generating a floating point exception (e.g.
; divide by zero), then the exception will be generated by your own
; floating point code instead. Since raising your own exceptions would be
; very ugly, all exceptions are disabled in the FPSR setup.
;
; Remember that the routine which calls this function may not then start
; using floating point code itself, it must invoke another APCS routine
; to do that. You must have a 32-bit FPEmulator module (there is no 'Z' in
; the help string).

; Pre-condition: processor is in SVC26 or SVC32 mode, not in an interrupt
;                routine - i.e. use of this call will make a SWI
;                non-reentrant.
;
;                It is assumed that you have a 32-bit FPEmulator module
;                on your system.
;
; Post-condition: processor is in same mode as on entry, now safe to call
;                 other APCS routines that use floating point.

        AREA    |asmutils$modulefp$$Code|,CODE,READONLY,PIC

        GET     hdr:ListOpts
        GET     hdr:Macros
        GET     hdr:System
        GET     hdr:Machine.<Machine>
        GET     hdr:APCS.<APCS>

        EXPORT  modulefp_enable
        EXPORT  modulefp_disable

        [ No32bitCode :LAND: No26bitCode
        ! 1, "This code cannot be used in No26bitCode and No32bitCode!"
        ]

; Assembler equivalent of modulefp_buf structure

        ^       0
fpsr    #       4
regs    #       12 * 4

; extern void modulefp_enable(modulefp_buf * regs);

modulefp_enable

        RFS     r1
        STR     r1,[r0,#fpsr]
        MOV     r1,#&00000000 ; All exceptions suppressed
        WFS     r1

        SFM     f0,4,[r0,#regs]

        Return  ,LinkNotStacked

; Once finished with floating point code, you MUST call this function to
; restore the previous state of the system.

; extern void modulefp_disable(modulefp_buf * regs);

modulefp_disable

        LFM     f0,4,[r0,#regs]

        LDR     r1,[r0,#fpsr]
        WFS     r1

        Return  ,LinkNotStacked

        END
