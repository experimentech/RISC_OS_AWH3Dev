REM This source code in this file is licensed to You by Castle Technology
REM Limited ("Castle") and its licensors on contractual terms and conditions
REM ("Licence") which entitle you freely to modify and/or to distribute this
REM source code subject to Your compliance with the terms of the Licence.
REM
REM This source code has been made available to You without any warranties
REM whatsoever. Consequently, Your use, modification and distribution of this
REM source code is entirely at Your own risk and neither Castle, its licensors
REM nor any other person who has contributed to this source code shall be
REM liable to You for any loss or damage which You may suffer as a result of
REM Your use, modification or distribution of this source code.
REM
REM Full details of Your rights and obligations are set out in the Licence.
REM You should have received a copy of the Licence with this source code file.
REM If You have not received a copy, the text of the Licence is available
REM online at www.castle-technology.co.uk/riscosbaselicence.htm
REM
REM > Main

ON ERROR ERROR EXT ERR,LEFT$(REPORT$,240) +" ("+STR$(ERL)+")"
PROCinitialise
SYS"OS_ReadMonotonicTime" TO timex%:timex%+=100

WHILE TRUE
 err% =FALSE
 ON ERROR LOCAL :err% =TRUE
      
 IF err% =TRUE THEN
  ON ERROR :ON ERROR OFF :ERROR ERR,LEFT$(REPORT$,240) +" ("+STR$(ERL)+")"
  PROCerr_report(ERR,REPORT$,%11)
 ELSE 
  SYS"XWimp_PollIdle",0,Q%,timex% TO A%
  CASE A% OF
  WHEN 0    :PROCnudge
  WHEN 1    :PROCredraw_browser
  WHEN 2    :PROCopenwindow
  WHEN 3    :cancel%=TRUE
             PROCclosewindow(!Q%)
  WHEN 5    :IF !Q%=m_wind% THEN
              IF alarm_counter%=0 THENPROCset_timex_for_next_second
              alarm_counter%=global_timeout%
             ENDIF
  WHEN 6    :PROCcheckmouse(!Q%,Q%!4,Q%!8,Q%!12,Q%!16)
  WHEN 7    :PROCdecodedrag
  WHEN 8    :PROCkey(!Q%,Q%!4,Q%!24)
  WHEN 9    :PROCmenuselect(Q%)
  WHEN 17,18:PROCreceive(A%)
  WHEN 19   :PROCacknowledge
  ENDCASE
 ENDIF
ENDWHILE
END

REM *************************************************************************
REM Initialisation
REM *************************************************************************

DEFPROCinitialise
 PROCmsg_init("Alarm:Messages")
 PROCinit_constants
 
 REM This has to be declared here because the increased use
 REM of messages has meant that this block is now use
 REM practically everywhere
 REM Because it is also used for loading templates into (temporarily)
 REM we must make sure that it is big enough for the largest template
 REM we are going to load, hence FNQsize.
 DIM Q% FNQsize
 
 PROCinit_heap_constants
 PROCinit_arrays
 PROCinit_date_and_time
 PROCinit_task
 PROCinit_templates
 PROCinit_globals
 PROCinit_config
 PROCinit_codevar
 PROCinit_timediff
 PROCload_alarms_into_memory(ra$)
ENDPROC
:
DEFPROCinit_date_and_time
 width_am%=0
 width_we%=1
 width_w3%=2
 width_dy%=3
 width_st%=4
 width_mo%=5
 width_m3%=6
 width_tz%=7
 DIM widths%(7)
 ?cur_clock%=3:SYS"OS_Word",14,cur_clock%
 SYS"Territory_ReadCalendarInformation",-1,cur_clock%,Q2%
 widths%(width_am%)=Q2%!16
 widths%(width_we%)=Q2%!20
 widths%(width_w3%)=Q2%!24
 widths%(width_dy%)=Q2%!28
 widths%(width_st%)=Q2%!32
 widths%(width_mo%)=Q2%!36
 widths%(width_m3%)=Q2%!40
 widths%(width_tz%)=Q2%!44
ENDPROC
:
DEFPROCinit_task
 LOCAL E%,length%,s$
 task_id$=FNmsg_0("TaskID")
 REM define the block of messages wanted by Alarm
 Q%!0=2       :REM Message_DataSaveAck
 Q%!4=3       :REM Message_DataLoad
 Q%!8=5       :REM Message_DataOpen
 Q%!12=8      :REM Message_PreQuit
 Q%!16=10     :REM Message_SaveDesktop
 Q%!20=&500   :REM Message_AlarmSet
 Q%!24=&501   :REM Message_AlarmGoneOff
 Q%!28=&502   :REM Message_HelpRequest
 Q%!32=&400C0 :REM Message_MenuWarning
 Q%!36=&400C1 :REM Message_ModeChange
 Q%!40=&400C2 :REM Message_TaskInitialise
 Q%!44=&400C9 :REM Message_MenusDeleted
 Q%!48=&400CF :REM Message_FontChanged
 Q%!52=0
 SYS"Wimp_Initialise",310,&4B534154,task_id$,Q% TO wimpversion%,taskid%
 REM work out whether or not a filename was provided on the command line
 SYS"OS_GetEnv" TO E%
 SYS"OS_ReadArgs","/g,quit/s,/g,/g",E%,Q%,2048
 E%=Q%!12
 s$=""
 IFE% THEN
  REM The filename is present
  length%=!E% AND &FFFF
  E%+=2
  WHILE length%
   s$+=CHR$(?E%)
   E%+=1
   length%-=1
  ENDWHILE
 ENDIF
 IFs$<>"" THENra$=s$

 REM Try loading the browser redraw code
 SYS"OS_File",17,"Alarm:Code" TO t%,,,,I%
 IFt%<>1 PROCok(FNmsg_0("OkayD1"))
 DIM assembler% I%
 SYS"OS_File",16,"Alarm:Code",assembler%,&80000000:REM Use R2 address and flush I cache
ENDPROC
:
DEFPROCinit_heap_constants
 LOCAL ws%
 ws%=0
 REM WARNING!
 REM If you make ANY changes to the following workspace usage,
 REM it must be mirrored in the browser source code
 alarm_next%       =FNws_claim(ws%,4)  :REM ptr to next alarm in this linked list
 alarm_prev%       =FNws_claim(ws%,4)  :REM ptr to previous alarm in list
 alarm_fileptr%    =FNws_claim(ws%,4)  :REM ptr to alarm in data file
 alarm_year%       =FNws_claim(ws%,4)  :REM *local* year for alarm to go off on
 alarm_month%      =FNws_claim(ws%,4)  :REM *local* month for alarm to go off on
 alarm_date%       =FNws_claim(ws%,4)  :REM *local* date for alarm to go off on
 alarm_hours%      =FNws_claim(ws%,4)  :REM *local* hours for alarm to go off on
 alarm_minutes%    =FNws_claim(ws%,4)  :REM *local* minutes for alarm to go off on
 valid_year%       =FNws_claim(ws%,4)  :REM validated *local* year for alarm to go off on
 valid_month%      =FNws_claim(ws%,4)  :REM validated *local* month for alarm to go off on
 valid_date%       =FNws_claim(ws%,4)  :REM validated *local* date for alarm to go off on
 valid_hours%      =FNws_claim(ws%,4)  :REM validated *local* hours for alarm to go off on
 valid_minutes%    =FNws_claim(ws%,4)  :REM validated *local* minutes for alarm to go off on
 alarm_line1%      =FNws_claim(ws%,41) :REM line 1 of the alarm text
 alarm_line2%      =FNws_claim(ws%,41) :REM line 2 of the alarm text
 alarm_line3%      =FNws_claim(ws%,41) :REM line 3 of the alarm text
 alarm_repeating%  =FNws_claim(ws%,1)  :REM is this a repeating alarm?
 alarm_repeat_rate%=FNws_claim(ws%,1)  :REM repeat rate for this alarm
 alarm_repeat_mult%=FNws_claim(ws%,1)  :REM repeat multiplier for this alarm
 alarm_urgent%     =FNws_claim(ws%,1)  :REM is this an urgent alarm?
 alarm_applalarm%  =FNws_claim(ws%,1)  :REM is this an application alarm?
 alarm_taskalarm%  =FNws_claim(ws%,1)  :REM is this a task alarm?
 alarm_fvdywk%     =FNws_claim(ws%,1)  :REM does this alarm fit into a working week?
 alarm_selected%   =FNws_claim(ws%,1)  :REM has this alarm been selected on the viewer?
 alarm_SIZE%       =FNws_claim(ws%,1)

 SYS"OS_ReadMemMapInfo" TO heap_psize%
 SYS"OS_GetEnv" TO ,heap_start%
 heap_size%=0
ENDPROC
:
DEFPROCinit_config
 LOCAL i%,j%
 SYS"OS_Byte",161,&DC TO ,,i%
 IF(i% AND %111)=0 i%=%00001001
 format%        =(i% AND %111)
 alarm_confirm% =((i% AND %1000)<>0)
 alarm_autosave%=((i% AND %10000)<>0)
 fivedayweek%   =((i% AND %100000)<>0)
 silent_alarm%  =((i% AND %1000000)<>0)
 $Q1%=FNread_system_string("Alarm$Options","")
 REM format is -timeout value -weekwork days -format string
 SYS"XOS_ReadArgs","timeout/k,weekwork/k,format/k",Q1%,Q%,2048 TO ;i%
 IF(i% AND 1) THEN !Q%=0:Q%!4=0:Q%!8=0

 REM Timeout
 IFQ%!0 THEN
  global_timeout%=VAL(FNrtoz(!Q%))
 ELSE
  global_timeout%=10
 ENDIF

 REM Working week
 IFQ%!4 THEN
  global_weekwork%=VAL(FNrtoz(Q%!4))
 ELSE
  ?cur_clock%=3:SYS"OS_Word",14,cur_clock%
  SYS"Territory_ReadCalendarInformation",-1,cur_clock%,Q2%
  global_weekwork%=0
  FORi%=1 TO 7
   IFi%>=Q2%!0 AND i%<=Q2%!4 global_weekwork%+=(1<<(i%-1))
  NEXT
 ENDIF

 REM User format
 IFQ%!8 THEN
  PROCset_string(setup%,ic_setup_user_string%,FNrtoz(Q%!8))
 ELSE
  PROCset_string(setup%,ic_setup_user_string%,"%z12:%mi:%se %pm. %zdy/%zmn/%yr")
 ENDIF

 REM Timeout
 IFglobal_timeout%=-1 THEN
  PROCset_string(setup%,ic_setup_beep_time%,"10")
  PROCsetstate(setup%,ic_setup_cont_beep%,1<<21,1<<21)
  PROCsetstate(setup%,ic_setup_beep_off%,0,1<<21)
 ELSE
  PROCset_string(setup%,ic_setup_beep_time%,STR$(global_timeout%))
  PROCsetstate(setup%,ic_setup_cont_beep%,0,1<<21)
  PROCsetstate(setup%,ic_setup_beep_off%,1<<21,1<<21)
 ENDIF
 alarm_counter%=global_timeout%

 REM Working week
 j%=global_weekwork%
 FORi%=0 TO 6
  IF(j% AND 1) THEN
   PROCsetstate(setup%,ic_setup_sun%+i%,1<<21,1<<21)
  ELSE
   PROCsetstate(setup%,ic_setup_sun%+i%,0,1<<21)
  ENDIF
  j%=j%>>1
 NEXT

 REM User format
 userformat$=FNread_string(setup%,ic_setup_user_string%)
 PROCset_format(format%)
ENDPROC
:
DEFPROCinit_globals
 LOCAL f%
 SYS"OS_Byte",161,&1C TO ,,f%
 IF(f% AND 2)=0 THEN
  REM CMOS has turned DragASprite off
  save_start%=-1
  save_stop%=-1
 ELSE
  REM Use DragASprite if available
  SYS"XOS_SWINumberFromString",,"DragASprite_Start" TO save_start%;f%
  IF(f% AND 1) save_start%=-1
  SYS"XOS_SWINumberFromString",,"DragASprite_Stop" TO save_stop%;f%
  IF(f% AND 1) save_stop%=-1
 ENDIF
 menuhand%=-1
 current_action%=-1
 cancel%=FALSE
 modified%=FALSE
 autosaved%=FALSE
 doing_deleting%=FALSE
 doing_shutdown%=0
 ictime%=-1
 alarm_head%=0
 alarm_count%=0
 alarm_set%=FALSE
 user_alarm_set%=FALSE
 alarm_original_pointer%=0
 alarm_warned%=FALSE
 timex%=0
 cur_textlen% =0
 cur_fonty% =-1
 cur_format$ =""
 spr_area% =0
ENDPROC
:
DEFPROCinit_codevar
 LOCAL len%,R%,P%,free_code%,buffer%,end_code%
 SYS"XOS_ReadVarVal","Alarm$Free",0,-1,0 TO ,,len%
 IF len% < 0 THEN
  REM Already defined, don't recreate it
 ELSE
  FOR R% =0 TO 2 STEP 2
  P% =Q%
  [OPT R%
  .free_code%
   MOV pc,r14 ;no write
   STMFD r13!,{r14}
 
   MVN r0,#0 ;=-1
   MVN r1,#0 ;=-1
   SWI "XWimp_SlotSize"
 
   MOV r0,r2
   ADR r1,buffer%
   MOV r2,#16
   SWI "XOS_ConvertFileSize"
 
   SUB r2,r1,r0 ;len =term -buf start
   LDMFD r13!,{pc}
  .buffer%
   EQUS STRING$(16,"*")
   ALIGN
  .end_code%
  ]
  NEXT
  SYS"OS_SetVarVal","Alarm$Free",free_code%,end_code%-free_code%,0,16
ENDIF  
ENDPROC
:
DEFPROCinit_templates
 LOCAL ind%

 REM Readability of icon numbers
 ic_warning_discard%=2
 ic_warning_save%=3

 ic_message_at1%=0
 ic_message_at2%=1
 ic_message_gap%=2
 ic_message_msg1%=3 : REM Next 6 in order, increments of 1
 ic_message_msg2%=4
 ic_message_msg3%=5
 ic_message_msg4%=6
 ic_message_msg5%=7
 ic_message_msg6%=8
 ic_message_accept%=9

 ic_setup_silent%=0
 ic_setup_working_week%=1
 ic_setup_cont_beep%=11
 ic_setup_beep_off%=15
 ic_setup_beep_time%=2
 ic_setup_seconds_label%=38
 ic_setup_auto_database%=14
 ic_setup_confirm_del%=13
 ic_setup_format_label%=4
 ic_setup_format_frame%=3
 ic_setup_ok%=5
 ic_setup_cancel%=6
 ic_setup_user_string%=30
 ic_setup_analogue_ws%=25 : REM Next 5 in order, increments of 1
 ic_setup_analogue_wos%=26
 ic_setup_hh_mm%=27
 ic_setup_hh_mm_ss%=28
 ic_setup_user_def%=29
 ic_setup_sun%=31 : REM Next 7 in order, increments of 1
 ic_setup_mon%=32
 ic_setup_tue%=33
 ic_setup_wed%=34
 ic_setup_thu%=35
 ic_setup_fri%=36
 ic_setup_sat%=37

 ic_save_icon%=3
 ic_save_name%=2
 ic_save_ok%=0

 ic_info_version%=3

 ic_deleting_msg1%=0
 ic_deleting_msg2%=3
 ic_deleting_delete%=1
 ic_deleting_keep%=2

 ic_alarm_year_delta%=51
 ic_alarm_year_label%=57
 ic_alarm_day_delta%=52
 ic_alarm_day_label%=56
 ic_alarm_hour_delta%=50
 ic_alarm_hour_label%=55
 ic_alarm_min_delta%=49
 ic_alarm_min_label%=54
 ic_alarm_dow_label%=46
 ic_alarm_ampm_label%=48
 ic_alarm_cur_year%=2
 ic_alarm_cur_mon%=47
 ic_alarm_cur_day%=7
 ic_alarm_cur_hour%=11
 ic_alarm_cur_min%=14
 ic_alarm_msg_label%=31
 ic_alarm_line1%=16
 ic_alarm_line2%=17
 ic_alarm_line3%=18
 ic_alarm_urgent%=5
 ic_alarm_task%=29
 ic_alarm_wweek%=30
 ic_alarm_repeat%=19
 ic_alarm_every%=32
 ic_alarm_every_many%=27
 ic_alarm_every_mins%=20
 ic_alarm_every_hours%=21
 ic_alarm_every_days%=22
 ic_alarm_every_weeks%=23
 ic_alarm_every_months%=24
 ic_alarm_every_years%=25
 ic_alarm_onthe%=33
 ic_alarm_onthe_rep_day%=35
 ic_alarm_onthe_day%=38
 ic_alarm_onthe_rep_month%=41
 ic_alarm_onthe_month_label%=44
 ic_alarm_ofevery_label%=43
 ic_alarm_ok_hi%=45
 ic_alarm_cancel_hi%=60
 ic_alarm_ok_lo%=58
 ic_alarm_cancel_lo%=59
 ic_alarm_adj_yu%=13
 ic_alarm_adj_yd%=12
 ic_alarm_adj_mu%=10
 ic_alarm_adj_md%=9
 ic_alarm_adj_du%=8
 ic_alarm_adj_dd%=6
 ic_alarm_adj_hu%=0
 ic_alarm_adj_hd%=1
 ic_alarm_adj_minu%=3
 ic_alarm_adj_mind%=4
 ic_alarm_adj_repu%=28
 ic_alarm_adj_repd%=26
 ic_alarm_adj_onthe_drepu%=36
 ic_alarm_adj_onthe_drepd%=34
 ic_alarm_adj_onthe_du%=39
 ic_alarm_adj_onthe_dd%=37
 ic_alarm_adj_onthe_mrepu%=42
 ic_alarm_adj_onthe_mrepd%=40
 
 PROCopen_templates
 
 a_wind% =FNload_template("alarm")
 m_wind% =FNload_template("message")
 setup% =FNload_template("setup")
 info% =FNload_template("info")
 browser% =FNload_template("browser")
 browse1% =FNload_template("browse1")
 warning% =FNload_template("warning")
 deleting% =FNload_template("deleting")
 slow% =FNload_template("slow")
 save% =FNload_template("save")

 SYS"Wimp_CloseTemplate"

 !Q% =save%
 Q%!4 =ic_save_name%
 SYS"Wimp_GetIconState",,Q%
 filename%=Q%!28
 
 PROCset_string(info%,ic_info_version%,FNmsg_0("_Version"))

 !Q%=browser%:Q%!4=2:SYS"Wimp_GetIconState",,Q%:SYS"Wimp_DeleteIcon",,Q%
 assembler%!4=Q%!16:REM right hand end of day icon
 !Q%=browser%:Q%!4=0:SYS"Wimp_GetIconState",,Q%:SYS"Wimp_DeleteIcon",,Q%
 assembler%!8=Q%!16:REM right hand end of date icon
 !Q%=browser%:Q%!4=1:SYS"Wimp_GetIconState",,Q%:SYS"Wimp_DeleteIcon",,Q%
 assembler%!12=Q%!16:REM right hand end of time icon
ENDPROC
:
DEFPROCinit_constants
 LOCAL I%,J%
 def_fn$="Choices:Alarm.Alarms"
 ra$=def_fn$
 setting%=0
 changing%=2
 mess1%=16
 mess2%=17
 mess3%=18
 errok%=1
 errfatal%=3
ENDPROC
:
DEFPROCinit_arrays
 LOCAL I%,t%
 REM Various alarm pointers are used:
 REM 0 : alarm currently being modified by the user
 REM 1 : alarm currently being monitored by !Alarm
 REM 2 : general scratch pointer
 DIM alarms%(2)
 DIM sin(59),cos(59)
 DIM Q1% 1024
 DIM Q2% 1024
 DIM cur_clock% 6
 DIM deftime% 5
 DIM buffers% 64
 DIM menufree% 256:menuend%=menufree%+256
 DIM validation_buffer% 64
 DIM menu_ws% 256:menu_curws%=menu_ws%:menu_maxws%=256

 REM Need to claim one block of an alarm record
 REM for the clock setting
 DIM t% alarm_SIZE%:alarms%(2)=t%

 REM Build some angles lookup tables
 FOR I%=0 TO 59
  sin(I%)=SINRAD(I%*6)
  cos(I%)=COSRAD(I%*6)
 NEXT
ENDPROC
:
REM *************************************************************************
REM Poll code handlers
REM *************************************************************************

DEFPROCnudge
 LOCAL U%
 PROCgettime
 PROCredraw_icon(-1,ictime%)
 IF alarm_set% THEN
  REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCnudge(1)")
  U%=alarm_urgent%?alarms%(1)
  IF NOT(alarm_detected%) PROCcheck_date_and_time(U%)
  IF FNalarm_sounding(U%) THEN
   VDU 7
   IF alarm_counter%>0 alarm_counter%-=1
  ENDIF
 ENDIF
 IF secs_used% OR FNalarm_sounding(U%) THEN
  PROCset_timex_for_next_second
 ELSE
  SYS"OS_ReadMonotonicTime" TO timeslip%
  U%=VAL(FNconverttime(cur_clock%,"%SE"))
  timeslip%-=timex%
  timex%+=timeslip% - (timeslip% MOD 100) + 100*(60-U%)
 ENDIF
ENDPROC
:
DEFPROCredraw_browser
 LOCAL A%,B%,C%,D%,more%
 SYS"Wimp_RedrawWindow",,Q% TO more%
 A%=more%
 B%=Q%
 C%=alarm_head%
 D%=msg_desc%
 CALLassembler%
ENDPROC
:
DEFPROCopenwindow
REM task_buff%  = original open window block
REM Q1% = pane window state block
REM Q2% = edit window state block
IF!Q%=browser% THEN
 REM get current state of pane window
 !Q1%=browse1%:SYS"Wimp_GetWindowState",,Q1%
 REM if edit window is above pane window, open the
 REM edit window behind it
 IF Q1%!28 = Q%!28 Q%!28=browse1%
 REM get current state of edit window
 !Q2%=browser%:SYS"Wimp_GetWindowState",,Q2%
 REM if edit window is moving in the direction of
 REM the pane window, open the pane first
 SYS"Wimp_OpenWindow",,Q%:REM open window & get updated coordinates
 IF Q%!28=-2 THEN
  !Q2%=browser%:SYS"Wimp_GetWindowState",,Q2%
  Q%!28=Q2%!28
 ENDIF
 PROCopen_top_pane(Q%,browse1%)
ELSE
 IF!Q%<>browse1% SYS"Wimp_OpenWindow",,Q%
ENDIF
ENDPROC
:
DEFPROCclosewindow(H%)
 LOCAL error%
 !Q%=H%:PROCtell_pinboard(H%)
 SYS"Wimp_CloseWindow",,Q%
 IF H%=browser% !Q%=browse1%:SYS"Wimp_CloseWindow",,Q%
 IF H%=a_wind% THEN
  REM following bit relies on the fact that
  REM alarm_original_pointer% and alarms%(1) are pointing
  REM to the correct records!
  IF alarm_original_pointer%<>0 AND alarms%(1)<>0 THEN
   REM IFFNcheck_pointer PROCcheck_pointer(alarm_original_pointer%,"PROCclosewindow(alarm_original_pointer%)")
   REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCclosewindow(1)")
   IF (alarm_original_pointer%=alarms%(1)) AND NOT(cancel%) THEN
    !Q%=m_wind%
    SYS"Wimp_CloseWindow",,Q%
   ENDIF
  ENDIF
  IF current_action%<>-1 PROCcancel_current_action
 ENDIF
 IF H%=m_wind% THEN
  REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCclosewindow(1)")
  REM following bit relies on the fact that
  REM alarm_original_pointer% and alarms%(1) are pointing
  REM to the correct records!
  IF alarm_original_pointer%<>0 AND alarms%(1)<>0 THEN
   REM IFFNcheck_pointer PROCcheck_pointer(alarm_original_pointer%,"PROCclosewindow(alarm_original_pointer%)")
   IF (alarm_original_pointer%=alarms%(1)) AND current_action%<>setting% THEN
    !Q%=a_wind%
    SYS"Wimp_CloseWindow",,Q%
    PROCcancel_current_action
   ENDIF
  ENDIF
  IF alarm_repeating%?alarms%(1) THEN
   PROCremove_alarm_from_list(alarms%(1),FALSE)
   PROCsave_repeating_alarm(alarms%(1),alarm_repeat_rate%?alarms%(1),alarm_repeat_mult%?alarms%(1),error%)
  ELSE
   PROCremove_alarm_from_list(alarms%(1),TRUE)
   PROCheap_free("ALRM",alarms%(1))
   alarms%(1)=0
   PROCmodified_alarm_database
  ENDIF
  alarm_warned%=FALSE
  PROCreset_alarm_status
  IFerror% PROCok(FNmsg_0("OkayC3"))
 ENDIF
 cancel%=FALSE
ENDPROC
:
DEFPROCcheckmouse(X%,Y%,B%,H%,I%)
 CASE B% OF
  WHEN&400: IFH%=browser% PROCcheck_browser(B%,Y%)
  WHEN&100: IFH%=browser% PROCcheck_browser(B%,Y%)
  WHEN &40: IFH%=save% PROCdragicon(X%,Y%,H%,I%)
  WHEN   2: REM Menu
            CASE H% OF
             WHEN       -2: PROCdomenu(0,X%-64,316)
             WHEN browser%: PROCdomenu(1,X%-64,Y%)
             WHEN browse1%: PROCdomenu(1,X%-64,Y%)
             WHEN  m_wind%: $deftime%="1"
                            PROCdomenu(2,X%-64,Y%)
             WHEN  a_wind%: PROCdomenu(3,X%-64,Y%)
            ENDCASE
  WHEN   4: REM Select
            CASE H% OF
             WHEN       -2: IFcurrent_action%=setting% PROCfront(a_wind%):PROCok(FNmsg_0("OkayB6"))
                            IFcurrent_action%=changing% PROCfront(a_wind%):PROCok(FNmsg_0("OkayB8"))
                            PROCuser_set_an_alarm
             WHEN browser%: PROCcheck_browser(B%,Y%)
             WHEN  a_wind%: PROCcheck_alarm_window(1,-1,H%,I%)
             WHEN  m_wind%: IF I%=ic_message_accept% THEN PROCclosewindow(m_wind%)
             WHEN   setup%: PROCcheck_setup_window(1,-1,I%)
             WHEN warning%: SYS"Wimp_CreateMenu",,-1
                            SYS"Wimp_SetCaretPosition",-1,-1
                            REM Quit
                            IFI%=ic_warning_discard% THEN
                             modified%=FALSE
                             IFdoing_shutdown%=2 THEN
                              SYS"Wimp_ProcessKey",&1FC
                             ELSE
                              PROCshutdown
                             ENDIF
                            ENDIF
                            REM Save and quit
                            IFI%=ic_warning_save% THEN
                             IFdoing_shutdown%=2 THEN
                              REM global shutdown asked for
                              doing_shutdown%=3
                             ELSE
                              doing_shutdown%=1
                             ENDIF
                             PROCsave_setup(&AE9,0,4,ra$)
                             SYS"Wimp_CreateMenu",,save%,X%,Y%
                            ENDIF
             WHENdeleting%: SYS"Wimp_CreateMenu",,-1
                            IFI%=ic_deleting_delete% PROCdelete_alarms
             WHEN    save%: IF I%=ic_save_ok% THEN
                             PROCsavefile(TRUE,$filename%,FALSE)
                             ENDPROC
                            ENDIF
            ENDCASE
  WHEN   1: REM Adjust
            CASE H% OF
             WHEN       -2: PROCunset_alarms_selection:PROCopen_browser
             WHEN browser%: PROCcheck_browser(B%,Y%)
             WHEN  a_wind%: PROCcheck_alarm_window(-1,1,H%,I%)
             WHEN   setup%: PROCcheck_setup_window(-1,1,I%)
             WHEN    save%: IF I%=ic_save_ok% THEN
                             PROCsavefile(TRUE,$filename%,TRUE)
                             ENDPROC
                            ENDIF
            ENDCASE
 ENDCASE
ENDPROC
:
DEFPROCdecodedrag
 LOCAL h%,i%,mx%,my%
 IFsave_stop%<>-1 SYS save_stop%
 SYS"Wimp_GetPointerInfo",,Q%
 mx%=!Q%
 my%=Q%!4
 h%=Q%!12
 i%=Q%!16
 IF h%=save% ENDPROC
 PROCdrag_savefile(h%,i%,mx%,my%)
ENDPROC
:
DEFPROCmenuselect(menus%)
 LOCAL C%,D%,H%,got_adjust%,taskname$
 SYS"Wimp_GetPointerInfo",,buffers%
 IF (buffers%!8 AND 1) AND menuhand%<>2 got_adjust%=TRUE ELSE got_adjust%=FALSE
 CASE menuhand% OF
 WHEN 0: REM icon menu
         CASE !menus% OF
          WHEN 1:PROCunset_alarms_selection:PROCopen_browser
          WHEN 2:PROCopen_setup
          WHEN 3:REM Known to exist (to unshade the menu), check it's not running
                 C% = 0
                 REPEAT
                  SYS"TaskManager_EnumerateTasks",C%,Q%,16 TO C%
                  REM Can't use FNrtoz because Message_TaskInitialise permits ctrl termination
                  IF C% >= 0 THEN SYS"XOS_GenerateError",Q%!4 TO taskname$
                 UNTIL (taskname$ = "Time Setup") OR (C% < 0)
                 IF C% < 0 THEN
                  REM Not already running, so run it
                  SYS"XWimp_StartTask","/BootResources:Configure.!TimeSetup"
                 ELSE
                  REM Make it pop to the top
                  H%   = Q%!0
                  Q%!0 = 20
                  Q%!12= 0
                  Q%!16= &50D83:REM OpenConfigWindow
                  SYS"XWimp_SendMessage",17,Q%,H%
                 ENDIF
          WHEN 4:PROCshutdown
         ENDCASE
 WHEN 1: REM browser menu
         CASE !menus% OF
          WHEN 0:PROCuser_set_an_alarm
          WHEN 1:CASE menus%!4 OF
                 WHEN 0: C%=alarm_head%
                         WHILE C%
                          REM IFFNcheck_pointer PROCcheck_pointer(C%,"PROCmenuselect(C%,0)")
                          IFC%?alarm_selected% THEN
                           C%?alarm_selected%=0
                           PROCredraw_alarm(C%)
                           PROCichang(C%)
                           C%=0
                          ELSE
                           C%=C%!alarm_next%
                          ENDIF
                         ENDWHILE
                 WHEN 1: IFalarm_confirm% THEN
                          IFFNalarm_selection_count=1 THEN
                           PROCset_string(deleting%,ic_deleting_msg2%,FNmsg_0("BrwsT3"))
                          ELSE
                           PROCset_string(deleting%,ic_deleting_msg2%,FNmsg_0("BrwsT4"))
                          ENDIF
                          doing_deleting%=TRUE
                          !Q%=deleting%:SYS"Wimp_GetWindowState",,Q%
                          C%=(scrx1%-(Q%!12-Q%!4)) DIV 2
                          D%=(scry1%-(Q%!8-Q%!16)) DIV 2
                          SYS"Wimp_CreateMenu",,deleting%,C%,D%
                          got_adjust%=FALSE
                         ELSE
                          PROCdelete_alarms
                         ENDIF
                 WHEN 2: REM copy alarms ...
                         SYS"Hourglass_On"
                         C%=alarm_head%
                         WHILE C%
                          REM IFFNcheck_pointer PROCcheck_pointer(C%,"PROCmenuselect(C%,2)")
                          IFC%?alarm_selected% THEN
                           C%?alarm_selected%=0
                           D%=FNheap_claim("ALRM",alarm_SIZE%)
                           IFD%=0 PROCout_of_memory
                           PROCcopyalarm(C%,D%)
                           PROCsave_alarm(D%)
                           C%=alarm_head%:REM start at the beginning again
                          ELSE
                           C%=C%!alarm_next%
                          ENDIF
                         ENDWHILE
                         alarm_warned%=FALSE
                         PROCunset_alarms_selection:REM neat way for forcing a redraw
                         SYS"Hourglass_Off"
                 ENDCASE
          WHEN 2:SYS"Hourglass_On":PROCselect_all_alarms:SYS"Hourglass_Off"
          WHEN 3:PROCunset_alarms_selection
          WHEN 5:REM since <Alarm$Dir>.Alarms is the default
                 REM we can safely save the alarms away
                 PROCsave_alarms_to_disc(ra$,FALSE,TRUE,TRUE)
                 PROCunset_alarms_selection
                 PROCopen_browser
         ENDCASE
 WHEN 2: REM alarm message menu
         CASE !menus% OF
          WHEN 0:PROCclosewindow(m_wind%)
          WHEN 1:REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCmenuselect(alarms%(1))")
                 alarm_repeating%?alarms%(1)=0:PROCclosewindow(m_wind%)
          WHEN 2:CASE menus%!4 OF
                 WHEN 0:PROCdefer(1)
                 WHEN 1:PROCdefer(2)
                 WHEN 2:PROCdefer(4)
                 WHEN 3:PROCdefer(8)
                 WHEN 4:PROCdefer(16)
                 WHEN 5:PROCdefer(32)
                 ENDCASE
         ENDCASE
 WHEN 3: REM alarm find menu
         C%=alarms%(0):REM pointer to current alarm
         CASE !menus% OF
         WHEN 0:PROCread_prev_alarm(C%)
                PROCichang(C%)
         WHEN 1:PROCread_next_alarm(C%)
                PROCichang(C%)
         ENDCASE
 ENDCASE
 
 IF got_adjust% PROCdomenu(menuhand%,menux%,menuy%)
ENDPROC
:
DEFPROCreceive(A%)
 LOCAL task_handle%,my_ref%,size%,type%,name$,q20%,q24%,q28%,q32%
 CASE Q%!16 OF
 WHEN 0     :PROCshutdown
 WHEN 2     :task_handle%=Q%!4
             my_ref%=Q%!8
             q20%=Q%!20
             q24%=Q%!24
             q28%=Q%!28
             q32%=Q%!32
             size%=Q%!36
             type%=Q%!40
             name$=FNrtoz(Q%+44)
             PROCsavefile((size%<>-1),name$,FALSE)
             PROCtransfer_reply(3,task_handle%,my_ref%,size%,type%,name$,q20%,q24%,q28%,q32%)
 WHEN 3     :task_handle%=Q%!4
             my_ref%=Q%!8
             q20%=Q%!20
             q24%=Q%!24
             q28%=Q%!28
             q32%=Q%!32
             size%=Q%!36
             type%=Q%!40
             name$=FNrtoz(Q%+44)
             IF Q%!20=a_wind% THEN
              PROCset_task_alarm_string
              PROCtransfer_reply(4,task_handle%,my_ref%,size%,type%,name$,q20%,q24%,q28%,q32%)
             ELSE
              IF (Q%!20=-2 OR Q%!20=browser%) AND type%=&AE9 THEN
               PROCload_alarms_into_memory(name$)
               PROCtransfer_reply(4,task_handle%,my_ref%,size%,type%,name$,q20%,q24%,q28%,q32%)
              ENDIF
             ENDIF
 WHEN 5     :IF Q%!40=&AE9 THEN
              task_handle%=Q%!4
              my_ref%=Q%!8
              q20%=Q%!20
              q24%=Q%!24
              q28%=Q%!28
              q32%=Q%!32
              size%=Q%!36
              type%=Q%!40
              name$=FNrtoz(Q%+44)
              PROCtransfer_reply(4,task_handle%,my_ref%,size%,type%,name$,q20%,q24%,q28%,q32%)
              PROCload_alarms_into_memory(name$)
             ENDIF
 WHEN 8     :IFmodified% THEN
              IF!Q%<>20 THEN
               IF(Q%!20 AND 1)=0 doing_shutdown%=2
              ELSE
               doing_shutdown%=2
              ENDIF
              Q%!12=Q%!8
              SYS"Wimp_SendMessage",19,Q%,Q%!4
              !Q%=warning%:SYS"Wimp_GetWindowState",,Q%
              C%=(scrx1%-(Q%!12-Q%!4)) DIV 2
              D%=(scry1%-(Q%!8-Q%!16)) DIV 2
              SYS"Wimp_CreateMenu",,warning%,C%,D%
              SYS"Wimp_SetCaretPosition",warning%,-1,,,1<<25
             ENDIF
 WHEN 10    :PROCsave_desktop_state
 WHEN &500  :PROCprocess_appl_alarm(A%)
 WHEN &502  :PROCdetermine_help
 WHEN &400C0:CASE Q%!32 OF
              WHEN 1: CASE Q%!36 OF
                      WHEN 3: PROCsave_setup(&FFF,0,1,FNmsg_0("FN1"))
                      WHEN 4: PROCsave_setup(&AE9,0,2,FNmsg_0("FN1"))
                      ENDCASE
              WHEN 4: PROCsave_setup(&FFF,0,3,FNmsg_0("FN2"))
              WHEN 5: PROCsave_setup(&AE9,0,4,ra$)
             ENDCASE
             SYS"Wimp_CreateSubMenu",,Q%!20,Q%!24,Q%!28
 WHEN &400C1,&400CF :cur_format$ ="":PROCgettime
 WHEN &400C2:IFQ%!4<>taskid% AND FNrtoz(Q%+28)=task_id$ THEN
              Q%!12=0:Q%!16=0:!Q%=20
              SYS"Wimp_SendMessage",17,Q%,Q%!4
              PROCok(FNmsg_0("OkayB9"))
             ENDIF
 WHEN &400C9:IFQ%!20=deleting% THEN
              doing_deleting%=FALSE
             ENDIF
             IFFNalarm_selection_count=1 AND NOT(doing_deleting%) AND doing_shutdown%=0 THEN
              PROCunset_alarms_selection
             ENDIF
             IFQ%!20=save% doing_shutdown%=0
             IFQ%!20=warning% AND doing_shutdown%<>3 AND doing_shutdown%<>1 THEN
              REM 1 or 3 means that we have moved to the save dbox
              doing_shutdown%=0
             ENDIF
 ENDCASE
ENDPROC
:
DEFPROCacknowledge
 LOCAL error%
 IF Q%!16=&501 AND Q%!12=0 THEN
  REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCacknowledge(1)")
  PROCremove_alarm_from_list(alarms%(1),FALSE)
  PROCread_date_and_time(alarms%(1))
  PROCsave_repeating_alarm(alarms%(1),1,1,error%)
  IFerror% PROCok(FNmsg_0("OkayC5"))
  alarm_warned%=FALSE
  PROCreset_alarm_status
  PROCok(FNmsg_1("OkayA1",$(alarms%(1)+alarm_line1%)))
 ENDIF
ENDPROC

REM *************************************************************************
REM User message decoders
REM *************************************************************************

DEFPROCtransfer_reply(type%,handle%,ref%,size%,filetype%,name$,q20%,q24%,q28%,q32%)
 !Q%=(48+LENname$)ANDNOT3
 Q%!12=ref%
 Q%!16=type%
 Q%!20=q20%
 Q%!24=q24%
 Q%!28=q28%
 Q%!32=q32%
 Q%!36=size%
 Q%!40=filetype%
 $(Q%+44)=name$+CHR$0
 SYS"Wimp_SendMessage",17,Q%,handle%
ENDPROC
:
DEFPROCshutdown
 LOCAL C%,D%
 IFmodified% THEN
  !Q%=warning%:SYS"Wimp_GetWindowState",,Q%
  C%=(scrx1%-(Q%!12-Q%!4)) DIV 2
  D%=(scry1%-(Q%!8-Q%!16)) DIV 2
  SYS"Wimp_CreateMenu",,warning%,C%,D%
  SYS"Wimp_SetCaretPosition",warning%,-1,,,1<<25
  ENDPROC
 ENDIF
 PROCmsg_end
 REM Delete the code variable
 SYS"XOS_SetVarVal","Alarm$Free",,-1,0,16
 SYS"Wimp_CloseDown"
 END
ENDPROC
:
DEFPROCsave_desktop_state
 LOCAL I%,s$
 LOCAL ERROR
 ON ERROR LOCAL Q%!12=Q%!8:SYS"Wimp_SendMessage",19,Q%,Q%!4:ENDPROC
 I%=Q%!20
 BPUT#I%,FNbuild_alarm_options
 BPUT#I%,"Run "+FNread_system_string("Alarm$Dir","");
 IF FNupper(ra$)=FNupper(def_fn$) THEN BPUT#I%,10 ELSE BPUT#I%," "+ra$:REM Append alarms file location if non default
ENDPROC
:
DEFPROCdetermine_help
 LOCAL additional_help$,v%
 additional_help$=""
 IF Q%!36<-1 ENDPROC
 CASE Q%!32 OF
 WHEN -2: PROCh("AlarmH2")
 WHEN browser%,browse1%: PROCh("AlarmHA")
 WHEN  setup%:REM knock out the textual icons that we don't want to help on
              IF Q%!36=ic_setup_seconds_label% THEN Q%!36=-1
              IF Q%!36=ic_setup_format_label% THEN Q%!36=-1
              IF Q%!36=ic_setup_format_frame% THEN Q%!36=-1
              CASE Q%!36 OF
               WHEN                     -1: PROCh("AlarmHB")
               WHEN       ic_setup_silent%: IF FNicon_set(setup%,Q%!36) PROCh("SHlp0B") ELSE PROCh("SHlp0A")
               WHEN           ic_setup_ok%: PROCh("SHlpIA")
               WHEN       ic_setup_cancel%: PROCh("SHlpIB")
               WHEN ic_setup_working_week%: IF FNicon_set(setup%,Q%!36) PROCh("SHlp1B") ELSE PROCh("SHlp1A")
               WHENic_setup_sun%,ic_setup_mon%,ic_setup_tue%,ic_setup_wed%,ic_setup_thu%,ic_setup_fri%,ic_setup_sat%:
                                            IF FNicon_set(setup%,Q%!36) PROCh("SHlpHA") ELSE PROCh("SHlpHB")
               WHEN    ic_setup_cont_beep%: PROCh("SHlpGA")
               WHEN     ic_setup_beep_off%: PROCh("SHlpGB")
               WHEN    ic_setup_beep_time%: PROCh("SHlpAA")
               WHENic_setup_auto_database%: IF FNicon_set(setup%,Q%!36) PROCh("SHlp2B") ELSE PROCh("SHlp2A")
               WHEN  ic_setup_confirm_del%: IF FNicon_set(setup%,Q%!36) PROCh("SHlp3B") ELSE PROCh("SHlp3A")
               WHEN  ic_setup_analogue_ws%: PROCh("SHlp4A")
               WHEN        ic_setup_hh_mm%: PROCh("SHlp6A")
               WHEN ic_setup_analogue_wos%: PROCh("SHlp5A")
               WHEN     ic_setup_hh_mm_ss%: PROCh("SHlp7A")
               WHEN     ic_setup_user_def%: PROCh("SHlp8A")
               WHEN  ic_setup_user_string%: additional_help$=FNconverttime(cur_clock%,FNread_string(setup%,Q%!36))
                                            IFadditional_help$<>FNmsg_0("FrmtA4") THEN
                                             additional_help$=FNmsg_0("SHlpBB")+"|M"+additional_help$
                                            ENDIF
                                            PROCh("SHlpBA")
              ENDCASE
 WHEN a_wind%:REM knock out the textual icons that we don't want to help on
              IF Q%!36=ic_alarm_msg_label% Q%!36=-1
              IF Q%!36=ic_alarm_onthe_month_label% Q%!36=-1
              IF Q%!36=ic_alarm_ofevery_label% Q%!36=-1
              IFcurrent_action%<>setting% additional_help$=FNmsg_0("HelpE5")
              IF Q%!36=-1 THEN
               CASE current_action% OF
                WHEN setting%:PROCh("AlarmH3")
                WHEN changing%:PROCh("AlarmH5")
               ENDCASE
              ELSE
               CASE Q%!36 OF
                WHEN          ic_alarm_adj_hu%: PROCh("ClockA7")
                WHEN          ic_alarm_adj_hd%: PROCh("ClockA8")
                WHEN        ic_alarm_adj_minu%: PROCh("ClockA9")
                WHEN        ic_alarm_adj_mind%: PROCh("ClockB1")
                WHEN          ic_alarm_adj_dd%: PROCh("ClockB2")
                WHEN          ic_alarm_adj_du%: PROCh("ClockB3")
                WHEN          ic_alarm_adj_md%: PROCh("ClockB4")
                WHEN          ic_alarm_adj_mu%: PROCh("ClockB5")
                WHEN          ic_alarm_adj_yd%: PROCh("ClockB6")
                WHEN          ic_alarm_adj_yu%: PROCh("ClockB7")
                WHEN        ic_alarm_adj_repd%: PROCh("HelpC9")
                WHEN        ic_alarm_adj_repu%: PROCh("HelpD2")
                WHEN ic_alarm_adj_onthe_drepd%: PROCh("HelpF1")
                WHEN ic_alarm_adj_onthe_drepu%: PROCh("HelpF1")
                WHEN    ic_alarm_adj_onthe_du%: PROCh("HelpF2")
                WHEN    ic_alarm_adj_onthe_dd%: PROCh("HelpF2")
                WHEN ic_alarm_adj_onthe_mrepd%: PROCh("HelpF3")
                WHEN ic_alarm_adj_onthe_mrepu%: PROCh("HelpF3")
                WHEN          ic_alarm_urgent%: IF FNicon_set(a_wind%,Q%!36) PROCh("HelpA7") ELSE PROCh("HelpA6")
                WHEN          ic_alarm_repeat%: IF FNicon_set(a_wind%,Q%!36) PROCh("HelpC2") ELSE PROCh("HelpC1")
                WHEN            ic_alarm_task%: IF FNicon_set(a_wind%,Q%!36) PROCh("HelpE2") ELSE PROCh("HelpE1")
                WHEN           ic_alarm_wweek%: IF FNicon_set(a_wind%,Q%!36) PROCh("HelpE4") ELSE PROCh("HelpE3")
                WHEN ic_alarm_ok_lo%,ic_alarm_ok_hi%:
                                                CASE current_action% OF
                                                 WHEN setting%  :PROCh("HelpD3")
                                                 WHEN changing% :PROCh("HelpD7")
                                                ENDCASE
                WHEN ic_alarm_cancel_lo%,ic_alarm_cancel_hi%:
                                                CASE current_action% OF
                                                 WHEN setting%  :PROCh("HelpIB")
                                                 WHEN changing% :PROCh("HelpIC")
                                                ENDCASE
                WHEN ic_alarm_line1%,ic_alarm_line2%:
                                                PROCh("HelpB8")
                WHEN           ic_alarm_line3%: PROCh("HelpB9")
                WHEN      ic_alarm_every_mins%: PROCh("HelpC3")
                WHEN     ic_alarm_every_hours%: PROCh("HelpC4")
                WHEN      ic_alarm_every_days%: PROCh("HelpC5")
                WHEN     ic_alarm_every_weeks%: PROCh("HelpC6")
                WHEN    ic_alarm_every_months%: PROCh("HelpC7")
                WHEN     ic_alarm_every_years%: PROCh("HelpC8")
                WHEN      ic_alarm_every_many%: PROCh("HelpD1")
                WHEN        ic_alarm_cur_year%: PROCh("HelpB7")
                WHEN         ic_alarm_cur_day%: PROCh("HelpA9")
                WHEN        ic_alarm_cur_hour%: PROCh("HelpA3")
                WHEN         ic_alarm_cur_min%: PROCh("HelpA4")
                WHEN           ic_alarm_every%: PROCh("HelpF7")
                WHEN           ic_alarm_onthe%: PROCh("HelpE6")
                WHEN   ic_alarm_onthe_rep_day%: PROCh("HelpF4")
                WHEN       ic_alarm_onthe_day%: PROCh("HelpF5")
                WHEN ic_alarm_onthe_rep_month%: PROCh("HelpF6")
                WHEN       ic_alarm_dow_label%: PROCh("HelpB5")
                WHEN         ic_alarm_cur_mon%: PROCh("HelpB4")
                WHEN      ic_alarm_ampm_label%: PROCh("HelpA5")
                WHEN       ic_alarm_min_delta%: PROCh("HelpG4")
                WHEN      ic_alarm_hour_delta%: PROCh("HelpG3")
                WHEN      ic_alarm_year_delta%: PROCh("HelpG1")
                WHEN       ic_alarm_day_delta%: PROCh("HelpG2")
               ENDCASE
              ENDIF
 WHEN m_wind%:IF Q%!36 = ic_message_accept% THEN PROCh("MnuAL1") ELSE PROCh("AlarmH8")
 WHEN info%:PROCh("AlarmH9")
 WHEN save%:CASE Q%!36 OF
             WHEN ic_save_ok%:PROCh("Drg02")
             WHEN ic_save_name%:PROCh("Drg03")
             WHEN ic_save_icon%:PROCh("Drg04")
             OTHERWISE:PROCh("Drg01")
            ENDCASE
 OTHERWISE
  IF Q%!36<>-1 THEN
   SYS"Wimp_GetMenuState",1,Q%+1024,Q%!32,Q%!36
   IF menuhand%=0 THEN
    CASE Q%!1024 OF
     WHEN 0:IF Q%!1028=-1 PROCh("MnuMM1")
     WHEN 1:PROCh("MnuMM3")
     WHEN 2:PROCh("MnuMM4")
     WHEN 3:PROCh("MnuMM5")
     WHEN 4:PROCh("MnuMM6")
    ENDCASE
   ENDIF
   IF menuhand%=3 THEN
    IFcurrent_action%=setting% THEN
     PROCh("MnuFI4")
    ELSE
     CASE Q%!1024 OF
      WHEN 0:PROCh("MnuFI1")
      WHEN 1:PROCh("MnuFI2")
     ENDCASE
    ENDIF
   ENDIF
   IF menuhand%=1 THEN
    v%=FNalarm_selection_count
    CASE Q%!1024 OF
    WHEN 0:IFcurrent_action%=-1 PROCh("BHlpA1") ELSE PROCgrey_help
    WHEN 1:IFcurrent_action%<>-1 OR v%=0 THEN
            PROCgrey_help
           ELSE
            CASE Q%!1028 OF
            WHEN 0: IFv%=1 THEN
                     PROCh("BHlpB1")
                    ELSE
                     PROCh("BHlpB2")
                    ENDIF
            WHEN 1: IFv%=1 THEN
                     PROCh("BHlpB3")
                    ELSE
                     PROCh("BHlpB4")
                    ENDIF
            WHEN 2: IFv%=1 THEN
                     PROCh("BHlpB9")
                    ELSE
                     PROCh("BHlpBA")
                    ENDIF
            WHEN 3: IFv%=1 THEN
                     PROCh("BHlpB5")
                    ELSE
                     PROCh("BHlpB6")
                    ENDIF
            WHEN 4: IFv%=1 THEN
                     PROCh("BHlpB7")
                    ELSE
                     PROCh("BHlpB8")
                    ENDIF
            OTHERWISE:IFv%=1 THEN
                       PROCh("BHlpA2")
                      ELSE
                       PROCh("BHlpA3")
                      ENDIF
            ENDCASE
           ENDIF
    WHEN 2:IFalarm_head%=0 PROCgrey_help ELSE PROCh("BHlpA4")
    WHEN 3:IFalarm_head%=0 THEN
            PROCh("MnuAM9")
           ELSE
            IFv%=0 THEN
             PROCh("MnuAMA")
            ELSE
             PROCh("BHlpA5")
            ENDIF
           ENDIF
    WHEN 4:IFalarm_head%=0 OR current_action%<>-1 PROCgrey_help ELSE PROCh("BHlpA6")
    WHEN 5:IFcurrent_action%<>-1 PROCgrey_help ELSE PROCh("BHlpA7")
    ENDCASE
   ENDIF
   IF menuhand%=2 THEN
    CASE Q%!1024 OF
     WHEN 0:PROCh("MnuAL1")
     WHEN 1:PROCh("MnuAL2")
     WHEN 2:CASE Q%!1028 OF
             WHEN 0:IF Q%!1032=-1 PROCh("MnuD21") ELSE PROCh("MnuD11")
             WHEN 1:IF Q%!1032=-1 PROCh("MnuD22") ELSE PROCh("MnuD11")
             WHEN 2:IF Q%!1032=-1 PROCh("MnuD23") ELSE PROCh("MnuD11")
             WHEN 3:IF Q%!1032=-1 PROCh("MnuD24") ELSE PROCh("MnuD11")
             WHEN 4:IF Q%!1032=-1 PROCh("MnuD25") ELSE PROCh("MnuD11")
             WHEN 5:IF Q%!1032=-1 PROCh("MnuD26") ELSE PROCh("MnuD11")
             OTHERWISE :PROCh("MnuAL3")
            ENDCASE
    ENDCASE
   ENDIF
  ENDIF
 ENDCASE
ENDPROC
:
DEFPROCkey(H%,I%,C%)
 LOCAL num_icons%,copy_icons%,midx%,midy%
 LOCAL mine%

 mine% =FALSE

 IF H% =a_wind% THEN
  CASE C% OF
  WHEN &0D,&18A,&19A,&18E,&18F:
   REM Return, tab, shift tab, down, up navigation
   alarm% =alarms%(0) ELSE alarm% =alarms%(2)
   PROCrec_fromwin(alarm%,H%)
   PROCrefresh_alarm_window(H%,alarm%)
   mine% =TRUE
  ENDCASE
 ENDIF

 IF (C%=&1B OR C%=&1A2) AND (H%=setup% OR H%=a_wind%) THEN
  REM Escape or CTRL-F2 closes
  Q%!28=H%
  SYS"Wimp_SendMessage",3,Q%+28,H%
  mine% =TRUE
 ENDIF

 IFC%=13 AND (H%=a_wind% OR H%=save% OR H%=setup% OR H%=warning%) THEN
  REM Return presses the default button or first button
  Q%!28 =H% OR 1
  SYS"Wimp_GetWindowInfo",,Q% +28
  num_icons% =Q%!(28 +4 +84)
  midx%=(Q%!(28 +4 +0) + Q%!(28 +4 +8)) / 2
  midy%=(Q%!(28 +4 +4) + Q%!(28 +4+12)) / 2

  REM look for default button first
  copy_icons% =0
  WHILE copy_icons% <num_icons%
   Q%!(28 +4) =copy_icons%
   SYS"Wimp_GetIconState",,Q% +28
   IF INSTR(FNvalid(Q%+28 +8),"R6,3") THEN
    REM Land the mouse somewhere in the visible area
    Q%!(28 +0) =midx%
    Q%!(28 +4) =midy%
    Q%!(28 +8) =%100 :REM select
    Q%!(28 +12) =H%
    Q%!(28 +16) =copy_icons%
    SYS"Wimp_SendMessage",6,Q%+28,H%
    ENDPROC : REM Implicit mine% = TRUE
   ENDIF
   copy_icons% +=1
  ENDWHILE

  REM then look for non-default button
  copy_icons% =0
  WHILE copy_icons% <num_icons%
   Q%!(28 +4) =copy_icons%
   SYS"Wimp_GetIconState",,Q% +28
   IF INSTR(FNvalid(Q%+28 +8),"R5,3") THEN
    REM Land the mouse somewhere in the visible area
    Q%!(28 +0) =midx%
    Q%!(28 +4) =midy%
    Q%!(28 +8) =%100 :REM select
    Q%!(28 +12) =H%
    Q%!(28 +16) =copy_icons%
    SYS"Wimp_SendMessage",6,Q%+28,H%
    ENDPROC : REM Implicit mine% = TRUE
   ENDIF
   copy_icons% +=1
  ENDWHILE
 ENDIF

 IF NOT mine% THEN SYS"Wimp_ProcessKey",C%
ENDPROC
REM Limited ("Castle") and its licensors on contractual terms and conditions
REM ("Licence") which entitle you freely to modify and/or to distribute this
REM source code subject to Your compliance with the terms of the Licence.
REM
REM This source code has been made available to You without any warranties
REM whatsoever. Consequently, Your use, modification and distribution of this
REM source code is entirely at Your own risk and neither Castle, its licensors
REM nor any other person who has contributed to this source code shall be
REM liable to You for any loss or damage which You may suffer as a result of
REM Your use, modification or distribution of this source code.
REM
REM Full details of Your rights and obligations are set out in the Licence.
REM You should have received a copy of the Licence with this source code file.
REM If You have not received a copy, the text of the Licence is available
REM online at www.castle-technology.co.uk/riscosbaselicence.htm
REM
REM > Dialogues

REM *************************************************************************
REM Alarm window
REM *************************************************************************

DEFPROCcreate_alarm_wind(t$,W%,I%)
 LOCAL E%,F%,B%
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCcreate_alarm_wind")
 B%=(1<<21)+(15<<12)
 IF I%?alarm_applalarm% W%=FALSE
 IF W% F%=15<<12:E%=11<<12 ELSE F%=0:E%=0
 PROCset_title(a_wind%,t$)
 
 PROCrefresh_alarm_window(a_wind%,I%)
 
 IF I%?alarm_applalarm% THEN
  PROCset_string(a_wind%,ic_alarm_line1%,FNmsg_0("ActvA5"))
  PROCset_string(a_wind%,ic_alarm_line2%,$(I%+alarm_line1%))
  PROCset_string(a_wind%,ic_alarm_line3%,"")
 ELSE
  PROCset_string(a_wind%,ic_alarm_line1%,$(I%+alarm_line1%))
  PROCset_string(a_wind%,ic_alarm_line2%,$(I%+alarm_line2%))
  PROCset_string(a_wind%,ic_alarm_line3%,$(I%+alarm_line3%))
 ENDIF
 PROCsetstate(a_wind%,ic_alarm_line1%,F%,15<<12)
 PROCsetstate(a_wind%,ic_alarm_line2%,F%,15<<12)
 PROCsetstate(a_wind%,ic_alarm_line3%,F%,15<<12)

 PROCsetstate(a_wind%,ic_alarm_urgent%,E%,B%)
 IF I%?alarm_urgent% PROCsetstate(a_wind%,ic_alarm_urgent%,1<<21,0)

 PROCsetstate(a_wind%,ic_alarm_repeat%,E%,B%)

 PROCsetstate(a_wind%,ic_alarm_every%,E%,B%)

 PROCsetstate(a_wind%,ic_alarm_onthe%,E%,B%)
 PROCset_repeat_flags(W%,I%)

 PROCsetstate(a_wind%,ic_alarm_task%,E%,B%)
 IF I%?alarm_taskalarm% THEN
  PROCsetstate(a_wind%,ic_alarm_task%,1<<21,0)
  REM disable urgent button if task alarm
  PROCsetstate(a_wind%,ic_alarm_urgent%,1<<22,1<<22)
 ELSE
  REM enable urgent button if not task alarm
  PROCsetstate(a_wind%,ic_alarm_urgent%,0,1<<22)
 ENDIF

 PROCsetstate(a_wind%,ic_alarm_wweek%,E%,B%)
 IF I%?alarm_fvdywk% PROCsetstate(a_wind%,ic_alarm_wweek%,1<<21,0)
ENDPROC
:
DEFPROCopen_alarm_wind
 LOCAL Y%,X%
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCopen_alarm_wind")

 !Q%=a_wind%:SYS"Wimp_GetWindowState",,Q%
 IF(Q%!32 AND (1<<16))=0 THEN
  REM window was already closed,
  REM so we can quite happily move it
  !Q1%=-2
  SYS"Wimp_GetWindowState",,Q1%
  Y%=Q1%!4-Q1%!20
  !Q1%=-2:Q1%!4=ictime%
  SYS"Wimp_GetIconState",,Q1%
  REM open it left and up a bit from the time icon
  X%=Y%+Q1%!16-832
  Q%!12=(Q%!12-Q%!4)+X%
  Q%!16=524+140 : REM Template min y + iconbar + margin
  Q%!8=140
  Q%!4=X%
  Q%!20=0
  Q%!24=0
 ELSE
  REM unpin
  PROCtell_pinboard(a_wind%)
 ENDIF
 REM we want to force it to the top
 Q%!28=-1
 SYS"Wimp_OpenWindow",,Q%
 PROCtoggle_alarm_size(alarm_repeating%?alarms%(0)<>0)
ENDPROC
:
DEF PROCtoggle_alarm_size(flag%)
 LOCAL size_x%,size_y%
 LOCAL eor%,mask%,H%,L%
 
 mask% =128 +(1 <<23) : REM Delete and help redraw
 Q%!&100 =a_wind%
 SYS"Wimp_GetWindowInfo",,(Q%+&100) OR 1

 IF flag% =FALSE THEN
  REM Shrink to nothing. The wimp will sort out the mess, by using
  REM the window's minimum size.
  Q%!(&100 +4 +8) =0 :REM Visible area maximum X
  Q%!(&100 +4 +4) =Q%!(&100 +4 +12) :REM Visible area minimum Y = max Y

  REM Hide the repeating alarm icons which would obscure the ok/cancel buttons
  eor% =128 +(1 <<23)
  H%=0
  L%=mask%
 ELSE
  Q%!0 =a_wind%
  SYS"Wimp_GetWindowInfo",,Q% OR 1
  size_x% =Q%!(&100 +4 +48) -Q%!(&100 +4 +40) :REM Work area max X - min X
  size_y% =Q%!(&100 +4 +52) -Q%!(&100 +4 +44) :REM Work area max Y - min Y
  Q%!(&100 +4 +8) = Q%!(&100 +4 +0) +size_x% :REM Visible area max X = min X + size_x%
  Q%!(&100 +4 +4) = Q%!(&100 +4 +12) -size_y% :REM Visible area min Y = max Y - size_y%

  REM Show the repeating alarm icons
  eor% =0
  H%=mask%
  L%=0
 ENDIF
 PROCsetstate(a_wind%,ic_alarm_ok_hi%,H%,mask%)
 PROCsetstate(a_wind%,ic_alarm_cancel_hi%,H%,mask%)
 PROCsetstate(a_wind%,ic_alarm_cancel_lo%,L%,mask%)
 PROCsetstate(a_wind%,ic_alarm_ok_lo%,L%,mask%)
 PROCsetstate(a_wind%,ic_alarm_every%,eor%,mask%)
 PROCsetstate(a_wind%,ic_alarm_every_many%,eor%,mask%)
 PROCsetstate(a_wind%,ic_alarm_adj_repu%,eor%,mask%)
 PROCsetstate(a_wind%,ic_alarm_adj_repd%,eor%,mask%)
 PROCsetstate(a_wind%,ic_alarm_every_mins%,eor%,mask%)
 PROCsetstate(a_wind%,ic_alarm_every_hours%,eor%,mask%)

 SYS"Wimp_OpenWindow",,Q%+&100

 REM Forcing window on screen by closing & re-opening it will cause
 REM flicker if it's not needed. So we check if it's offscreen
 REM first.
 IF FNoffscreen(a_wind%) THEN PROCforce_onscreen(a_wind%)
ENDPROC
:
DEFPROCrefresh_alarm_window(H%,I%)
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCrefresh_alarm_window")
 PROCset_string(H%,2,FNyear(I%))
 PROCset_string(H%,47,FNmonth(I%))
 PROCset_string(H%,46,FNdow(I%))
 PROCset_string(H%,7,FNday(I%))
 PROCset_string(H%,11,FNhour(I%))
 PROCset_string(H%,14,FNmin(I%))
 PROCset_string(H%,48,FNam(I%))

 PROCalarm_rec_to_fivebt(I%,buffers%)
 ?cur_time% =3
 SYS"OS_Word",14,cur_time%
 REM zero out seconds, so difference seems sensible
 SYS"Territory_ConvertTimeToOrdinals",-1,cur_time%,cur_ordinals%
 cur_ordinals%!0 =0 :REM cs
 cur_ordinals%!4 =0 :REM s
 SYS"Territory_ConvertOrdinalsToTime",-1,cur_time%,cur_ordinals%

 PROCtime_diff(cur_time%,buffers%,sign%,yr_dif%,day_dif%,hr_dif%,min_dif%)

 IF sign% =-1 THEN PROCset_string(H%,53,"-") ELSE PROCset_string(H%,53,"+")

 PROCset_string(H%,51,STR$(yr_dif%))
 PROCset_string(H%,52,STR$(day_dif%))
 PROCset_string(H%,50,STR$(hr_dif%))
 PROCset_string(H%,49,RIGHT$("0"+STR$(min_dif%),2))
ENDPROC
:
DEFPROCselect_all_alarms
 LOCAL C%
 C%=alarm_head%
 WHILE C%
  REM IFFNcheck_pointer PROCcheck_pointer(C%,"PROCselect_all_alarms")
  IFC%?alarm_applalarm%=0 C%?alarm_selected%=1
  C%=C%!alarm_next%
 ENDWHILE
 !Q%=browser%
 Q%!4=0
 Q%!8=-(alarm_count%*48+52)
 Q%!12=assembler%!16
 Q%!16=0
 SYS"Wimp_ForceRedraw",!Q%,Q%!4,Q%!8,Q%!12,Q%!16
ENDPROC
:
DEFPROCunset_alarms_selection
 LOCAL p%
 p%=alarm_head%
 WHILE p%
  REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCunset_alarms_selection")
  IFp%?alarm_selected% p%?alarm_selected%=0
  p%=p%!alarm_next%
 ENDWHILE
 !Q%=browser%
 Q%!4=0
 Q%!8=-(alarm_count%*48+52)
 Q%!12=assembler%!16
 Q%!16=0
 SYS"Wimp_ForceRedraw",!Q%,Q%!4,Q%!8,Q%!12,Q%!16
ENDPROC
:
DEFPROCopen_top_pane(block%,handle%)
 REM open a pane window at the top of an edit window
 REM this routine uses the block passed to it, so it
 REM is necessary to save any values which get corrupted
 REM by this routine.
 LOCAL h%,y%,x1%,x2%,sx%,sy%
 h%=!block%
 y%=block%!8
 x1%=block%!4
 x2%=block%!12
 sx%=block%!20
 sy%=block%!24
 REM now adjust the parameters
 REM specify the pane window to be opened
 !block%=handle%
 REM make the pane open just below the edit window
 block%!8=block%!16-52:REM pane_height%
 REM don't allow the pane window to scroll
 block%!20=0
 block%!24=0
 SYS"Wimp_OpenWindow",,block%
 !block%=h%
 block%!4=x1%
 block%!12=x2%
 block%!8=y%
 block%!20=sx%
 block%!24=sy%
ENDPROC
:
DEFPROCredraw_alarm(pointer%)
 LOCAL p%,y%
 p%=alarm_head%
 y%=-52
 WHILE p%
  IFp%=pointer% THEN
   !Q%=browser%
   Q%!4=0
   Q%!8=y%-48
   Q%!12=assembler%!16
   Q%!16=y%
   SYS"Wimp_ForceRedraw",!Q%,Q%!4,Q%!8,Q%!12,Q%!16
   p%=0
  ENDIF
  y%-=48
  IFp% p%=p%!alarm_next%
 ENDWHILE
ENDPROC
:
DEFFNalarm_selection_count
 LOCAL m2%,m3%
 m3%=0
 m2%=alarm_head%
 WHILE m2% AND m3%<2
  REM IFFNcheck_pointer PROCcheck_pointer(m2%,"FNalarm_selection_count")
  IFm2%?alarm_selected% m3%+=1
  m2%=m2%!alarm_next%
 ENDWHILE
=m3%

REM *************************************************************************
REM Setup window
REM *************************************************************************

DEFPROCopen_setup
 LOCAL Y%,X%
 REM ensure that the window has the right settings
 IFsilent_alarm% THEN
  PROCsetstate(setup%,ic_setup_silent%,1<<21,1<<21)
 ELSE
  PROCsetstate(setup%,ic_setup_silent%,0,1<<21)
 ENDIF
 IFfivedayweek% THEN
  PROCsetstate(setup%,ic_setup_working_week%,1<<21,1<<21)
  Y%=0
 ELSE
  PROCsetstate(setup%,ic_setup_working_week%,0,1<<21)
  Y%=1<<22
 ENDIF
 FORX%=0 TO 6
  IFFNvalid_day(X%+1) THEN
   PROCsetstate(setup%,ic_setup_sun%+X%,Y%+(1<<21),3<<21)
  ELSE
   PROCsetstate(setup%,ic_setup_sun%+X%,Y%,3<<21)
  ENDIF
 NEXT
 IFglobal_timeout%=-1 THEN
  PROCsetstate(setup%,ic_setup_cont_beep%,1<<21,1<<21)
  PROCsetstate(setup%,ic_setup_beep_off%,0,1<<21)
  PROCsetstate(setup%,ic_setup_beep_time%,1<<22,1<<22)
 ELSE
  PROCsetstate(setup%,ic_setup_cont_beep%,0,1<<21)
  PROCsetstate(setup%,ic_setup_beep_off%,1<<21,1<<21)
  PROCset_string(setup%,ic_setup_beep_time%,STR$(global_timeout%))
  PROCsetstate(setup%,ic_setup_beep_time%,0,1<<22)
 ENDIF
 IFalarm_autosave% THEN
  PROCsetstate(setup%,ic_setup_auto_database%,1<<21,1<<21)
 ELSE
  PROCsetstate(setup%,ic_setup_auto_database%,0,1<<21)
 ENDIF
 IFalarm_confirm% THEN
  PROCsetstate(setup%,ic_setup_confirm_del%,1<<21,1<<21)
 ELSE
  PROCsetstate(setup%,ic_setup_confirm_del%,0,1<<21)
 ENDIF
 PROCset_string(setup%,ic_setup_user_string%,userformat$)
 FORX%=0 TO 4
  REM Display format radio icons
  IFformat%=(X%+1) THEN
   PROCsetstate(setup%,ic_setup_analogue_ws%+X%,1<<21,1<<21)
  ELSE
   PROCsetstate(setup%,ic_setup_analogue_ws%+X%,0,1<<21)
  ENDIF
 NEXT
 IFformat%<>5 THEN
  PROCsetstate(setup%,ic_setup_user_string%,1<<22,1<<22)
 ELSE
  PROCsetstate(setup%,ic_setup_user_string%,0,1<<21)
 ENDIF
 !Q%=setup%:SYS"Wimp_GetWindowState",,Q%
 IF(Q%!32 AND (1<<16))=0 THEN
  REM window was already closed,
  REM so we can quite happily move it
  !Q1%=-2
  SYS"Wimp_GetWindowState",,Q1%
  Y%=Q1%!4-Q1%!20
  !Q1%=-2:Q1%!4=ictime%
  SYS"Wimp_GetIconState",,Q1%
  REM open it left and up a bit from the time icon
  X%=Y%+Q1%!16-1012
  Q%!12=(Q%!12-Q%!4)+X%
  Q%!16=738+140 : REM Template min y + iconbar + margin
  Q%!8=140
  Q%!4=X%
  Q%!20=0
  Q%!24=0
 ELSE
  REM unpin
  PROCtell_pinboard(setup%)
 ENDIF
 REM we want to force it to the top
 Q%!28=-1
 SYS"Wimp_OpenWindow",,Q%
 IFglobal_timeout%<>-1 THEN
  SYS"Wimp_SetCaretPosition",setup%,ic_setup_beep_time%,-1,-1,-1,LEN(FNread_string(setup%,ic_setup_beep_time%))
 ELSE
  IFformat%=5 THEN
   REM User format
   SYS"Wimp_SetCaretPosition",setup%,ic_setup_user_string%,-1,-1,-1,LEN(FNread_string(setup%,ic_setup_user_string%))
  ELSE
   REM Invisible caret please
   SYS"Wimp_SetCaretPosition",setup%,-1,,,1<<25
  ENDIF
 ENDIF
ENDPROC
:
DEFPROCcheck_setup_window(P%,M%,I%)
 LOCAL i%
 CASE I% OF
 WHEN ic_setup_working_week%:
         FORi%=0 TO 6
          REM Shading of the working week
          IFFNicon_set(setup%,ic_setup_working_week%) THEN
           PROCsetstate(setup%,ic_setup_sun%+i%,0,1<<22)
          ELSE
           PROCsetstate(setup%,ic_setup_sun%+i%,1<<22,1<<22)
          ENDIF
         NEXT
 WHEN           ic_setup_ok%:PROCok_save_setup(P%) : ENDPROC
 WHEN       ic_setup_cancel%:cancel%=TRUE : PROCclosewindow(setup%) : ENDPROC
 WHEN  ic_setup_analogue_ws%:PROCsetstate(setup%,I%,1<<21,1<<21)
 WHEN ic_setup_analogue_wos%:PROCsetstate(setup%,I%,1<<21,1<<21)
 WHEN        ic_setup_hh_mm%:PROCsetstate(setup%,I%,1<<21,1<<21)
 WHEN     ic_setup_hh_mm_ss%:PROCsetstate(setup%,I%,1<<21,1<<21)
 WHEN     ic_setup_user_def%:PROCsetstate(setup%,I%,1<<21,1<<21)
                             PROCsetstate(setup%,ic_setup_user_string%,0,1<<22)
 WHEN    ic_setup_cont_beep%:PROCsetstate(setup%,I%,1<<21,1<<21)
                             PROCsetstate(setup%,ic_setup_beep_time%,1<<22,1<<22)
 WHEN     ic_setup_beep_off%:PROCsetstate(setup%,I%,1<<21,1<<21)
                             PROCsetstate(setup%,ic_setup_beep_time%,0,1<<22)
 ENDCASE
 IF (I% >= ic_setup_analogue_ws%) AND (I% <= ic_setup_hh_mm_ss%) THEN
  PROCsetstate(setup%,ic_setup_user_string%,1<<22,1<<22)
 ENDIF

 REM Reevaluate where the caret should be
 IFFNicon_set(setup%,ic_setup_beep_off%) THEN
  SYS"Wimp_SetCaretPosition",setup%,ic_setup_beep_time%,-1,-1,-1,LEN(FNread_string(setup%,ic_setup_beep_time%))
 ELSE
  IFFNicon_set(setup%,ic_setup_user_def%) THEN
   REM User format
   SYS"Wimp_SetCaretPosition",setup%,ic_setup_user_string%,-1,-1,-1,LEN(FNread_string(setup%,ic_setup_user_string%))
  ELSE
   REM Invisible caret please
   SYS"Wimp_SetCaretPosition",setup%,-1,,,1<<25
  ENDIF
 ENDIF
ENDPROC
:
DEFPROCok_save_setup(P%)
 LOCAL j%,i%
 silent_alarm%=FNicon_set(setup%,ic_setup_silent%)
 fivedayweek%=FNicon_set(setup%,ic_setup_working_week%)
 j%=0
 FORi%=0 TO 6
  IFFNicon_set(setup%,ic_setup_sun%+i%) j%+=(1<<i%)
 NEXT
 IFj%=0 THEN
  PROCok(FNmsg_0("OkayC9"))
 ELSE
  global_weekwork%=j%
 ENDIF
 IFFNicon_set(setup%,ic_setup_cont_beep%) THEN
  global_timeout%=-1
 ELSE
  global_timeout%=VAL(FNread_string(setup%,ic_setup_beep_time%))
 ENDIF
 IFalarm_autosave%<>FNicon_set(setup%,ic_setup_auto_database%) THEN
  alarm_autosave%=FNicon_set(setup%,ic_setup_auto_database%)
  IFalarm_autosave% THEN
   REM changing from FALSE to TRUE, so save the database
   IFmodified% AND ra$<>"" PROCsave_alarms_to_disc(ra$,FALSE,TRUE,TRUE):autosaved%=FALSE
  ELSE
   REM changing from TRUE to FALSE, clear autosaved flag
   autosaved%=FALSE
  ENDIF
 ENDIF
 alarm_confirm%=FNicon_set(setup%,ic_setup_confirm_del%)
 PROCreset_alarm_status
 IFFNicon_set(setup%,ic_setup_analogue_ws%) THEN
  IFformat%<>1 PROCset_format(1)
 ELSE
  IFFNicon_set(setup%,ic_setup_analogue_wos%) THEN
   IFformat%<>2 PROCset_format(2)
  ELSE
   IFFNicon_set(setup%,ic_setup_hh_mm%) THEN
    IFformat%<>3 PROCset_format(3)
   ELSE
    IFFNicon_set(setup%,ic_setup_hh_mm_ss%) THEN
     IFformat%<>4 PROCset_format(4)
    ELSE
     IFFNicon_set(setup%,ic_setup_user_def%) THEN
      IFformat%<>5 OR userformat$<>FNread_string(setup%,ic_setup_user_string%) THEN
       userformat$=FNread_string(setup%,ic_setup_user_string%)
       IFFNwidth(userformat$)>80 THEN
        PROCformat_error(FNmsg_0("FrmtA2"))
       ELSE
        IFFNwidth(userformat$)<1 THEN
         PROCformat_error(FNmsg_0("FrmtA3"))
        ELSE
         PROCset_format(5)
        ENDIF
       ENDIF
      ENDIF
     ENDIF
    ENDIF
   ENDIF
  ENDIF
 ENDIF
 REM only close the window if SELECT was used
 IFP%=1 THEN !Q%=setup%:SYS"Wimp_SetCaretPosition",-1,-1:SYS"Wimp_CloseWindow",,Q%
 PROCsave_config
ENDPROC

REM *************************************************************************
REM Browser window
REM *************************************************************************

DEFPROCopen_browser
 LOCAL Y%,X%,W%,s$
 !Q%=browser%:SYS"Wimp_GetWindowInfo",,Q%
 !Q1%=browser%:SYS"Wimp_CloseWindow",,Q1%
 !Q1%=browse1%:SYS"Wimp_CloseWindow",,Q1%
 s$=$(Q%!76)
 IFmodified% THEN
  IFRIGHT$(s$,1)<>"*" s$+=" *"
 ELSE
  IFRIGHT$(s$,1)="*" s$=LEFT$(s$,LEN(s$)-2)
 ENDIF
 $(Q%!76)=s$
 IF(Q%!32 AND (1<<16))=0 THEN
  REM window was already closed,
  REM so we can quite happily move it
  !Q1%=-2
  SYS"Wimp_GetWindowState",,Q1%
  Y%=Q1%!4-Q1%!20
  !Q1%=-2:Q1%!4=ictime%
  SYS"Wimp_GetIconState",,Q1%
  X%=Y%+Q1%!16-820
  IFalarm_count%=0 THEN
   Y%=48+52
  ELSE
   IFalarm_count%>20 THEN
    Y%=20*48+52
   ELSE
    Y%=alarm_count%*48+52
   ENDIF
  ENDIF
  Q%!12=(Q%!12-Q%!4)+X%
  Q%!16=Y%+172
  Q%!8=172
  Q%!4=X%
  Q%!20=0
  Q%!24=0
 ELSE
  PROCtell_pinboard(browser%)
 ENDIF
 REM we want to force it to the top
 Q%!28=-1
 SYS"Wimp_OpenWindow",,Q%
 PROCopen_top_pane(Q%,browse1%)
ENDPROC
:
DEFPROCadjust_browser_size
 LOCAL l%,x%,p%,n%
 REM first of all, zip through the list, counting the number of alarms
 REM and working out how wide the window is going to be
 alarm_count%=0
 p%=alarm_head%
 WHILE p%
  REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCadjust_browser_size")
  alarm_count%+=1
  IFp%?alarm_taskalarm% THEN
   l%=LEN(FNmsg_1("BrwsA1", $(p%+alarm_line1%)+$(p%+alarm_line2%)+$(p%+alarm_line3%)))
  ELSE
   IFp%?alarm_applalarm% THEN
    l%=LEN(FNmsg_1("BrwsA5", $(p%+alarm_line1%)))
   ELSE
    l%=LEN($(p%+alarm_line1%))
    IF$(p%+alarm_line2%)<>"" l%+=1+LEN($(p%+alarm_line2%))
    IF$(p%+alarm_line3%)<>"" l%+=1+LEN($(p%+alarm_line3%))
   ENDIF
  ENDIF
  IFl%>x% x%=l%
  p%=p%!alarm_next%
 ENDWHILE
 x%+=30:REM date and time bit
 IFx%<70 x%=70
 x%=x%*16+16
 assembler%!16=x%
 n%=alarm_count%*48
 n%=-(n%+52)
 !Q%=0:Q%!4=n%:Q%!8=x%:Q%!12=0:SYS"Wimp_SetExtent",browser%,Q%
 !Q%=0:Q%!4=-52:Q%!8=x%:Q%!12=0:SYS"Wimp_SetExtent",browse1%,Q%
ENDPROC
:
DEFPROCcheck_browser(B%,Y%)
 LOCAL i%
 i%=FNalarm_hit(Y%)
 IFi% THEN
  REM IFFNcheck_pointer PROCcheck_pointer(i%,"PROCcheck_browser")
  IFi%?alarm_applalarm% i%=0
 ENDIF
 CASE B% OF
 WHEN 1024:IFi% THEN
            IFi%?alarm_selected%=0 THEN
             PROCunset_alarms_selection
             i%?alarm_selected%=1
             PROCredraw_alarm(i%)
            ENDIF
           ELSE
            IFFNalarm_selection_count PROCunset_alarms_selection
           ENDIF
 WHEN  256:IFi% THEN
            i%?alarm_selected%=1-i%?alarm_selected%
            PROCredraw_alarm(i%)
           ENDIF
 WHEN    4:IF current_action%=changing% PROCfront(a_wind%):PROCok(FNmsg_0("OkayA2"))
           IF current_action%=setting% PROCfront(a_wind%):PROCok(FNmsg_0("OkayA4"))
           i%=alarm_head%
           WHILE i%
            IFi%?alarm_selected% THEN
             i%?alarm_selected%=0
             PROCredraw_alarm(i%)
             PROCichang(i%)
             i%=0
            ELSE
             i%=i%!alarm_next%
            ENDIF
           ENDWHILE
 ENDCASE
ENDPROC

REM *************************************************************************
REM Menus
REM *************************************************************************

DEFPROCdomenu(h%,x%,y%)
 LOCAL m1%,m2%,m3%,m4%,m5%,s$,t$
 menufree%=menuend%-&440
 menu_curws%=menu_ws%
 menudata%=0
 menuhand%=h%
 menux%=x%
 menuy%=y%
 CASE h% OF
 WHEN 0:REM icon menu
        menudata%=FNcrmenu(FNmsg_0("MenuMM"))
        PROCattach(menudata%,0,info%,TRUE)
        IF NOT FNgot_time_setup THEN PROCset_shade(menudata%,3,1)
 WHEN 1:REM browser menu
        m3%=FNalarm_selection_count
        IFm3%<>2 THEN
         s$="BrwsM5":t$="BrwsM6"
        ELSE
         s$="BrwsM3":t$="BrwsM4"
        ENDIF
 
        menudata%=FNcrmenu(FNmsg_1("BrwsM1",FNmsg_0(s$)))
        m1%=FNcrmenu(FNmsg_2("BrwsM2",FNmsg_0(s$),FNmsg_0(t$)))
        PROCattach(menudata%,1,m1%,TRUE)
          PROCattach(m1%,3,save%,FALSE)
          PROCattach(m1%,4,save%,FALSE)
        PROCattach(menudata%,4,save%,FALSE)
        PROCattach(menudata%,5,save%,FALSE)
 
        IFm3%=0 THEN
         m3%=FNalarm_hit(menuy%)
         REM ^^^^^^^^ need to allow for the adjustment factor
         REM no longer, menu is now style guide compliant
         IFm3% THEN
          REM IFFNcheck_pointer PROCcheck_pointer(m3%, "PROCdomenu(m3%)")
          IFm3%?alarm_applalarm%=0 THEN
           m3%?alarm_selected%=1
           PROCredraw_alarm(m3%)
          ELSE
           m3%=0
          ENDIF
         ENDIF
         IFm3%=0 THEN
          PROCset_shade(menudata%,1,1)
          PROCset_shade(m1%,0,1)
          PROCset_shade(m1%,1,1)
          PROCset_shade(m1%,2,1)
          PROCset_shade(m1%,3,1)
          PROCset_shade(m1%,4,1)
          PROCset_shade(menudata%,3,1)
         ENDIF
        ENDIF
 
        IF current_action%<>-1 THEN
         PROCset_shade(menudata%,0,1)
         PROCset_shade(menudata%,1,1)
         PROCset_shade(m1%,0,1)
         PROCset_shade(m1%,1,1)
         PROCset_shade(m1%,2,1)
         PROCset_shade(m1%,3,1)
         PROCset_shade(m1%,4,1)
         PROCset_shade(menudata%,4,1)
         PROCset_shade(menudata%,5,1)
        ENDIF
 
        IF alarm_head%=0 THEN
         REM this will catch the final case of
         REM no alarms existing
         PROCset_shade(menudata%,2,1)
         PROCset_shade(menudata%,4,1)
        ENDIF
 WHEN 2:REM message window menu
        menudata%=FNcrmenu(FNmsg_0("MenuAL"))
        m1%=FNcrmenu(FNmsg_0("MenuD2"))
        PROCattach(menudata%,2,m1%,TRUE)
        m2%=FNcrmenu(FNmsg_0("MenuD1"))
        PROCattach(m1%,0,m2%,TRUE)
        PROCattach(m1%,1,m2%,TRUE)
        PROCattach(m1%,2,m2%,TRUE)
        PROCattach(m1%,3,m2%,TRUE)
        PROCattach(m1%,4,m2%,TRUE)
        PROCattach(m1%,5,m2%,TRUE)
        PROCwriteable(m2%,0,deftime%,4)

        REM Better check this menu is indirect before we trample all
        REM over it to give it some validation
    
        $validation_buffer% = "A0-9"+CHR$0
        !(m2% + 28 + (24 * 0) + 16) = validation_buffer%

        REM Sodding wimp... We disown the caret here if the change alarm
        REM window is open. Otherwise, if we defer an alarm, the wimp steals
        REM the caret from the change alarm window. We then go, "Ah, our alarm
        REM has been altered, close the change alarm window". We the close
        REM the menu tree, and the wimp tries to give the input focus back
        REM to the change alarm window. BOOM.

        IF current_action% <> setting% THEN
            SYS"Wimp_SetCaretPosition", -1, -1
        ENDIF
 WHEN 3:menudata%=FNcrmenu(FNmsg_0("MenuFI"))
        IFcurrent_action%=setting% THEN
         PROCset_shade(menudata%,0,1)
         PROCset_shade(menudata%,1,1)
        ELSE
         h%=alarms%(0):PROCread_prev_alarm(h%)
         IF h%=0 PROCset_shade(menudata%,0,1)
         h%=alarms%(0):PROCread_next_alarm(h%)
         IF h%=0 PROCset_shade(menudata%,1,1)
        ENDIF
 ENDCASE
 IFmenudata% SYS"Wimp_CreateMenu",,menudata%,menux%,menuy%
ENDPROC
REM This source code in this file is licensed to You by Castle Technology
REM Limited ("Castle") and its licensors on contractual terms and conditions
REM ("Licence") which entitle you freely to modify and/or to distribute this
REM source code subject to Your compliance with the terms of the Licence.
REM
REM This source code has been made available to You without any warranties
REM whatsoever. Consequently, Your use, modification and distribution of this
REM source code is entirely at Your own risk and neither Castle, its licensors
REM nor any other person who has contributed to this source code shall be
REM liable to You for any loss or damage which You may suffer as a result of
REM Your use, modification or distribution of this source code.
REM
REM Full details of Your rights and obligations are set out in the Licence.
REM You should have received a copy of the Licence with this source code file.
REM If You have not received a copy, the text of the Licence is available
REM online at www.castle-technology.co.uk/riscosbaselicence.htm
REM
REM > Utils

REM *************************************************************************
REM Wimp utilities
REM *************************************************************************

DEFFNicon_set(w%,i%)
 Q%!2000=w%:Q%!2004=i%:SYS"Wimp_GetIconState",,Q%+2000
=((Q%!2024 AND 1<<21)<>0)
:
DEFFNvalid(p%)
 LOCAL flags%,valid%,str$
 REM indirected + text?
 flags% =p%!16
 IF (flags% AND (%1<<8) +1) =(%1<<8) +1 THEN
  valid% =p%!(20 +4)
  IF valid% <> -1 THEN SYS"XOS_GenerateError",valid% TO str$ :=str$
 ENDIF
=""
:
DEFFNlength_icon(H%)
=LEN(FNread_string(a_wind%,H%))

DEF PROCopen_window (handle%)
 LOCAL mc_dx%,mc_dy%,mc_sw%,mc_sh%,scrx%,scry%
 LOCAL x2%, y2%, x1%, y1%

 Q%!0  = handle%

 SYS"Wimp_GetWindowState",, Q%
 IF (Q%!32 AND 65536)=0 THEN
  REM only do this if the window isn't open!
  REM centre the window on the screen
  SYS"OS_ReadModeVariable", -1,  4 TO ,,mc_dx%
  mc_dx% = 1 << mc_dx%
  SYS"OS_ReadModeVariable", -1, 5  TO ,,mc_dy%
  mc_dy% = 1 << mc_dy%
  SYS"OS_ReadModeVariable", -1, 11 TO ,,mc_sw%
  mc_sw% += 1
  SYS"OS_ReadModeVariable", -1, 12 TO ,,mc_sh%
  mc_sh% += 1
  scrx% = mc_sw% * mc_dx%
  scry% = mc_sh% * mc_dy%

  x1% = (scrx% - (Q%!12 - Q%!4 )) DIV 2
  y1% = (scry% - (Q%!8  - Q%!16)) DIV 2
  x2% = x1% + (Q%!12 - Q%!4 )
  y2% = y1% + (Q%!8  - Q%!16)

  Q%!4  = x1%
  Q%!8  = y2%
  Q%!12 = x2%
  Q%!16 = y1%
 ENDIF
 REM but always at the top of the stack ...
 Q%!28 = -1
 REM Open the window...
 SYS"Wimp_OpenWindow",, Q%
ENDPROC
:
DEFPROCtell_pinboard(handle%)
 REM broadcast Message_WindowClosed for the window
 !buffers%=24
 buffers%!12=0
 buffers%!16=&400CB
 buffers%!20=handle%
 SYS"Wimp_SendMessage",17,buffers%,0
ENDPROC
:
DEF PROCforce_onscreen(win%)
 LOCAL caret%
 REM do we have caret, if so preserve info
 SYS"Wimp_GetCaretPosition",,Q% +&100
 caret% =(Q%!&100)=win%
 
 Q%!0 =win%
 SYS"Wimp_CloseWindow",,Q%
 SYS"Wimp_GetWindowState",,Q%
 SYS"Wimp_OpenWindow",,Q%
 
 IF caret% =TRUE THEN
  SYS"Wimp_SetCaretPosition",Q%!&100,Q%!&104,Q%!&108,Q%!&10C,Q%!&110,Q%!&114
 ENDIF
ENDPROC
:
DEF FNoffscreen(win%)
 LOCAL XE%,YE%,X%,Y%
 SYS"OS_ReadModeVariable",-1,4 TO ,,XE%
 SYS"OS_ReadModeVariable",-1,5 TO ,,YE%
 SYS"OS_ReadModeVariable",-1,11 TO ,,X%
 SYS"OS_ReadModeVariable",-1,12 TO ,,Y%
 
 X% =(X% +1) <<XE%
 Y% =(Y% +1) <<YE%
 Q%!0 =win%
 SYS"Wimp_GetWindowOutline",,Q%
 
 IF (Q%!4) <0 THEN =TRUE
 IF (Q%!8) <0 THEN =TRUE
 IF (Q%!12) > X% THEN =TRUE
 IF (Q%!16) > Y% THEN =TRUE
=FALSE
:
DEFPROCgrey_help
 CASE current_action% OF
 WHEN setting%: PROCh("MnuAM6")
 WHEN changing%:PROCh("MnuAM8")
 OTHERWISE:     IFalarm_head%=0 THEN
                 PROCh("MnuAM9")
                ELSE
                 PROCh("MnuAMA")
                ENDIF
 ENDCASE
ENDPROC
:
DEFPROCh(M$)
 LOCAL C%
 M$=FNmsg_0(M$):IFadditional_help$<>"" M$+="|M"+additional_help$
 C%=LENM$+1
 Q%!12=Q%!8:Q%!16=&503:$(Q%+20)=M$+CHR$0
 !Q%=(24+C%) AND NOT3
 SYS"Wimp_SendMessage",17,Q%,Q%!4
ENDPROC
:
DEFFNiconblock_indirect(icon%, window%)
 REM Similar to FNicon_indirect, but returns a pointer to the
 REM iconblock corresponding to icon%
 LOCAL here%, loop%
 loop% = 0
 IF (icon% > window%!84) THEN
  =-1
 ELSE
  here% = window% + 88
  WHILE (loop% <> icon%)
   here% += 32
   loop% += 1
  ENDWHILE
 ENDIF
=here%
:
DEFFNicon_size_indirect(icon%, window%)
 REM Returns the size of an indirected icon.
 LOCAL here%, loop%
 loop% = 0
 IF (icon% > window%!84) THEN
  =-1
 ELSE
  here% = window% + 88
  WHILE (loop% <> icon%)
   here% += 32
   loop% += 1
  ENDWHILE
 ENDIF
=here%!28
:
DEFFNicon_indirect(icon%, window%)
 REM Returns a pointer to the indirected text area of icon icon%
 REM in window window%
 LOCAL here%, loop%
 loop% = 0
 IF (icon% > window%!84) THEN
  =-1
 ELSE
  here% = window% + 88
  WHILE (loop% <> icon%)
   here% += 32
   loop% += 1
  ENDWHILE
 ENDIF
=here%!20
:
DEFPROCset(I%)
 PROCsetstate(a_wind%,I%,1<<21,1<<21)
ENDPROC
:
DEFPROCredraw_icon(H%,I%)
 PROCsetstate(H%,I%,0,0)
ENDPROC
:
DEFPROCsetstate(H%,I%,E%,B%)
 !Q%=H%:Q%!4=I%:Q%!8=E%:Q%!12=B%
 SYS"Wimp_SetIconState",,Q%
ENDPROC
:
DEFPROCset_title(H%,title$)
 !Q%=H%:SYS"Wimp_GetWindowInfo",,Q%
 $(Q%!76)=title$
ENDPROC
:
DEFPROCset_string(H%,I%,s$)
 LOCAL cur_str$
 !Q%=H%:Q%!4=I%:SYS"Wimp_GetIconState",,Q%
 cur_str$ =$(Q%!28)
 IF cur_str$ <>s$ THEN
  $(Q%!28)=s$
  PROCredraw_icon(H%,I%)
 ENDIF
ENDPROC
:
DEFFNread_string(H%,I%)
 !Q2%=H%:Q2%!4=I%:SYS"Wimp_GetIconState",,Q2%
=$(Q2%!28)
:
DEFPROCfront(h%)
 !Q1%=h%:SYS"Wimp_GetWindowState",,Q1%
 Q1%!28=-1:SYS"Wimp_OpenWindow",,Q1%
ENDPROC

REM *************************************************************************
REM Template utilities
REM *************************************************************************

DEFFNtotal_indirect_size
 REM Returns the total size of all indirect fields in a
 REM template file (which must already have been opened)
 LOCAL total%, size%, here%
 LOCAL name%
 
 DIM name% 12
 $name% = "*"
 here%  = 0
 total% = 0
 
 SYS"Wimp_LoadTemplate", ,0,,,,name%,0 TO ,,size%,,,,here%
 WHILE (here% <> 0)
  total% += size%
  $name% = "*"
  SYS"Wimp_LoadTemplate", ,0,,,,name%,here% TO ,,size%,,,,here%
 ENDWHILE
=total%
:
DEFFNsize_indirect(name$)
 LOCAL size%
 SYS"Wimp_LoadTemplate",,0,,,,name$,0 TO ,,size%
=size%
:
DEFFNwinsize_indirect (name$)
 LOCAL size%
 SYS"Wimp_LoadTemplate",,0,,,,name$,0 TO ,size%
=size%
:
DEFPROCopen_templates
 LOCAL a%,n$
 n$="Alarm:Templates"
 SYS"OS_Byte",161,&8C TO ,,a%
 IF (a%AND1)=1 THEN
  REM Newlook 3D bit on
  SYS"OS_File",17,"Alarm:Template3D" TO a%
  IFa%=1 THEN n$="Alarm:Template3D":REM And there's a specific 3D file
 ENDIF
 SYS"Wimp_OpenTemplate",,n$
ENDPROC
:
DEFFNQsize
 LOCAL i%,s%,t%
 s%=3000 : REM Minimum size for buffer Q%
 PROCopen_templates
 i%=0
 REPEAT
  SYS"Wimp_LoadTemplate",,-1,,,-1,"*"+STRING$(11,CHR$(0)),i% TO ,t%,,,,,i%
  IF i%<>0 AND s%<t% s%=t%
 UNTIL i%=0
 SYS"Wimp_CloseTemplate"
=s%
:
DEF FNload_template(temp$)
 LOCAL ind%,ind_space%,win%
 ind% = FNsize_indirect (temp$)
 DIM ind_space% ind%
 SYS"Wimp_LoadTemplate",,Q%,ind_space%,ind_space% + ind%,-1,temp$,0 TO ,,,,,,r6%
 IFr6%=0 ERROR 0, FNmsg_1("Fatal5",temp$)
 SYS"Wimp_CreateWindow",,Q% TO win%
=win%

REM *************************************************************************
REM Message utilities (msglib 0.01)
REM *************************************************************************

DEFPROCmsg_init(N$)
 REM LOCAL ERROR
 REM ON ERROR LOCAL RESTORE ERROR:ERROR 0,"Cannot find messages file"
 DIM msg_text% 256
 SYS"OS_Module",6,,,17+LEN(N$) TO ,,msg_desc%
 $(msg_desc%+16)=N$
 SYS"MessageTrans_OpenFile",msg_desc%,msg_desc%+16,0
ENDPROC
:
DEFFNmsg_0(T$)
=FNmsg_4(T$,"","","","")
:
DEFFNmsg_1(T$,S0$)
=FNmsg_4(T$,S0$,"","","")
:
DEFFNmsg_2(T$,S0$,S1$)
=FNmsg_4(T$,S0$,S1$,"","")
:
DEFFNmsg_3(T$,S0$,S1$,S2$)
=FNmsg_4(T$,S0$,S1$,S2$,"")
:
DEFFNmsg_4(T$,S0$,S1$,S2$,S3$)
 LOCAL F%,L%,eb%
 SYS"XMessageTrans_Lookup",msg_desc%,T$,msg_text%,256,S0$,S1$,S2$,S3$ TO eb%,,,L%;F%
 IF F% AND 1 THEN=T$
 msg_text%?L%=13
=$msg_text%
:
DEFPROCmsg_end
 IFmsg_desc% THEN
  SYS"MessageTrans_CloseFile",msg_desc%
  SYS"OS_Module",7,,msg_desc%
 ENDIF
ENDPROC

REM *************************************************************************
REM Error handling utilities (errlib 0.01)
REM *************************************************************************

DEF PROCerr_report(err%,errortext$,flags%)
 LOCAL OKC%,wimpver%
 SYS"XWimp_DragBox",,-1
 IF err% =&108D5 OR err% =&108D4 THEN ENDPROC
 
 IF err% =errok% THEN flags% =flags% AND NOT %10
 IF err% =errfatal% THEN flags% =(3 <<9) +(%10)
 IF flags% AND %10 THEN flags% =flags% OR (3<<9)
 
 OKC% =flags% AND %11
 IF OKC% =%11 THEN errortext$ =FNmsg_2("Unexp",LEFT$(errortext$,230 -LEN(FNmsg_0("Unexp"))),STR$(ERL))
 IF OKC% =%10 THEN errortext$ =FNmsg_2("Fatal",LEFT$(errortext$,230 -LEN(FNmsg_0("Fatal"))),STR$(ERL))
 
 REM if wimp>350 then replace Cancel with Quit
 SYS"Wimp_ReadSysInfo",7 TO wimpver%
 IF wimpver% >350 AND (flags% AND %10) >0 THEN
  errortext$ =FNmsg_0("ErrBut")+"{"+LEFT$(errortext$,240 -LEN(FNmsg_0("ErrBut")))
 
  flags% =flags% AND NOT %10
 ENDIF
 
 IF FNerr_box(err%,errortext$,flags%) >1 THEN PROCshutdown
ENDPROC
:
REM Error categories (at <<9)
REM 0 as 2 (error)
REM 1 information report (information)= just tell user something
REM 2 error report (warning) = tell user about problem, but app will continue
REM 3 program report (program) = an error that should not occur and may require app to quit
REM 4 question report (question) = ask user question (ie DCS)
REM 5 do not use (user 1)
REM 6 do not use (user 2)
DEF FNerr_box(err%,but_msg$,flags%)
 LOCAL pos%,but$,err$
 pos% =INSTR(but_msg$,"{") :IF pos% THEN pos% -=1
 
 but$ =MID$(but_msg$,0,pos%)
 err$ =MID$(but_msg$,INSTR(but_msg$,"{") +1)
 err$ =CHR$(err%)+CHR$(err% >>8)+CHR$(err% >>16)+CHR$(err% >>24)+LEFT$(err$,251)
 
 IF but$ >"" THEN
  SYS"Wimp_ReportError",err$,(1<<8) +flags%,task_id$,,,but$ TO ,ans%
 ELSE
  SYS"Wimp_ReportError",err$,(1<<8) +flags%,task_id$ TO ,ans%
 ENDIF
=ans%
:
DEFPROCformat_error(e$)
 PROCset_format(3)
 PROCok(FNmsg_1("OkayA8",e$))
ENDPROC
:
DEFPROCok(e$)
 ERROR errok%,e$
ENDPROC
:
DEFPROCfatal(e$)
 REM PROCheap_dump("adfs::4.HeapDump","")
 ERROR errfatal%,e$
ENDPROC
:
DEFPROCwarning(e$)
 LOCAL null%
 IFalarm_warned% ENDPROC
 alarm_warned%=TRUE
 null% =FNerr_box(1,e$,1)
ENDPROC
:
DEFPROCout_of_memory
 REM not a lot we can do except give a 'nice' error and quit
 PROCfatal(FNmsg_0("OkayD3"))
ENDPROC

REM *************************************************************************
REM String utilities
REM *************************************************************************

DEFFNrtoz(P%)
 LOCAL t$
 WHILE ?P%
  t$+=CHR$?P%:P%+=1
 ENDWHILE
=t$
:
DEFFNupper(s$)
 LOCAL I%,j$
 FOR I%=1 TO LENs$
  j$=MID$(s$,I%,1)
  IF j$>="a" AND j$<="z" MID$(s$,I%,1)=CHR$(ASC(j$)-32)
 NEXT
=s$
:
DEFFNconvertextras(f$)
REM expand system variables
REM if we exceed max basic string length then an empty string is returned
SYS"OS_GSTrans",f$,STRING$(255,"*"),254 TO ,f$
=f$
:
DEFFNbuild_alarm_options
 LOCAL s$,q$,form$,fix_form$,c$
 q$ =CHR$(34)
 s$="Set Alarm$Options"
 s$+=" -timeout "+q$+STR$(global_timeout%)+q$
 s$+=" -weekwork "+STR$(global_weekwork%)
 form$ =FNread_string(setup%,ic_setup_user_string%)
 fix_form$ =""
 
 REM we need to change '<' to '|<' to preserve variable names
 WHILE form$ >""
  c$ =LEFT$(form$,1)
  form$ =MID$(form$,2)
  IF c$ ="<" THEN fix_form$ +="|"
  fix_form$ +=c$
 ENDWHILE
 s$+=" -format "+q$+fix_form$+q$
=s$
:
DEFFNread_system_string(v$,default$)
 LOCAL P%
 SYS"XOS_ReadVarVal",v$,Q%,-1,0,3 TO ,,P%
 IF P%=0 :=default$
 SYS"XOS_ReadVarVal",v$,Q%,256,0,3 TO ,,P%
 Q%?P%=13
=$Q%
:
DEFFNleafname_ptr(f1%)
 LOCAL f2%
 REPEAT
  f2%=f1%
  f1%+=INSTR($f1%,":")
 UNTIL f1%=f2%
 REPEAT
  f2%=f1%
  f1%+=INSTR($f1%,".")
 UNTIL f1%=f2%
=f1%
:
DEFFNdigits(size%,val%)
=RIGHT$(STRING$(size%,"0")+STR$(val%),size%)
:
DEFFNchksum_textlen(t$)
 LOCAL check%
 check% =0
 WHILE t$ >""
  c$ =LEFT$(t$,1) :t$ =MID$(t$,2)
 
  CASE c$ OF
  WHEN "0","1","2","3","4","5","6","7","8","9":
   check% +=1
  WHEN "W","X":
   check% +=&100
  WHEN ",",".",":",";":
   check% +=&10000
  OTHERWISE:
   check% +=&1000000
  ENDCASE
 ENDWHILE
=check%

REM *************************************************************************
REM Time utilities (subtime 0.00)
REM *************************************************************************

DEF PROCinit_timediff
 DIM cur_time% 4,copy_first% 7,copy_second% 7,cur_ordinals% 35,first_ordinals% 35,sub_time% 63
 
 P%=sub_time%
 [OPT 2
  LDMIA r0,{r2,r4}
  LDMIA r1,{r3,r5}
  SUBS  r2,r3,r2
  SBC   r4,r5,r4
  STMIA r0,{r2,r4}
  
  CMP   r0,#0 ;clrv
  MOV   pc,r14
 ]
ENDPROC
:
DEF PROCtime_diff(first%,second%,RETURN sign%,RETURN yrs%,RETURN days%,RETURN hrs%,RETURN mins%)
 LOCAL A%,B%
 
 copy_first%!0 =first%!0
 copy_first%!4 =first%?4
 copy_second%!0 =second%!0
 copy_second%!4 =second%?4
 
 A% =copy_first%
 B% =copy_second%
 CALL sub_time%
 
 IF copy_first%?5 =&FF THEN
  REM subtract from 0 to negate
  copy_second%!0 =0
  copy_second%!4 =0
  CALL sub_time%
  sign% =-1
 ELSE
  sign% =0
 ENDIF
 
 SYS"Territory_ConvertTimeToUTCOrdinals",,copy_first%,first_ordinals%
 yrs% =(first_ordinals%!&18) -1900
 days% =(first_ordinals%!&20) -1
 hrs% =(first_ordinals%!&C)
 mins% =(first_ordinals%!&8)
ENDPROC
:
DEFPROCset_timex_for_next_second
SYS"OS_ReadMonotonicTime" TO timeslip%
timeslip%-=timex%
timex%+=timeslip% - (timeslip% MOD 100) + 100
ENDPROC
:
DEFPROCset_format(F%)
 format%=F%
 IF format%=1 THEN format$="~AH:~AM:~AS"
 IF format%=2 THEN format$="~AH:~AM"
 IF format%=3 THEN format$="%24~IN%MI"
 IF format%=4 THEN format$="%24:%MI:%SE"
 IF format%=5 THEN format$=userformat$
 
 secs_used%=FNseconds_used(format$)
 PROCset_timex_for_next_second
ENDPROC

REM *************************************************************************
REM Menu utilities
REM *************************************************************************

DEFFNcrmenu(menu$)
 LOCAL M%,I%,maxlen%
 IF (menufree%+28>menuend%) PROCfatal(FNmsg_0("Fatal2"))
 menuptr%=menufree%
 I%=0
 maxlen%=0
 IF LEFT$(menu$,1)="#" I%=1:menutitle$=FNpar(",") ELSE menutitle$=""
 IF LENmenutitle$ <= 12 THEN
  $menuptr%=LEFT$(menutitle$,12)
 ELSE
  menuptr%!0 = FNworkspace (LEN(menutitle$)+1)
  menuptr%!4 = -1
  menuptr%!8 = LENmenutitle$
  $(menuptr%!0) = menutitle$
 ENDIF
 menuptr%?12=7
 menuptr%?13=2
 menuptr%?14=7
 menuptr%?15=0
 menuptr%!16=196
 menuptr%!20=44
 menuptr%!24=0
 menuptr%+=28
 REPEAT
  item$=FNpar(",")
  IF maxlen% < LEN(item$) THEN
   maxlen% = LENitem$
  ENDIF
  PROCmenuitem(item$)
 UNTIL item$=""
 M%=menufree%
 IF LENmenutitle$ <= 12 THEN
  IF LEN(LEFT$(menutitle$, 12)) > maxlen% THEN
   maxlen% = LEN(LEFT$(menutitle$, 12))
  ENDIF
 ELSE
  M%!28=M%!28 OR 256
  IF LEN(menutitle$) > maxlen% THEN
   maxlen% = LEN(menutitle$)
  ENDIF
 ENDIF
 M%!16=(maxlen% + 1) * 16
 menufree%=menuptr%
=M%
:
DEFPROCmenuitem(text$)
 LOCAL I%,F%,L%
 IF text$="" menuptr%!-24=(menuptr%!-24)OR &80:ENDPROC
 IF (menuptr%+24>menuend%) PROCfatal(FNmsg_0("Fatal2"))
 F%=&00
 IF RIGHT$(text$,1)="#" text$=LEFT$(text$):F%+=&02
 IF RIGHT$(text$,1)="@" text$=LEFT$(text$):F%+=&08
 menuptr%!0=F%
 menuptr%!4=-1
 menuptr%!8=&07000021
 IF LEFT$(text$,1)="$" THEN
  !menuptr%+=&04
  menuptr%!8+=&100
  menuptr%!16=-1
  text$=STRING$(16, " ")
 ELSE
  IF LENtext$<=12 THEN
   $(menuptr%+12)=text$
  ELSE
   I%=FNworkspace(LEN(text$)+1):$I%=text$
   menuptr%!12=I%:menuptr%!16=-1:menuptr%!20=LENtext$+1
   menuptr%!8=menuptr%!8 OR &100
  ENDIF
 ENDIF
 menuptr%+=24
ENDPROC
:
DEFPROCattach(menu%,item%,ptr%,traverse%)
 menu%+=28+item%*24
 IF traverse% !menu%=!menu% OR (1<<4)
 menu%!4=ptr%
ENDPROC
:
DEFPROCwriteable(menu%,item%,ptr%,size%)
 LOCAL M%,L%
 IF LEN($menu%) <= 12 THEN
  M%=LEN$menu%-3
 ELSE
  M%=LEN$!menu%-3
 ENDIF
 L%=size%:IF L%>16 L%=16
 IF L%>M% M%=L%
 menu%!16=(M%*8+6)*2
 menu%+=28+item%*24
 menu%!12=ptr%
 menu%!20=size%
ENDPROC
:
DEFFNpar(sep$)
 LOCAL L%
 L%=I%+1
 I%=INSTR(menu$+sep$,sep$,L%)
=MID$(menu$,L%,I%-L%)
:
DEFPROCset_shade(menuhandle%,item%,value%)
 IF -((menuhandle%!(28+8+24*item%) AND &400000)=&400000)<>value% THEN
  menuhandle%!(28+8+24*item%)=menuhandle%!(28+8+24*item%)EOR &400000
 ENDIF
ENDPROC
:
DEFPROCtick(menuhandle%,item%)
 menuhandle%!(28+24*item%)=menuhandle%!(28+24*item%)EOR 1
ENDPROC
:
DEFFNworkspace(L%)
 IF menu_curws%+L%>menu_ws%+menu_maxws% PROCfatal(FNmsg_0("Fatal3"))
 menu_curws%+=L%
=menu_curws%-L%

REM *************************************************************************
REM Heap utilities
REM *************************************************************************

DEFFNheap_ident_num(v$)
 LOCAL i%,j%
 FORi%=0 TO 3
  j%=j% OR ASC(MID$(v$,i%+1,1))<<(i%*8)
 NEXT
=j%
:
DEFFNheap_claim(ident$,size%)
 LOCAL p%,f%
 REM need to add 4 extra bytes 'cos if the block needs
 REM extending then the first word gets trampled on
 size%+=4
 f%=TRUE
 WHILE size%>=FNheap_freespace AND f%=TRUE
  f%=FNheap_increase
 ENDWHILE
 REM claim the block and store the ident
 SYS"XOS_Heap",2,heap_start%,,size% TO ,,p%;f%
 IF(f%AND1) :=0
 !p%=FNheap_ident_num(ident$)
 p%+=4
=p%
:
DEFPROCheap_reset
 LOCAL slot%
 IFheap_size%>0 THEN
  SYS"Wimp_SlotSize",-1,-1 TO slot%
  SYS"Wimp_SlotSize",slot%-heap_size%,-1
  heap_size%=0
 ENDIF
ENDPROC
:
DEFFNheap_increase
 LOCAL slot%
 SYS"Wimp_SlotSize",-1,-1 TO slot%
 SYS"Wimp_SlotSize",slot%+heap_psize%,-1
 IFheap_size%=0 THEN
  SYS"XOS_Heap",0,heap_start%,,heap_psize% TO ;slot%
  IF(slot% AND 1) PROCok(FNmsg_1("OkayD2",STR$(heap_psize%/1024)))
 ELSE
  SYS"XOS_Heap",5,heap_start%,,heap_psize% TO ;slot%
  IF(slot% AND 1) :=FALSE
 ENDIF
 heap_size%+=heap_psize%
=TRUE
:
DEFFNheap_freespace
 LOCAL f%
 IFheap_size%=0 THEN =0
 SYS"OS_Heap",1,heap_start% TO ,,f%
=f%
:
DEFPROCheap_free(ident$,block%)
 LOCAL r0%,f%
 IFblock% THEN
  block%-=4
  IF!block%<>FNheap_ident_num(ident$) PROCfatal(FNmsg_1("BNF", ident$))
  SYS"XOS_Heap",3,heap_start%,block% TO r0%;f%
  IF(f% AND 1) PROCfatal(FNmsg_2("ODD1", ident$, FNrtoz(r0%+4)))
  SYS"XOS_Heap",1,heap_start% TO ,,,f%
  IF(f%+16)=heap_size% PROCheap_reset
 ENDIF
ENDPROC
:
DEFFNheap_extend(ident$,block%,size%)
 LOCAL p%,current%,i%,f%
 block%-=4
 IF!block%<>FNheap_ident_num(ident$) PROCfatal(FNmsg_1("BNE", ident$))
 REM find out how big this block is
 SYS"OS_Heap",6,heap_start%,block% TO ,,,current%
 REM check that there is enough space in the heap for a duplicate of this block
 f%=TRUE
 WHILE (current%+size%)>=FNheap_freespace AND f%=TRUE
  f%=FNheap_increase
 ENDWHILE
 SYS"OS_Heap",4,heap_start%,block%,size% TO ,,p%
=p%+4
:
DEFFNws_claim(RETURN ws%, size_required%)
 ws%+=size_required%
=(ws%-size_required%)

REM *************************************************************************
REM Choices utilities
REM *************************************************************************

DEFFNopen(name$,action%)
 LOCAL C%
 LOCAL ERROR
 ON ERROR LOCAL :=-1
 SYS"OS_Find",%1100+action%,name$ TO C%
=C%
:
DEFFNclose(handle%)
 LOCAL ERROR
 ON ERROR LOCAL :=-1
 SYS"OS_Find",0,handle%
=0
:
DEFFNgot_time_setup
 LOCAL ftype%
 REM If boot sequence didn't run it wont have set this variable
 IF FNread_system_string("Boot$OSVersion", "") = "" THEN =FALSE
 REM Look in boot resources for the plugin application
 SYS"XOS_File",23,"BootResources:Configure.!TimeSetup" TO,,,,,,ftype%
=ftype%=8192

DEFPROCsave_config
 LOCAL cmos%,cli$,cli2$,i%,opt_file$,f%

 cli$ =FNbuild_alarm_options
 SYS"OS_CLI",cli$
 
 REM for obey file we must double every % otherwise it will change
 REM "%24" into "4" as it think's %2 is a cli parameter
 cli2$ =""
 WHILE cli$ >""
  IF ASC(cli$) =37 THEN cli2$ +="%"
  cli2$ +=LEFT$(cli$,1)
  cli$ =MID$(cli$,2)
 ENDWHILE
 
 opt_file$ ="<Choices$Write>.Boot.Predesk.Alarm"
 SYS"XOS_Find",&80,opt_file$ TO i%;f%
 IF(f%AND1) THEN
  PROCok(FNrtoz(i%+4))
 ELSE
  BPUT#i%,cli2$
  CLOSE#i%
  SYS"XOS_File",18,opt_file$,&FEB
 ENDIF
 
 SYS"XOS_Byte",161,&DC TO ,,cmos%
 cmos%=(cmos% AND &80) OR format% :REM Preserve DST, mix in display format
 IFalarm_confirm%  cmos%=cmos% OR %1000
 IFalarm_autosave% cmos%=cmos% OR %10000
 IFfivedayweek%    cmos%=cmos% OR %100000
 IFsilent_alarm%   cmos%=cmos% OR %1000000
 SYS"XOS_Byte",162,&DC,cmos% TO i%;f%
 IF(f%AND1) THEN PROCok(FNrtoz(i%+4))
ENDPROC
:
DEFPROCsave_setup(filetype%,filesize%,handle%,icon_name$)
 LOCAL b$
 b$=STR$~(filetype%)
 b$=RIGHT$("000"+b$,3)
 save_filetype%=filetype%
 save_filesize%=filesize%

 REM the handle is used PURELY as a reference by the host program as to
 REM what is being saved (ie the host program could be capable of
 REM producing more than one file and otherwise won't know)
 save_handle%=handle%
 !Q2%=save%:Q2%!4=3:SYS"Wimp_GetIconState",,Q2%
 $(Q2%!32)="sfile_"+b$
 !Q2%=save%:Q2%!4=2:SYS"Wimp_GetIconState",,Q2%
 $(Q2%!28)=icon_name$
ENDPROC
:
DEFPROCsavefile(f%,l$,m%)
 IF f% THEN
  IF INSTR(l$,".")=0 AND INSTR(l$,":")=0 PROCok(FNmsg_0("OkayC1"))
 ENDIF

 CASE save_handle% OF
 WHEN 1:PROCprint_the_alarms_out(l$,TRUE)
 WHEN 2:PROCsave_alarms_to_disc(l$,TRUE,f%,TRUE)
        PROCunset_alarms_selection
 WHEN 3:PROCprint_the_alarms_out(l$,FALSE)
 WHEN 4:PROCsave_alarms_to_disc(l$,FALSE,f%,TRUE)
        PROCunset_alarms_selection
        PROCopen_browser:REM to adjust the title bar
 ENDCASE

 IF m% THEN
  IFmenudata% SYS"Wimp_CreateMenu",,menudata%,menux%,menuy%
 ELSE
  SYS"Wimp_CreateMenu",,-1
 ENDIF

 CASE doing_shutdown% OF
 WHEN 1:PROCshutdown
 WHEN 3:SYS"Wimp_ProcessKey",&1FC
 ENDCASE
ENDPROC
:
DEFPROCdragicon(mousex%,mousey%,handle%,icon%)
 LOCAL bx%,by%,ix0%,ix1%,iy0%,iy1%,f$
 savewind%=handle%
 !Q%=handle%:SYS"Wimp_GetWindowState",,Q%
 bx%=Q%!4-Q%!20
 by%=Q%!16-Q%!24
 !Q%=handle%:Q%!4=icon%:SYS"Wimp_GetIconState",,Q%
 ix0%=Q%!8
 iy0%=Q%!12
 ix1%=Q%!16
 iy1%=Q%!20
 !Q%=handle%
 Q%!4=5
 Q%!8=bx%+ix0%
 Q%!12=by%+iy0%
 Q%!16=bx%+ix1%
 Q%!20=by%+iy1%
 Q%!24=Q%!8-mousex%
 Q%!28=Q%!12-mousey%
 Q%!32=scrx1%+Q%!16-mousex%
 Q%!36=scry1%+Q%!20-mousey%
 IFsave_start%<>-1 THEN
  f$="file_"+RIGHT$("000"+STR$~(save_filetype%),3)
  SYS save_start%,%11000101,1,f$,Q%+8,Q%+24
 ELSE
  SYS"Wimp_DragBox",,Q%
 ENDIF
ENDPROC
:
DEFPROCdrag_savefile(h%,i%,mx%,my%)
 LOCAL f1%,ext%
 f1%=FNleafname_ptr(filename%)
 !Q%=(48+LEN$f1%) AND NOT3
 Q%!12=0
 Q%!16=1
 Q%!20=h%
 Q%!24=i%
 Q%!28=mx%
 Q%!32=my%
 Q%!36=0
 Q%!40=&FFF
 $(Q%+44)=$f1%
 ?(Q%+44+LEN$(Q%+44))=0
 SYS"Wimp_SendMessage",17,Q%,h%,i%
 saveref%=Q%!8
ENDPROC
REM This source code in this file is licensed to You by Castle Technology
REM Limited ("Castle") and its licensors on contractual terms and conditions
REM ("Licence") which entitle you freely to modify and/or to distribute this
REM source code subject to Your compliance with the terms of the Licence.
REM
REM This source code has been made available to You without any warranties
REM whatsoever. Consequently, Your use, modification and distribution of this
REM source code is entirely at Your own risk and neither Castle, its licensors
REM nor any other person who has contributed to this source code shall be
REM liable to You for any loss or damage which You may suffer as a result of
REM Your use, modification or distribution of this source code.
REM
REM Full details of Your rights and obligations are set out in the Licence.
REM You should have received a copy of the Licence with this source code file.
REM If You have not received a copy, the text of the Licence is available
REM online at www.castle-technology.co.uk/riscosbaselicence.htm
REM
REM > Clock

REM *************************************************************************
REM Clock plotting
REM *************************************************************************

DEFFNiconbar
 LOCAL I%,A%,priority%,analogue%
 PROCprepare_icon
 SYS"OS_SpriteOp",&118,icons%,"-time" TO ,,A%
 IF ictime%=-1 THEN
  REM initial placement
  !buffers%=-7
  priority% =&10000000
 ELSE
  REM subsequent replacement
  !buffers%=-4
  priority% =ictime%
 ENDIF

 analogue% = FNanalogue

 buffers%!4=0 : REM minx
 IF analogue% THEN buffers%!8=-18 ELSE buffers%!8=0 : REM miny
 buffers%!12=icon_width% : REM maxx
 IF analogue% THEN buffers%!16=buffers%!8+icon_height% ELSE buffers%!16=68 : REM maxy
 buffers%!20=%00000111000000000011000100010010
 buffers%!24=A%
 buffers%!28=icons%
 buffers%!32=0
 SYS"Wimp_CreateIcon",priority%,buffers% TO I%

 IF ictime%<>-1 THEN
  REM and delete the old one
  !buffers%=-1
  buffers%!4=ictime%
  SYS"Wimp_DeleteIcon",,buffers%
 ENDIF
=I%
:
DEFPROCreset_alarm_status
 LOCAL U%
 PROCread_first_alarm(alarms%(1))
 PROCgettime
 PROCredraw_icon(-1,ictime%)
 PROCset_timex_for_next_second
ENDPROC
:
DEFPROCprepare_icon
 LOCAL W%,X%,Y%,Z%,C%,mode%
 Q%!0=4
 Q%!4=5
 Q%!8=11
 Q%!12=12
 Q%!16=-1
 SYS"OS_ReadVduVariables",Q%,Q%+20
 dx%=(Q%!20)
 dy%=(Q%!24)
 scrx1%=(Q%!28+1) <<dx%
 scry1%=(Q%!32+1) <<dy%
 CASE ((dx% <<4) OR dy%) OF
  WHEN &22:  mode% =9  : REM 45x45
  WHEN &11:  mode% =27 : REM 90x90
  WHEN &12:  mode% =12 : REM 90x45
  OTHERWISE: mode% =(3 <<27) OR ((180 >>dx%) <<1) OR ((180 >>dy%) <<14) OR1 : REM 4bpp new type sprite
 ENDCASE
 IF FNanalogue THEN
  icon_width% =116 : REM OS unit circle
  icon_height%=116
  icons% =FNmake_4bpp_sprite("-time",icon_width% >>>dx%,icon_height% >>>dy%,mode%,TRUE)
  SYS"OS_SpriteOp",&11D,icons%,"-time"
  SYS"OS_SpriteOp",&13D,icons%,"-time",0 TO W%,X%,Y%,Z%
  GCOL 0,128
  TINT 3,0
  CLG
  GCOL 0,63
  TINT 2,&FF
  C%=icon_width% /2 : REM Circle centre
  CIRCLE FILL C%,C%,C%-1 : REM Mask slightly smaller than the clock
  SYS"OS_SpriteOp",W%,X%,Y%,Z%
 ELSE
  icon_height% =68 : REM Per style guide
  icons% =FNmake_4bpp_sprite("-time",icon_width% >>>dx%,icon_height% >>>dy%,mode%,FALSE)
 ENDIF
ENDPROC
:
DEF FNmake_4bpp_sprite(name$,x%,y%,mode%,mask%)
 LOCAL size%,pal%
 IF spr_area% >0 THEN PROCheap_free("SPRT",spr_area%)

 REM work in bits for 4bpp
 size% = x% *4
 REM round up to nearest word
 size% = (size% +31) AND NOT 31
 size% = ((size% *y%) /8)

 REM allow for a transparency mask (wastes a few bytes in new type sprites)
 IF mask% THEN size% =size% *2

 REM sprite area and header and palette
 size% +=16 +44 +(16*2*4)
 
 spr_area% =FNheap_claim("SPRT",size%)
 !spr_area%=size%:spr_area%!4=0:spr_area%!8=16:spr_area%!12=16
 SYS"OS_SpriteOp",&109,spr_area%
 SYS"OS_SpriteOp",&10F,spr_area%,name$,1,x%,y%,mode%

 REM Overwrite a VIDC1 desktop palette
 pal% =spr_area% +16 +44
 FOR x% =0 TO15
  CASE x% OF
   WHEN0,1,2,3,4,5,6:y% =(15 -(x% *2)) *&111111
   WHEN7:            y% =0
   WHEN8:            y% =&994400
   WHEN9:            y% =&00EEEE
   WHEN10:           y% =&00CC00
   WHEN11:           y% =&0000DD
   WHEN12:           y% =&BBEEEE
   WHEN13:           y% =&008855
   WHEN14:           y% =&00BBFF
   WHEN15:           y% =&FFBB00
  ENDCASE
  !(pal% +(x% *8) +0) =y% <<8
  !(pal% +(x% *8) +4) =y% <<8
 NEXT
=spr_area%
:
DEF PROCrect(colour%,x%,y%,w%,h%,thickness%)
 GCOL colour%
 RECTANGLE FILL x%,y%,thickness%,h%
 RECTANGLE FILL x%,y%,w%,thickness%
 RECTANGLE FILL x%,y% +h% -thickness%,w%,thickness%
 RECTANGLE FILL x% +w% -thickness%,y%,thickness%,h%
ENDPROC
:
DEFPROCclock(t$)
 LOCAL T%,I%,H%,M%,S%,R%,X%,Y%
 H%=VAL(LEFT$(t$,2))
 M%=VAL(MID$(t$,4,2))
 S%=VAL(RIGHT$(t$,2))
 R%=icon_width%/2-1
 X%=icon_width%/2:Y%=X%
 CLS
 IF user_alarm_set% THEN GCOL 11 ELSE GCOL 8
 IF R%>150 THEN
  T%=R%-(R%>>5)-8
  FOR I%=0 TO 59
   POINT X%+T%*sin(I%),Y%+T%*cos(I%)
  NEXT
 ENDIF
 IF R%>50 THEN
  T%=R%-(R%>>4)
  FOR I%=0 TO 59 STEP 5
   T%=R%-(R%>>4)
   RECTANGLE FILL X%+T%*sin(I%)-(R%>>5),Y%+T%*cos(I%)-(R%>>5),R%>>4
  NEXT
 ENDIF
 IF user_alarm_set% THEN GCOL 14 ELSE GCOL 15
 CIRCLE X%,Y%,R%
 PROChands(H%,M%,S%,R%,X%,Y%)
ENDPROC
:
DEFPROChands(H%,M%,S%,R%,X%,Y%)
 GCOL 4
 IF INSTR(format$,"~AH") THEN PROChand(H%*5+M%DIV 12,X%,Y%,R%-(R%>>1))
 IF INSTR(format$,"~AM") THEN PROChand(M%,X%,Y%,R%-(R%>>2))
 IF INSTR(format$,"~AS") THEN
  GCOL 11
  MOVE X%,Y%
  DRAW BY (R%-(R%>>4))*sin(S%MOD 60),(R%-(R%>>4))*cos(S%MOD 60)
  GCOL 11
  CIRCLE FILL X%,Y%,R%>>4
 ENDIF
ENDPROC
:
DEFPROChand(A%,X%,Y%,R%)
 LOCAL T%
 T%=(R%>>1)/cos(1)
 MOVE X%+sin((A%+1) MOD 60)*T%,Y%+cos((A%+1) MOD 60)*T%
 MOVE X%,Y%
 PLOT 117,X%+sin((A%+60-1) MOD 60)*T%,Y%+cos((A%+60-1) MOD 60)*T%
ENDPROC
:
DEFPROCgettime
 LOCAL t$,font%,flags%,W%,X%,Y%,Z%,maxy%,miny%

 REM Get the time, and apply the GSTran'd format to it 
 ?cur_clock%=3:SYS"OS_Word",14,cur_clock%
 t$=FNconverttime(cur_clock%,FNconvertextras(format$))
 
 textlen% =FNchksum_textlen(t$) : REM Sizeable change?

 SYS"XWimp_ReadSysInfo",8 TO font%;flags%
 IF flags% AND1 THEN font% =0 : REM No readsysinfo 8, use system font

 IF cur_format$ <> format$ OR cur_textlen% <> textlen% THEN
  REM An issue in RO6.06 with 16 colour modes makes the text 'bounce' due
  REM to changes in the y size, splitting the code this way ensures
  REM the value is recached only on a mode/font change
  IF font% =0 THEN
   icon_width%  =(16 * LENt$) +40
  ELSE
   SYS"Wimp_TextOp",1,t$,0 TO len%
   icon_width%  =len% +40

   SYS"Font_CharBBox",font%,ASC("0"),0 TO ,,miny%,,maxy%
   SYS"Font_Converttopoints",,20,68 TO ,icon_xoff_mp%,icon_height_mp%
   cur_fonty% =maxy% -miny%
  ENDIF
 
  ictime%=FNiconbar
  
  cur_format$ =format$
  cur_textlen% =textlen%
 ENDIF

 SYS"OS_SpriteOp",&13C,icons%,"-time",0 TO W%,X%,Y%,Z%
 VDU 5
 IF FNanalogue THEN
  t$=FNconverttime(cur_clock%,"%24:%MI:%SE")
  PROCclock(t$)
 ELSE
  IF user_alarm_set% THEN C%=11:D%=14 ELSE C%=8:D%=15

  PROCrect(C%,0,0,icon_width% -1,icon_height% -1,3)
  PROCrect(D%,4,4,icon_width% -1-8,icon_height% -1 -8,3)

  REM clear whole plinth
  GCOL 0
  RECTANGLE FILL 8,8,icon_width% -1 -16,icon_height% -1 -16

  IF font% =0 THEN
   GCOL 7
   VDU 23,17,7,%110,16 >>>dx%;32 >>>dy%|
   MOVE (icon_width% - (16 * LENt$)) / 2,46:PRINT t$
  ELSE
   SYS"XColourTrans_SetFontColours",font%,&ffffff00,0,14
   SYS"XFont_Paint",font%,t$,(1 << 8),icon_xoff_mp%,(icon_height_mp% - cur_fonty%) DIV 2
  ENDIF
 ENDIF
 SYS"OS_SpriteOp",W%,X%,Y%,Z%
ENDPROC
:
DEF FNanalogue
=INSTR(format$,"~AH") OR INSTR(format$,"~AM") OR INSTR(format$,"~AS")

REM *************************************************************************
REM Date internationalisation
REM *************************************************************************

DEFFNmonthsinyear(year%)
 REM catch bad years. This is safe to do here!
 IFyear%<1901 year%=1901
 IFyear%>2247 year%=2247
 REM first of all, build a five byte time
 PROCordinals_to_fivebt(buffers%,1,1,1,1,year%)
 REM now get the number of months in this year
 SYS"Territory_ReadCalendarInformation",-1,buffers%,Q2%
=Q2%!8
:
DEFFNdaysinmonth(month%,year%)
 REM catch bad years. This is safe to do here!
 IFyear%<1901 year%=1901
 IFyear%>2247 year%=2247
 REM first of all, build a five byte time
 PROCordinals_to_fivebt(buffers%,1,1,1,month%,year%)
 REM now find out how many days there are in this month
 SYS"Territory_ReadCalendarInformation",-1,buffers%,Q2%
=Q2%!12
:
DEFFNvalid_day(D%)
 D%-=1
 IF(global_weekwork% AND (1<<D%)) :=TRUE
=FALSE
:
DEFFNvalid_day_of_week(I%)
 LOCAL J%
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNvalid_day_of_week")
 IF I%?alarm_fvdywk% THEN
  IF(global_weekwork% AND (1<<FNday_of_week(I%)))=0 =FALSE
 ENDIF
=TRUE
:
REM Territory manager returns day numbers as 1 = Sunday to
REM 7 = Saturday.
REM This function returns them as 0 = Sunday to 6 = Saturday.
DEFFNday_of_week(I%)
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNday_of_week")
 PROCalarm_rec_to_fivebt(I%,buffers%)
 SYS"Territory_ConvertTimeToOrdinals",-1,buffers%,Q2%
=Q2%!28-1
:
DEFFNconverttime(B%,form$)
 LOCAL T%,F%,f$,tst$
 f$ =""
 WHILE form$ >""
  tst$ =LEFT$(form$,3)
  IF tst$ ="~IN" THEN
   IF VAL(FNconverttime(B%,"%SE")) MOD 2 =0 THEN
    f$ +="."
   ELSE
    f$ +=":"
   ENDIF
   form$ =MID$(form$,4)
  ELSE
   f$ +=LEFT$(form$,1)
   form$ =MID$(form$,2)
  ENDIF
 ENDWHILE
 SYS"XTerritory_ConvertDateAndTime",-1,B%,Q1%,81,f$+CHR$13+CHR$0 TO ,T%;F%
 IF(F% AND 1) THEN
  $Q1%=FNmsg_0("FrmtA4")
 ELSE
  ?T%=13
 ENDIF
=$Q1%
:
DEFPROCfivebt_to_ordinals(fivebt%,RETURN hr%,RETURN mi%,RETURN da%,RETURN mo%,RETURN yr%)
 SYS"Territory_ConvertTimeToOrdinals",-1,fivebt%,Q2%
 mi%=Q2%!8
 hr%=Q2%!12
 da%=Q2%!16
 mo%=Q2%!20
 yr%=Q2%!24
ENDPROC
:
DEFPROCalarm_rec_to_fivebt(ptr%,fivebt%)
 LOCAL hr%,mi%,da%,mo%,yr%
 REM IFFNcheck_pointer PROCcheck_pointer(ptr%,"PROCalarm_rec_to_fivebt")
 hr%=ptr%!alarm_hours%
 mi%=ptr%!alarm_minutes%
 da%=ptr%!alarm_date%
 mo%=ptr%!alarm_month%
 yr%=ptr%!alarm_year%
 PROCordinals_to_fivebt(fivebt%,hr%,mi%,da%,mo%,yr%)
ENDPROC
:
DEFPROCordinals_to_fivebt(fivebt%,hr%,mi%,da%,mo%,yr%)
 !Q2%=0
 Q2%!4=0
 Q2%!8=mi%
 Q2%!12=hr%
 Q2%!16=da%
 Q2%!20=mo%
 Q2%!24=yr%
 SYS"Territory_ConvertOrdinalsToTime",-1,fivebt%,Q2%
ENDPROC
:
DEFFNseconds_used(s$)
 LOCAL I%
 WHILE s$ >""
  cmp$ =FNupper(LEFT$(s$,4))
  IF LEFT$(cmp$,1) ="<" THEN =TRUE
  IF LEFT$(cmp$,2) ="%Z" THEN cmp$ ="%"+MID$(cmp$,3)
 
  CASE LEFT$(cmp$,3) OF
  WHEN "%SE","~AS","~IN"
   =TRUE
  ENDCASE

  s$ =MID$(s$,2)
 ENDWHILE
=FALSE
:
DEFFNwidth(s$)
 LOCAL W%,M%,I%,A%,c$
 W%=0
 WHILE s$<>""
  I%=INSTR(s$,"%")
  IFI%=0 THEN
   W%+=LENs$
   s$=""
  ELSE
   W%+=I%-1
   s$=MID$(s$,I%+1)
   IFLEFT$(s$,1)="%" THEN
    W%+=1
    s$=MID$(s$,2)
   ELSE
    IFFNupper(LEFT$(s$,1))="Z" s$=MID$(s$,2)
    c$=FNupper(LEFT$(s$,2)):s$=MID$(s$,3)
    CASE c$ OF
     WHEN "CS":W%+=2
     WHEN "SE":W%+=2
     WHEN "MI":W%+=2
     WHEN "12":W%+=2
     WHEN "24":W%+=2
     WHEN "AM":W%+=widths%(width_am%)
     WHEN "PM":W%+=widths%(width_am%)
     WHEN "WE":W%+=widths%(width_we%)
     WHEN "W3":W%+=widths%(width_w3%)
     WHEN "WN":W%+=1
     WHEN "DY":W%+=widths%(width_dy%)
     WHEN "ST":W%+=widths%(width_st%)
     WHEN "MO":W%+=widths%(width_mo%)
     WHEN "M3":W%+=widths%(width_m3%)
     WHEN "MN":W%+=2
     WHEN "CE":W%+=2
     WHEN "YR":W%+=2
     WHEN "WK":W%+=2
     WHEN "DN":W%+=3
     WHEN "TZ":W%+=widths%(width_tz%)
     WHEN "AH","AM","AS":W%=1
     OTHERWISE: PROCformat_error(FNmsg_1("FrmtA1",c$))
    ENDCASE
   ENDIF
  ENDIF
 ENDWHILE
=W%

REM *************************************************************************
REM Clock set
REM *************************************************************************

DEFPROCset_clock_from_alarm_rec(ptr%)
 REM IFFNcheck_pointer PROCcheck_pointer(ptr%,"PROCset_clock_from_alarm_rec")
 PROCalarm_rec_to_fivebt(ptr%,Q2%)
 SYS"Territory_SetTime",Q2%
ENDPROC

REM *************************************************************************
REM Clock validation
REM *************************************************************************

DEFPROCvalidate_alarm_rec(ptr%,RETURN error%)
 LOCAL hr%,mi%,da%,mo%,yr%
 REM IFFNcheck_pointer PROCcheck_pointer(ptr%,"PROCvalidate_alarm_rec")
 hr%=ptr%!alarm_hours%
 mi%=ptr%!alarm_minutes%
 da%=ptr%!alarm_date%
 mo%=ptr%!alarm_month%
 yr%=ptr%!alarm_year%
 PROCvalidate_ordinals(hr%,mi%,da%,mo%,yr%,error%)
 ptr%!alarm_hours%=hr%
 ptr%!alarm_minutes%=mi%
 ptr%!alarm_date%=da%
 ptr%!alarm_month%=mo%
 ptr%!alarm_year%=yr%
ENDPROC
:
DEFPROCvalidate_ordinals(RETURN hr%,RETURN mi%,RETURN dy%,RETURN mo%,RETURN yr%,RETURN error%)
 IFyr%>2247 yr%=2247:error%=TRUE:ENDPROC
 WHILE mo%<1 yr%-=1:mo%+=FNmonthsinyear(yr%):ENDWHILE
 WHILE mo%>FNmonthsinyear(yr%) mo%-=FNmonthsinyear(yr%):yr%+=1:ENDWHILE
 WHILE mi%<0 mi%+=60:hr%-=1:ENDWHILE
 WHILE mi%>59 mi%-=60:hr%+=1:ENDWHILE
 WHILE hr%<0 hr%+=24:dy%-=1:ENDWHILE
 WHILE hr%>23 hr%-=24:dy%+=1:ENDWHILE
 WHILE dy%<1 mo%-=1:dy%+=FNdaysinmonth(mo%,yr%):ENDWHILE
 WHILE dy%>FNdaysinmonth(mo%,yr%)
  dy%-=FNdaysinmonth(mo%,yr%)
  mo%+=1
  WHILEmo%>FNmonthsinyear(yr%) mo%-=FNmonthsinyear(yr%):yr%+=1:ENDWHILE
 ENDWHILE
 IF yr%<1901 yr%=1901
 IF yr%>2247 yr%=2247:error%=TRUE
ENDPROC
REM This source code in this file is licensed to You by Castle Technology
REM Limited ("Castle") and its licensors on contractual terms and conditions
REM ("Licence") which entitle you freely to modify and/or to distribute this
REM source code subject to Your compliance with the terms of the Licence.
REM
REM This source code has been made available to You without any warranties
REM whatsoever. Consequently, Your use, modification and distribution of this
REM source code is entirely at Your own risk and neither Castle, its licensors
REM nor any other person who has contributed to this source code shall be
REM liable to You for any loss or damage which You may suffer as a result of
REM Your use, modification or distribution of this source code.
REM
REM Full details of Your rights and obligations are set out in the Licence.
REM You should have received a copy of the Licence with this source code file.
REM If You have not received a copy, the text of the Licence is available
REM online at www.castle-technology.co.uk/riscosbaselicence.htm
REM
REM > Alarms

REM *************************************************************************
REM List management
REM *************************************************************************

DEFPROCremove_alarm_from_list(p%,give_error_while_saving%)
 REM
 REM Deletes the specified alarm record
 REM from the linked list
 REM
 LOCAL prev%,next%,c%,n1%,p1%,f%
 REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCremove_alarm_from_list(p%)")
 prev%=p%!alarm_prev%:p%!alarm_prev%=0
 next%=p%!alarm_next%:p%!alarm_next%=0
 REM IFFNcheck_pointer IFprev% PROCcheck_pointer(prev%,"PROCremove_alarm_from_list(prev)")
 REM IFFNcheck_pointer IFnext% PROCcheck_pointer(next%,"PROCremove_alarm_from_list(next)")
 IFalarm_head%=p% alarm_head%=next%
 IFnext% next%!alarm_prev%=prev%
 IFprev% prev%!alarm_next%=next%
 IFalarm_autosave% AND p%!alarm_fileptr%<>0 AND ra$<>"" THEN
  IFra$=FNmsg_0("FN2") THEN
   PROCwarning(FNmsg_0("File05"))
   ENDPROC
  ENDIF
  PROCsave_alarms_to_disc(ra$, FALSE, TRUE, give_error_while_saving%)
 ENDIF
ENDPROC
:
DEFPROCsave_alarm(ptr%)
 REM
 REM Links the specified record into
 REM the correct order of the linked list
 REM
 LOCAL C%,p%,q%,f%
 REM IFFNcheck_pointer PROCcheck_pointer(ptr%,"PROCsave_alarm")
 REM if the working week flag is set and it isn't a repeating
 REM alarm, turn the flag off
 IF ptr%?alarm_repeating%=0 THEN
  ptr%?alarm_fvdywk%=FALSE
 ENDIF
 IFalarm_head%=0 THEN
  REM simple case!
  alarm_head%=ptr%
  ptr%!alarm_next%=0
  ptr%!alarm_prev%=0
 ELSE
  REM slightly more difficult case!
  C%=alarm_head%
  p%=0
  WHILE C%
   REM IFFNcheck_pointer PROCcheck_pointer(C%,"PROCsave_alarm")
   REM do the comparisons separately (rather than
   REM IF less OR equal) to save time since
   REM if less, then can't be equal!
   f%=FNrec1_less_than_rec2(C%,ptr%)
   IFf%=FALSE f%=FNrec1_equal_rec2(C%,ptr%)
   IFf% THEN
    REM the alarm we are pointing to is before
    REM the one we want to insert
    p%=C%
    C%=C%!alarm_next%
   ELSE
    C%=0
   ENDIF
  ENDWHILE
  IF p%=0 THEN
   REM IFFNcheck_pointer PROCcheck_pointer(alarm_head%,"PROCsave_alarm(alarm_head%)")
   REM insert at the head of the list
   ptr%!alarm_next%=alarm_head%
   ptr%!alarm_prev%=0
   REM alarm_head% can't be zero ...
   alarm_head%!alarm_prev%=ptr%
   alarm_head%=ptr%
  ELSE
   REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCsave_alarm(p%)")
   REM insert into the chain
   REM p% is pointing to the record that should
   REM be BEFORE this one
   ptr%!alarm_prev%=p%
   ptr%!alarm_next%=p%!alarm_next%
   p%!alarm_next%=ptr%
   p%=ptr%!alarm_next%
   IFp% THEN
    REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCsave_alarm(p% 1)")
    p%!alarm_prev%=ptr%
   ENDIF
  ENDIF
 ENDIF
 PROCmodified_alarm_database
 IFalarm_autosave% AND ra$<>"" THEN
  IFra$=FNmsg_0("FN2") THEN
   PROCwarning(FNmsg_0("File05"))
  ELSE
   PROCsave_alarms_to_disc(ra$,FALSE,TRUE,TRUE)
  ENDIF
 ENDIF
ENDPROC
:
DEFPROCdelete_alarms
 LOCAL I%,H%,give_error_while_saving%
 give_error_while_saving%=TRUE
 I%=alarm_head%
 WHILE I%
  REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCdelete_alarms")
  IFI%?alarm_selected% THEN
   H%=I%!alarm_next%
   IFalarms%(1) THEN
    REM there is an active alarm - check it
    IFalarms%(1)=I% PROCtell_pinboard(m_wind%):!Q%=m_wind%:SYS"Wimp_CloseWindow",,Q%
   ENDIF
   PROCremove_alarm_from_list(I%,give_error_while_saving%)
   give_error_while_saving%=FALSE
   PROCheap_free("ALRM",I%)
   I%=H%
  ELSE
   I%=I%!alarm_next%
  ENDIF
 ENDWHILE
 alarm_warned%=FALSE
 PROCmodified_alarm_database
 PROCreset_alarm_status
ENDPROC
:
DEFPROCread_first_alarm(RETURN I%)
 REM
 REM Set the pointer I% to point
 REM to the first alarm
 REM
 LOCAL error%
 alarm_set%=FALSE
 user_alarm_set%=FALSE
 alarm_detected%=FALSE
 IFalarm_head% THEN
  I%=alarm_head%
  WHILE (I%<>0) AND (user_alarm_set%=FALSE)
   IFI%?alarm_applalarm%=FALSE user_alarm_set%=TRUE
   I%=I%!alarm_next%
  ENDWHILE
  I%=alarm_head%
  IFFNvalid_day_of_week(I%)=FALSE THEN
   REM the next alarm we are looking at doesn't fall
   REM onto a valid day of the week, so pull the
   REM date backwards until it does
   PROCcopy_alarm_to_validated(I%)
   REPEAT:I%!alarm_date%-=1:PROCvalidate_alarm_rec(I%,error%):UNTIL FNvalid_day_of_week(I%)
   PROCswap_alarm_and_validated(I%)
   REM so the originally set date and time is in alarm_*
   REM while the validated version is in valid_*
  ELSE
   REM ok - the day of the week is valid - just ensure
   REM that the valid version is up to date
   PROCcopy_alarm_to_validated(I%)
  ENDIF
  alarm_set%=TRUE
 ENDIF
ENDPROC
:
DEFPROCread_prev_alarm(RETURN I%)
 REM
 REM Point to the previous alarm
 REM
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCread_prev_alarm")
 REPEAT
  I%=I%!alarm_prev%
  IFI%=0 ENDPROC
 UNTIL I%?alarm_applalarm%=0
ENDPROC
:
DEFPROCread_next_alarm(RETURN I%)
 REM
 REM Point to the next alarm
 REM
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCread_next_alarm")
 REPEAT
  I%=I%!alarm_next%
  IFI%=0 ENDPROC
 UNTIL I%?alarm_applalarm%=0
ENDPROC

DEF PROCrec_fromwin(I%,H%)
 I%!alarm_year% =VAL(FNread_string(H%,2))
 I%!alarm_date% =VAL(FNread_string(H%,7))
 I%!alarm_hours% =VAL(FNread_string(H%,11))
 I%!alarm_minutes% =VAL(FNread_string(H%,14))
 IF I%!alarm_year% <1901 THEN I%!alarm_year% =1901
 IF I%!alarm_year% >2247 THEN I%!alarm_year% =2247
 
 IF I%!alarm_date% >31 THEN I%!alarm_date% =31
 IF I%!alarm_hours% >23 THEN I%!alarm_hours% =23
 IF I%!alarm_minutes% >59 THEN I%!alarm_minutes% =59
 PROCvalidate_alarm_rec(I%,error%)
ENDPROC
:
DEFPROCcopy_alarm_to_validated(I%)
 REM copy the alarm values into the validated values
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCcopy_alarm_to_validated")
 I%!valid_year%=I%!alarm_year%
 I%!valid_month%=I%!alarm_month%
 I%!valid_date%=I%!alarm_date%
 I%!valid_hours%=I%!alarm_hours%
 I%!valid_minutes%=I%!alarm_minutes%
ENDPROC
:
DEFPROCswap_alarm_and_validated(I%)
 REM swap the values over!
 SWAP I%!valid_year%, I%!alarm_year%
 SWAP I%!valid_month%, I%!alarm_month%
 SWAP I%!valid_date%, I%!alarm_date%
 SWAP I%!valid_hours%, I%!alarm_hours%
 SWAP I%!valid_minutes%, I%!alarm_minutes%
ENDPROC
:
DEFPROCcopy_validated_to_alarm(I%)
 REM copy the validated values into the alarm values
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCcopy_validated_to_alarm")
 I%!alarm_year%=I%!valid_year%
 I%!alarm_month%=I%!valid_month%
 I%!alarm_date%=I%!valid_date%
 I%!alarm_hours%=I%!valid_hours%
 I%!alarm_minutes%=I%!valid_minutes%
ENDPROC
:
DEFPROCcheck_alarm_window(P%,M%,H%,I%)
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCcheck_alarm_window")
 IF NOT(alarms%(0)?alarm_applalarm%) THEN
  CASE I% OF
  WHEN ic_alarm_urgent%: alarm_urgent%?alarms%(0)=NOT(alarm_urgent%?alarms%(0))
  WHEN ic_alarm_adj_yu%,ic_alarm_adj_yd%,ic_alarm_adj_mu%,ic_alarm_adj_md%,ic_alarm_adj_du%,ic_alarm_adj_dd%,ic_alarm_adj_hu%,ic_alarm_adj_hd%,ic_alarm_adj_minu%,ic_alarm_adj_mind%
                                  PROCrec_fromwin(alarms%(0),H%)
                                  CASE I% OF
                                   WHEN   ic_alarm_adj_dd%: PROCchange_date(alarms%(0),M%,H%)
                                   WHEN   ic_alarm_adj_du%: PROCchange_date(alarms%(0),P%,H%)
                                   WHEN   ic_alarm_adj_md%: PROCchange_month(alarms%(0),M%,H%)
                                   WHEN   ic_alarm_adj_mu%: PROCchange_month(alarms%(0),P%,H%)
                                   WHEN   ic_alarm_adj_yd%: PROCchange_year(alarms%(0),M%,H%)
                                   WHEN   ic_alarm_adj_yu%: PROCchange_year(alarms%(0),P%,H%)
                                   WHEN   ic_alarm_adj_hd%: PROCchange_hour(alarms%(0),M%,H%)
                                   WHEN   ic_alarm_adj_hu%: PROCchange_hour(alarms%(0),P%,H%)
                                   WHEN ic_alarm_adj_mind%: PROCchange_min(alarms%(0),M%,H%)
                                   WHEN ic_alarm_adj_minu%: PROCchange_min(alarms%(0),P%,H%)
                                  ENDCASE
  WHEN          ic_alarm_repeat%: IFalarm_repeating%?alarms%(0) THEN
                                   alarm_repeating%?alarms%(0)=0
                                   alarm_repeat_rate%?alarms%(0)=1
                                   alarm_repeat_mult%?alarms%(0)=1
                                   PROCtoggle_alarm_size(FALSE)
                                  ELSE
                                   IFFNicon_set(a_wind%,ic_alarm_onthe%) THEN
                                    alarm_repeating%?alarms%(0)=2
                                   ELSE
                                    alarm_repeating%?alarms%(0)=1
                                   ENDIF
                                   PROCtoggle_alarm_size(TRUE)
                                  ENDIF
                                  PROCset_repeat_flags(TRUE,alarms%(0))
  WHEN            ic_alarm_task%: alarm_taskalarm%?alarms%(0)=NOT(alarm_taskalarm%?alarms%(0))
                                  IFalarm_taskalarm%?alarms%(0) THEN
                                   PROCsetstate(a_wind%,ic_alarm_urgent%,1<<22,1<<22)
                                  ELSE
                                   PROCsetstate(a_wind%,ic_alarm_urgent%,0,1<<22)
                                  ENDIF
  WHEN      ic_alarm_every_mins%: alarm_repeat_rate%?alarms%(0)=1:PROCset(I%)
  WHEN     ic_alarm_every_hours%: alarm_repeat_rate%?alarms%(0)=2:PROCset(I%)
  WHEN      ic_alarm_every_days%: alarm_repeat_rate%?alarms%(0)=4:PROCset(I%)
  WHEN     ic_alarm_every_weeks%: alarm_repeat_rate%?alarms%(0)=8:PROCset(I%)
  WHEN    ic_alarm_every_months%: alarm_repeat_rate%?alarms%(0)=16:PROCset(I%)
  WHEN     ic_alarm_every_years%: alarm_repeat_rate%?alarms%(0)=32:PROCset(I%)
  WHEN        ic_alarm_adj_repd%: PROCchange_mult(M%)
  WHEN        ic_alarm_adj_repu%: PROCchange_mult(P%)
  WHEN ic_alarm_adj_onthe_drepd%: PROCchange_special_offset(M%)
  WHEN ic_alarm_adj_onthe_drepu%: PROCchange_special_offset(P%)
  WHEN    ic_alarm_adj_onthe_dd%: PROCchange_special_day(M%)
  WHEN    ic_alarm_adj_onthe_du%: PROCchange_special_day(P%)
  WHEN ic_alarm_adj_onthe_mrepd%: PROCchange_special_month(M%)
  WHEN ic_alarm_adj_onthe_mrepu%: PROCchange_special_month(P%)
  WHEN           ic_alarm_wweek%: alarm_fvdywk%?alarms%(0)=NOT(alarm_fvdywk%?alarms%(0))
                                  IFalarm_fvdywk%?alarms%(0) PROCcheck_special_day(alarms%(0))
  WHEN           ic_alarm_every%: IFalarm_repeating%?alarms%(0)<>1 THEN
                                   alarm_repeating%?alarms%(0)=1
                                   alarm_repeat_rate%?alarms%(0)=1
                                   alarm_repeat_mult%?alarms%(0)=1
                                   PROCset_repeat_flags(TRUE,alarms%(0))
                                  ENDIF
                                  PROCset(I%)
  WHEN           ic_alarm_onthe%: IFalarm_repeating%?alarms%(0)<>2 THEN
                                   alarm_repeating%?alarms%(0)=2
                                   alarm_repeat_rate%?alarms%(0)=1
                                   alarm_repeat_mult%?alarms%(0)=1
                                   PROCset_repeat_flags(TRUE,alarms%(0))
                                  ENDIF
                                  PROCset(I%)
  WHEN ic_alarm_ok_lo%,ic_alarm_ok_hi%:
                                  PROCrec_fromwin(alarms%(0),H%):PROCok_current_action
  WHEN ic_alarm_cancel_lo%,ic_alarm_cancel_hi%:
                                  cancel%=TRUE:PROCclosewindow(a_wind%)
  ENDCASE
 ENDIF
ENDPROC
:
DEFPROCstore_alarm_strings(I%)
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCstore_alarm_strings")
 $(I%+alarm_line1%)=FNread_string(a_wind%,mess1%)
 $(I%+alarm_line2%)=FNread_string(a_wind%,mess2%)
 $(I%+alarm_line3%)=FNread_string(a_wind%,mess3%)
ENDPROC
:
DEFPROCcopyalarm(from%,to%)
 LOCAL i%
 REM IFFNcheck_pointer PROCcheck_pointer(from%,"PROCcopyalarm (from)")
 REM IFFNcheck_pointer PROCcheck_pointer(to%,"PROCcopyalarm (to)")
 FORi%=0 TO alarm_SIZE%-1
  to%?i%=from%?i%
 NEXT
 to%!alarm_fileptr%=0
ENDPROC

REM *************************************************************************
REM Application/task alarms
REM *************************************************************************

DEFPROCprocess_appl_alarm(A%)
 CASE Q%!20 OF
 WHEN 0,1:PROCset_appl_alarm
 WHEN 2:PROCcancel_appl_alarm
 OTHERWISE: PROCack_appl_alarm(1,FNmsg_0("ApplA1"))
 ENDCASE
 PROCreset_alarm_status
ENDPROC
:
DEFPROCack_appl_alarm(E%,e$)
 LOCAL C%
 IF A%<>18 ENDPROC
 C%=LEN(e$)+1
 Q%!12=Q%!8
 Q%!20=E%
 $(Q%+24)=e$+CHR$(0)
 !Q%=(24+C%) AND NOT3
 SYS"Wimp_SendMessage",17,Q%,Q%!4
ENDPROC
:
DEFPROCset_appl_alarm
 LOCAL year%,month%,dayofmonth%,hour%,minute%,I%,J%,ptr%
 ptr%=FNheap_claim("ALRM",alarm_SIZE%)
 IFptr%=0 PROCout_of_memory
 IF Q%!20=1 THEN
  |buffers%=|(Q%+24)
  PROCfivebt_to_ordinals(buffers%,hour%,minute%,dayofmonth%,month%,year%)
 ELSE
  year%=Q%!24 AND &FFFF
  month%=Q%?26
  dayofmonth%=Q%?27
  hour%=Q%?28
  minute%=Q%?29
 ENDIF
 ptr%!alarm_hours%=hour%
 ptr%!alarm_minutes%=minute%:REM bug fix to allow application alarms to work
 ptr%!alarm_date%=dayofmonth%
 ptr%!alarm_month%=month%
 ptr%!alarm_year%=year%
 I%=30
 WHILE Q%?I% I%+=1:ENDWHILE
 Q%?I%=13:$(ptr%+alarm_line1%)=$(Q%+30)
 IF LEN($(ptr%+alarm_line1%))>40 THEN
  PROCheap_free("ALRM",ptr%)
  PROCack_appl_alarm(2,FNmsg_0("ApplA2"))
  ENDPROC
 ENDIF
 I%+=1:J%=I%
 WHILE Q%?I% I%+=1:ENDWHILE
 Q%?I%=13:$(ptr%+alarm_line2%)=$(Q%+J%)
 IF LEN($(ptr%+alarm_line2%))>40 THEN
  PROCheap_free("ALRM",ptr%)
  PROCack_appl_alarm(3,FNmsg_0("ApplA3"))
  ENDPROC
 ENDIF
 $(ptr%+alarm_line3%)=""
 ptr%?alarm_repeating%=0
 ptr%?alarm_applalarm%=TRUE
 ptr%?alarm_taskalarm%=FALSE
 ptr%?alarm_fvdywk%=FALSE
 ptr%?alarm_urgent%=FALSE
 PROCsave_alarm(ptr%)
 alarm_warned%=FALSE
 PROCack_appl_alarm(0,"")
ENDPROC
:
DEFPROCbroadcast_appl_alarm
 LOCAL I%
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCbroadcast_appl_alarm(1)")
 Q%!12=0
 Q%!16=&501
 $(Q%+20)=$(alarms%(1)+alarm_line1%)+CHR$(0)
 I%=21+LEN($(alarms%(1)+alarm_line1%))
 $(Q%+I%)=$(alarms%(1)+alarm_line2%)+CHR$(0)
 I%+=LEN($(alarms%(1)+alarm_line2%))+1
 !Q%=(I%+4) AND NOT3
 SYS"Wimp_SendMessage",18,Q%,0
ENDPROC
;
DEFFNexecute_task_alarm(e$)
 LOCAL ERROR
 ON ERROR LOCAL :=FALSE
 OSCLI("Filer_Run "+e$)
=TRUE
:
DEFPROCactivate_task_alarm
 LOCAL e$,e%,error%
 REM IFFNcheck_pointer IF current_action%<>-1 PROCcheck_pointer(alarms%(0),"PROCactivate_task_alarm(0)")
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCactivate_task_alarm(1)")
 e$=$(alarms%(1)+alarm_line1%)+$(alarms%(1)+alarm_line2%)+$(alarms%(1)+alarm_line3%)
 IF (alarms%(0)=alarms%(1)) AND current_action%<>setting% THEN
  !Q%=a_wind%
  SYS"Wimp_CloseWindow",,Q%
  PROCcancel_current_action
 ENDIF
 IF alarm_repeating%?alarms%(1) THEN
  PROCremove_alarm_from_list(alarms%(1),FALSE)
  PROCsave_repeating_alarm(alarms%(1),alarm_repeat_rate%?alarms%(1),alarm_repeat_mult%?alarms%(1),error%)
 ELSE
  PROCremove_alarm_from_list(alarms%(1),TRUE)
  PROCheap_free("ALRM",alarms%(1))
  alarms%(1)=0
  PROCmodified_alarm_database
 ENDIF
 alarm_warned%=FALSE
 PROCreset_alarm_status
 e%=FNexecute_task_alarm(e$)
 IF NOTe% SYS"Wimp_StartTask",e$
 IFerror% PROCok(FNmsg_0("OkayC6"))
ENDPROC
:
DEFPROCset_task_alarm_string
 LOCAL v$
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCset_task_alarm_string(0)")
 v$=FNrtoz(Q%+44)
 $(alarms%(0)+alarm_line1%)=LEFT$(v$,40):v$=MID$(v$,41)
 $(alarms%(0)+alarm_line2%)=LEFT$(v$,40):v$=MID$(v$,41)
 $(alarms%(0)+alarm_line3%)=LEFT$(v$,40)
 PROCset_string(a_wind%,16,$(alarms%(0)+alarm_line1%))
 PROCset_string(a_wind%,17,$(alarms%(0)+alarm_line2%))
 PROCset_string(a_wind%,18,$(alarms%(0)+alarm_line3%))
 SYS"Wimp_SetCaretPosition",a_wind%,mess1%,-1,-1,-1,LEN($(alarms%(0)+alarm_line1%))
 PROCset(29):alarm_taskalarm%?alarms%(0)=TRUE
 PROCsetstate(a_wind%,5,1<<22,1<<22)
ENDPROC
:
DEFPROCcancel_appl_alarm
 REM
 REM Attempt to cancel the specified application
 REM alarm from the linked list
 REM
 LOCAL I%,J%,name$,ident$,E%,res%
 I%=24
 WHILE Q%?I% I%+=1:ENDWHILE
 Q%?I%=13:name$=$(Q%+24)
 IF LEN(name$)>40 PROCack_appl_alarm(2,FNmsg_0("ApplA2")):ENDPROC
 I%+=1:J%=I%
 WHILE Q%?I% I%+=1:ENDWHILE
 Q%?I%=13:ident$=$(Q%+J%)
 IF LEN(ident$)>40 PROCack_appl_alarm(3,FNmsg_0("ApplA3")):ENDPROC
 J%=0
 E%=alarm_head%
 res%=-1
 WHILE E%
  REM IFFNcheck_pointer PROCcheck_pointer(E%,"PROCcancel_appl_alarm")
  IF name$=$(E%+alarm_line1%) AND ident$=$(E%+alarm_line2%) AND E%?alarm_applalarm% THEN
   res%=E%
   E%=0
  ELSE
   E%=E%!alarm_next%
  ENDIF
 ENDWHILE
 IFres%=-1 THEN
  PROCack_appl_alarm(4,FNmsg_0("ApplA4"))
 ELSE
  PROCremove_alarm_from_list(res%,TRUE)
  alarm_warned%=FALSE
  PROCheap_free("ALRM",res%)
  PROCmodified_alarm_database
  PROCreset_alarm_status
  PROCack_appl_alarm(0,"")
 ENDIF
ENDPROC

REM *************************************************************************
REM Alarm record manipulation
REM *************************************************************************

DEFFNrec1_less_than_rec2(rec1%,rec2%)
 IFrec1%!alarm_year%    > rec2%!alarm_year%    :=FALSE
 IFrec1%!alarm_year%    < rec2%!alarm_year%    :=TRUE
 IFrec1%!alarm_month%   > rec2%!alarm_month%   :=FALSE
 IFrec1%!alarm_month%   < rec2%!alarm_month%   :=TRUE
 IFrec1%!alarm_date%    > rec2%!alarm_date%    :=FALSE
 IFrec1%!alarm_date%    < rec2%!alarm_date%    :=TRUE
 IFrec1%!alarm_hours%   > rec2%!alarm_hours%   :=FALSE
 IFrec1%!alarm_hours%   < rec2%!alarm_hours%   :=TRUE
 IFrec1%!alarm_minutes% < rec2%!alarm_minutes% :=TRUE
=FALSE
:
DEFFNrec1_equal_rec2(rec1%,rec2%)
 IFrec1%!alarm_year%    <> rec2%!alarm_year%    :=FALSE
 IFrec1%!alarm_month%   <> rec2%!alarm_month%   :=FALSE
 IFrec1%!alarm_date%    <> rec2%!alarm_date%    :=FALSE
 IFrec1%!alarm_hours%   <> rec2%!alarm_hours%   :=FALSE
 IFrec1%!alarm_minutes% <> rec2%!alarm_minutes% :=FALSE
=TRUE
:
DEFPROCfind_alarm
 LOCAL i%,last%
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(2),"PROCfind_alarm(2)")
 PROCread_first_alarm(i%)
 REM IFFNcheck_pointer PROCcheck_pointer(i%,"PROCfind_alarm(i%)")
 WHILE FNrec1_less_than_rec2(i%,alarms%(2))
  last%=i%
  PROCread_next_alarm(i%)
  REM if we've run out of alarms, go back to the last one
  REM and write over the find match so we can get out
  REM of the loop
  IFi%=0 i%=last%:PROCcopyalarm(i%,alarms%(2))
 ENDWHILE
 PROCichang(i%)
ENDPROC
:
DEFPROCincrement_alarm(I%,R%,S%,RETURN error%)
 LOCAL J%,day%
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCincrement_alarm")
 
 day%=FNday_of_week(I%)
 
 IF R% AND 1 THEN
  IF I%?alarm_fvdywk% THEN
   REM number of minutes in a day = 1440
   WHILE S%>=1440
    I%!alarm_date%+=1
    S%-=1440
    REPEAT
     day%=(day% + 1) MOD 7
     IF(global_weekwork% AND (1<<day%))=0 I%!alarm_date%+=1:S%-=1440
    UNTIL (global_weekwork% AND (1<<day%))<>0
   ENDWHILE
  ENDIF
  I%!alarm_minutes%+=S%
 ENDIF
 
 IF R% AND 2 THEN
  IF I%?alarm_fvdywk% THEN
   REM number of hours in a day = 24
   WHILE S%>=24
    I%!alarm_date%+=1
    S%-=24
    REPEAT
     day%=(day% + 1) MOD 7
     IF(global_weekwork% AND (1<<day%))=0 I%!alarm_date%+=1:S%-=24
    UNTIL (global_weekwork% AND (1<<day%))<>0
   ENDWHILE
  ENDIF
  I%!alarm_hours%+=S%
 ENDIF
 
 IF R% AND 4 THEN
  IF I%?alarm_fvdywk% THEN
   FOR J%=1 TO S%
    I%!alarm_date%+=1
    REPEAT
     day%=(day% + 1) MOD 7
     IF(global_weekwork% AND (1<<day%))=0 I%!alarm_date%+=1:J%+=1
    UNTIL (global_weekwork% AND (1<<day%))<>0
   NEXT
  ELSE
   I%!alarm_date%+=S%
  ENDIF
 ENDIF
 
 IF R% AND 8  I%!alarm_date%+=S%*7
 IF R% AND 16 I%!alarm_month%+=S%
 IF R% AND 32 I%!alarm_year%+=S%
 
 PROCvalidate_alarm_rec(I%,error%)
 IF I%?alarm_fvdywk% THEN
  WHILE NOTerror% AND NOTFNvalid_day_of_week(I%)
   I%!alarm_date%+=1
   PROCvalidate_alarm_rec(I%,error%)
  ENDWHILE
 ENDIF
ENDPROC
:
DEFPROCincrement_special_alarm(I%,R%,S%,RETURN error%)
 LOCAL J%
 LOCAL day%            :REM day that alarm is required to go off on
 LOCAL offset%         :REM offset into month that alarm is required
 LOCAL required_date%  :REM calculated date for this month
 LOCAL hours%, minutes%, dayofmonth%, month%, year%
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCincrement_special_alarm")
 
 REM extract values from alarm settings
 day%=R% AND 7
 offset%=R% DIV 8
 
 REM ensure that alarm is started from tomorrow
 hours%=I%!alarm_hours%
 minutes%=I%!alarm_minutes%
 dayofmonth%=I%!alarm_date%+1
 month%=I%!alarm_month%
 year%=I%!alarm_year%
 
 REM calculate required date for THIS month
 required_date%=FNcalculate_special_date_required(I%,day%,offset%,error%)
 IFerror% ENDPROC
 
 REM if we are past that date, we must be repeating properly
 REM so add on the required number of months and try again
 IFrequired_date%<dayofmonth% THEN
  month%+=S%
  year%=I%!alarm_year%
  WHILE month%>FNmonthsinyear(year%) month%-=FNmonthsinyear(year%):year%+=1:ENDWHILE
  required_date%=FNcalculate_special_date_required(I%,day%,offset%,error%)
  IFerror% ENDPROC
 ENDIF
 
 I%!alarm_date%=required_date%
 I%!alarm_month%=month%
 I%!alarm_year%=year%
 PROCvalidate_alarm_rec(I%,error%)
ENDPROC
:
DEFPROCread_date_and_time(I%)
 LOCAL hr%,mi%,da%,mo%,yr%
 REM get the current date and time and store it
 REM in the specified alarm record as local ordinals
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCread_date_and_time")
 PROCfivebt_to_ordinals(cur_clock%,hr%,mi%,da%,mo%,yr%)
 I%!alarm_year%=yr%
 I%!alarm_month%=mo%
 I%!alarm_date%=da%
 I%!alarm_hours%=hr%
 I%!alarm_minutes%=mi%
ENDPROC
:
DEFFNread_repeat_day(I%)
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNread_repeat_day")
=(I%?alarm_repeat_rate% AND 7)
:
DEFFNread_repeat_offset(I%)
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNread_repeat_offset")
=(I%?alarm_repeat_rate% DIV 8)
:
DEFPROCwrite_repeat_day(I%,V%)
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCwrite_repeat_day")
 I%?alarm_repeat_rate%=(FNread_repeat_offset(I%) << 3) + V%
ENDPROC
:
DEFPROCwrite_repeat_offset(I%,V%)
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCwrite_repeat_offset")
 I%?alarm_repeat_rate%=(V% << 3) + FNread_repeat_day(I%)
ENDPROC
:
DEFPROCsave_record(c%,p%,next%,prev%)
 LOCAL b%,p1%
 REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCsave_record")
 p1%=PTR#c%
 p%!alarm_fileptr%=p1%
 PRINT#c%,100
 PRINT#c%,next%
 PRINT#c%,prev%
 b%=p%!alarm_year%
 BPUT#c%,(b% >> 8) AND 255
 BPUT#c%,(b% AND 255)
 BPUT#c%,p%?alarm_month%
 BPUT#c%,p%?alarm_date%
 BPUT#c%,p%?alarm_hours%
 BPUT#c%,p%?alarm_minutes%
 BPUT#c%,p%?alarm_urgent%
 PRINT#c%,$(p%+alarm_line1%)
 PRINT#c%,$(p%+alarm_line2%)
 PRINT#c%,$(p%+alarm_line3%)
 PTR#c%=p1%+148
 b%=0
 IF p%?alarm_applalarm%   b%+=1
 IF p%?alarm_repeating%=1 b%+=2
 IF p%?alarm_taskalarm%   b%+=4
 IF p%?alarm_fvdywk%      b%+=8
 IF p%?alarm_repeating%=2 b%+=16
 BPUT#c%,b%
 BPUT#c%,p%?alarm_repeat_rate%
 BPUT#c%,p%?alarm_repeat_mult%
ENDPROC
:
DEFFNcalculate_special_date_required(I%,day%,offset%,RETURN error%)
 LOCAL required_date%  :REM calculated date for this month
 LOCAL first_day_month%:REM first day for this month
 LOCAL last_day_month% :REM last day for this month
 LOCAL yr%,mn%,dy%
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNcalculate_special_date_required")
 
 yr%=year%:mn%=month%:dy%=1
 
 PROCvalidate_ordinals(hours%,minutes%,dy%,mn%,yr%,error%)
 IFerror% ENDPROC
 PROCordinals_to_fivebt(buffers%,hours%,minutes%,dy%,mn%,yr%)
 first_day_month%=VAL(FNconverttime(buffers%,"%WN"))
 
 mn%+=1
 PROCvalidate_ordinals(hours%,minutes%,dy%,mn%,yr%,error%)
 IFerror% ENDPROC
 PROCordinals_to_fivebt(buffers%,hours%,minutes%,dy%,mn%,yr%)
 last_day_month%=VAL(FNconverttime(buffers%,"%WN"))-1
 IFlast_day_month%=0 last_day_month%=7
 
 CASE offset% OF
 WHEN 0:REM first occurence in month
        required_date%=1
        IFday%<first_day_month% required_date%+=(7-first_day_month%)+day%
        IFday%>first_day_month% required_date%+=(day%-first_day_month%)
 WHEN 1:REM second occurence in month
        required_date%=8
        IFday%<first_day_month% required_date%+=(7-first_day_month%)+day%
        IFday%>first_day_month% required_date%+=(day%-first_day_month%)
 WHEN 2:REM third occurence in month
        required_date%=15
        IFday%<first_day_month% required_date%+=(7-first_day_month%)+day%
        IFday%>first_day_month% required_date%+=(day%-first_day_month%)
 WHEN 3:REM last occurence in month
        required_date%=FNdaysinmonth(month%,year%)
        IFday%>last_day_month% required_date%-=7
        required_date%-=(last_day_month%-day%)
 WHEN 4:REM penultimate occurence in month
        required_date%=FNdaysinmonth(month%,year%)-7
        IFday%>last_day_month% required_date%-=7
        required_date%-=(last_day_month%-day%)
 WHEN 5:REM third to last occurence in month
        required_date%=FNdaysinmonth(month%,year%)-14
        IFday%>last_day_month% required_date%-=7
        required_date%-=(last_day_month%-day%)
 ENDCASE
=required_date%
:
DEFPROCcheck_special_day(Z%)
 LOCAL J%,dir%
 REM IFFNcheck_pointer PROCcheck_pointer(Z%,"PROCcheck_special_day")
 IFZ%?alarm_repeating%<>2 ENDPROC
 J%=FNread_repeat_day(Z%)
 dir%=1
 WHILE NOT(FNvalid_day(J%))
  J%+=dir%
  IFJ%=8 THEN
   J%=FNread_repeat_day(Z%)
   dir%=-1
  ENDIF
 ENDWHILE
 PROCwrite_repeat_day(Z%,J%)
 PROCset_string(a_wind%,38,FNmsg_0("WE"+STR$(J%)+"a"+STR$(FNread_repeat_offset(Z%))))
 PROCset_string(a_wind%,35,FNmsg_0("SR"+STR$(FNread_repeat_offset(Z%))+"w"+STR$(J%)))
ENDPROC
:
DEFPROCchange_special_offset(V%)
 LOCAL D%
 D%=FNread_repeat_offset(alarms%(0))
 D%+=V%
 IF D%>-1 AND D%<6 THEN
  PROCwrite_repeat_offset(alarms%(0),D%)
  PROCset_string(a_wind%,35,FNmsg_0("SR"+STR$(D%)+"w"+STR$(FNread_repeat_day(alarms%(0)))))
  PROCset_string(a_wind%,38,FNmsg_0("WE"+STR$(FNread_repeat_day(alarms%(0)))+"a"+STR$(D%)))
 ENDIF
ENDPROC
:
DEFPROCchange_special_day(V%)
 LOCAL D%
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCchange_special_day(0)")
 D%=FNread_repeat_day(alarms%(0))
 D%+=V%
 IFalarm_fvdywk%?alarms%(0) THEN
  WHILE NOT(FNvalid_day(D%))
   D%+=V%
   IFD%<0 OR D%>7 D%=FNread_repeat_day(alarms%(0))
  ENDWHILE
 ENDIF
 IF D%>0 AND D%<8 THEN
  PROCwrite_repeat_day(alarms%(0),D%)
  PROCset_string(a_wind%,38,FNmsg_0("WE"+STR$(D%)+"a"+STR$(FNread_repeat_offset(alarms%(0)))))
  PROCset_string(a_wind%,35,FNmsg_0("SR"+STR$(FNread_repeat_offset(alarms%(0)))+"w"+STR$(D%)))
 ENDIF
ENDPROC
:
DEFPROCchange_special_month(V%)
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCchange_special_month(0)")
 V%+=alarm_repeat_mult%?alarms%(0)
 IF V%>0 AND V%<13 THEN
  alarm_repeat_mult%?alarms%(0)=V%
  PROCset_string(a_wind%,41,FNmsg_0("MR"+STR$(V%)))
 ENDIF
ENDPROC
:
DEFPROCchange_mult(V%)
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCchange_mult(0)")
 V%+=alarm_repeat_mult%?alarms%(0)
 IF V%>0 AND V%<256 THEN
  alarm_repeat_mult%?alarms%(0)=V%
  PROCset_string(a_wind%,27,STR$(V%))
 ENDIF
ENDPROC

REM *************************************************************************
REM Alarm input/output
REM *************************************************************************

DEFPROCmodified_alarm_database
 IFautosaved% THEN
  autosaved%=FALSE
 ELSE
  modified%=TRUE
 ENDIF
 PROCadjust_browser_size
 !Q%=browser%:SYS"Wimp_GetWindowState",,Q%
 IF(Q%!32 AND (1<<16)) PROCopen_browser
ENDPROC
:
DEFPROCprint_the_alarms_out(f$,selection%)
 REM
 REM Print out the details of all of the
 REM alarms to the file f$
 REM
 LOCAL C%,B%,Z$,Y$,Y1$,Y2$,doit%
 C%=OPENOUT(f$)
 B%=alarm_head%
 WHILE B%
  REM IFFNcheck_pointer PROCcheck_pointer(B%,"PROCprint_the_alarms_out")
  IFselection% THEN
   IFB%?alarm_selected% doit%=TRUE ELSE doit%=FALSE
  ELSE
   doit%=TRUE
  ENDIF
  IF doit% THEN
   PROCalarm_rec_to_fivebt(B%,buffers%)
   Y$=FNconverttime(buffers%,FNmsg_0("PrntA7"))
   IF Y$<>Z$ THEN
    REM ensure that we only print the date ONCE
    IF Z$<>"" THEN
     REM separate dates with a blank line
     BPUT#C%,""
    ENDIF
    BPUT#C%,Y$
    Z$=Y$
   ENDIF
   Y$=FNconverttime(buffers%,FNmsg_0("PrntA6"))
   BPUT#C%,Y$+STRING$(12-LENY$," ");
   IF B%?alarm_applalarm% THEN
    BPUT#C%,FNmsg_1("PrntA1", $(B%+alarm_line1%))
   ELSE
    IF B%?alarm_taskalarm% THEN
     BPUT#C%,FNmsg_0("PrntA2")
     BPUT#C%,STRING$(12," ")+$(B%+alarm_line1%)+$(B%+alarm_line2%)+$(B%+alarm_line3%)
    ELSE
     IF LEN($(B%+alarm_line1%))+LEN($(B%+alarm_line2%))+LEN($(B%+alarm_line3%))=0 THEN
      BPUT#C%,FNmsg_0("PrntB7")
     ELSE
      IF $(B%+alarm_line1%)<>"" BPUT#C%,$(B%+alarm_line1%)
      IF $(B%+alarm_line2%)<>"" BPUT#C%,STRING$(12," ")+$(B%+alarm_line2%)
      IF $(B%+alarm_line3%)<>"" BPUT#C%,STRING$(12," ")+$(B%+alarm_line3%)
     ENDIF
     IF B%?alarm_urgent% BPUT#C%,STRING$(12," ")+FNmsg_0("PrntA3")
    ENDIF
    CASE B%?alarm_repeating% OF
    WHEN 0:IF B%?alarm_fvdywk% BPUT#C%,STRING$(12," ")+FNmsg_0("PrntB8")
    WHEN 1:CASE B%?alarm_repeat_rate% OF
           WHEN 1: Y$=FNmsg_0("PrntB1")
           WHEN 2: Y$=FNmsg_0("PrntB2")
           WHEN 4: Y$=FNmsg_0("PrntB3")
           WHEN 8: Y$=FNmsg_0("PrntB4")
           WHEN 16:Y$=FNmsg_0("PrntB5")
           WHEN 32:Y$=FNmsg_0("PrntB6")
           ENDCASE
           IF B%?alarm_fvdywk% THEN
            BPUT#C%,STRING$(12," ")+FNmsg_2("PrntA4", STR$(B%?alarm_repeat_mult%), Y$)
           ELSE
            BPUT#C%,STRING$(12," ")+FNmsg_2("PrntA5", STR$(B%?alarm_repeat_mult%), Y$)
           ENDIF
    WHEN 2:Y$=FNmsg_0("SR"+STR$(FNread_repeat_offset(B%))+"w"+STR$(FNread_repeat_day(B%)))
           Y1$=FNmsg_0("WE"+STR$(FNread_repeat_day(B%))+"a"+STR$(FNread_repeat_offset(B%)))
           Y2$=FNmsg_0("MR"+STR$(B%?alarm_repeat_mult%))
           BPUT#C%,STRING$(12," ")+FNmsg_3("PrntB9", Y$, Y1$, Y2$)
           IFB%?alarm_fvdywk% BPUT#C%,STRING$(12," ")+FNmsg_0("PrntB8")
    ENDCASE
   ENDIF
  ENDIF
  B%=B%!alarm_next%
 ENDWHILE
 CLOSE#C%
 SYS"OS_File",18,f$,&FFF
ENDPROC
:
DEFPROCload_alarms_into_memory(f$)
 REM
 REM Load all of the alarms from the file
 REM into a linked list of records
 REM
 LOCAL c%,ptr%,this_rec%,B%,m%,old_autosave%,p%,matched%,this_autosave%,null%
 IFf$="" THEN
  REM to catch stupid situations
  PROCreset_alarm_status
  REM IFra$=def_fn$ OR ra$="" ra$=FNmsg_0("FN2")
  IF ra$="" ra$=FNmsg_0("FN2")
 ELSE
  old_autosave%=alarm_autosave%
  this_autosave%=alarm_autosave%
  IFalarm_head%=0 THEN
   this_autosave%=TRUE
   REM if no alarms loaded yet, and we're using the default file,
   REM revert to the old default name so that lower down, we replace
   REM it with the NEW default name
   REM IFra$=def_fn$ ra$=FNmsg_0("FN2")
  ENDIF
  alarm_autosave%=FALSE
  m%=modified%
  c%=FNopen(f$,&40)
  IFc%>0 THEN
   SYS"OS_Args",254,c% TO B%
   IF(B% AND 1<<6)=0 THEN
    CLOSE#c%
    c%=0
   ENDIF
  ENDIF
  IFc%>0 THEN
   IFBGET#c%=&41 AND BGET#c%=&4C AND BGET#c%=&52 AND BGET#c%=&4D THEN
    SYS"Hourglass_On"
    REPEAT
     INPUT#c%,ptr%
     IFptr%<>-1 THEN
      this_rec%=FNheap_claim("ALRM",alarm_SIZE%)
      IFthis_rec%=0 CLOSE#c%:PROCout_of_memory
      PTR#c%=ptr%
      INPUT#c%,B%
      IFB%=100 THEN
       PTR#c%=ptr%+15
       this_rec%!alarm_next%=0
       this_rec%!alarm_prev%=0
       this_rec%!alarm_fileptr%=ptr%
       B%=BGET#c%*256+BGET#c%
       this_rec%!alarm_year%=B%
       this_rec%!alarm_month%=BGET#c%
       this_rec%!alarm_date%=BGET#c%
       this_rec%!alarm_hours%=BGET#c%
       this_rec%!alarm_minutes%=BGET#c%
       this_rec%?alarm_urgent%=BGET#c%
       INPUT#c%,$(this_rec%+alarm_line1%)
       INPUT#c%,$(this_rec%+alarm_line2%)
       INPUT#c%,$(this_rec%+alarm_line3%)
       PTR#c%=ptr%+148
       B%=BGET#c%
       this_rec%?alarm_applalarm%=((B% AND 1)=1)
       this_rec%?alarm_repeating%=0
       IF(B% AND 2)=2   this_rec%?alarm_repeating%=1
       IF(B% AND 16)=16 this_rec%?alarm_repeating%=2
       this_rec%?alarm_taskalarm%=((B% AND 4)=4)
       this_rec%?alarm_fvdywk%=((B% AND 8)=8)
       this_rec%?alarm_repeat_rate%=BGET#c%
       this_rec%?alarm_repeat_mult%=BGET#c%
       this_rec%?alarm_selected%=0
       IFthis_rec%?alarm_applalarm% THEN
        REM check for duplicates of application alarms
        p%=alarm_head%
        WHILE p%
         IF p%?alarm_applalarm% THEN
          matched%=TRUE
          IFthis_rec%!alarm_year%<>p%!alarm_year% matched%=FALSE
          IFthis_rec%!alarm_month%<>p%!alarm_month% matched%=FALSE
          IFthis_rec%!alarm_date%<>p%!alarm_date% matched%=FALSE
          IFthis_rec%!alarm_hours%<>p%!alarm_hours% matched%=FALSE
          IFthis_rec%!alarm_minutes%<>p%!alarm_minutes% matched%=FALSE
          IFthis_rec%?alarm_urgent%<>p%?alarm_urgent% matched%=FALSE
          IF$(this_rec%+alarm_line1%)<>$(p%+alarm_line1%) matched%=FALSE
          IF$(this_rec%+alarm_line2%)<>$(p%+alarm_line2%) matched%=FALSE
          IF$(this_rec%+alarm_line3%)<>$(p%+alarm_line3%) matched%=FALSE
          IFthis_rec%?alarm_repeating%<>p%?alarm_repeating% matched%=FALSE
          IFthis_rec%?alarm_taskalarm%<>p%?alarm_taskalarm% matched%=FALSE
          IFthis_rec%?alarm_fvdywk%<>p%?alarm_fvdywk% matched%=FALSE
          IFthis_rec%?alarm_repeat_rate%<>p%?alarm_repeat_rate% matched%=FALSE
          IFthis_rec%?alarm_repeat_mult%<>p%?alarm_repeat_mult% matched%=FALSE
         ELSE
          matched%=FALSE
         ENDIF
         IFmatched% THEN
          PROCheap_free("ALRM",this_rec%)
          this_rec%=0
          p%=0
         ELSE
          p%=p%!alarm_next%
         ENDIF
        ENDWHILE
       ENDIF
       IFthis_rec%<>0 THEN PROCsave_alarm(this_rec%)
      ENDIF
      REM set the file pointer ready for the loop around
      PTR#c%=ptr%+5
     ENDIF
     SYS"Hourglass_Percentage",PTR#c%*100/EXT#c%
    UNTIL ptr%=-1
    SYS"Hourglass_Off"
    c%=FNclose(c%)
    IFra$=FNmsg_0("FN2") ra$=f$
    IFf$=ra$ AND m%=FALSE AND this_autosave%=TRUE THEN
     REM A consequence of using PROCsave_alarm is that
     REM it marks the modified flag, so if we are loading
     REM the default file and we hadn't set anything yet
     REM then we can clear the flag
     REM
     REM Note that this_autosave% is forced to true if
     REM this is the first alarm file (since we could
     REM load it multiple times) otherwise the global
     REM autosave value is used
     modified%=FALSE
     PROCset_title(browser%,f$)
    ENDIF
   ELSE
    c%=FNclose(c%)
    PROCok(FNmsg_1("OkayA3",f$))
   ENDIF
  ELSE
   REM IFra$=def_fn$ OR ra$="" ra$=FNmsg_0("FN2")
   IFra$="" ra$=FNmsg_0("FN2")
   REM just check that the file actually exists
   SYS"XOS_File",17,f$ TO c%;B%
   IF (B% AND 1)=0 AND c%<>0 THEN
    null% =FNerr_box(1,FNmsg_1("File07",f$),1)
   ENDIF
  ENDIF
  alarm_autosave%=old_autosave%
 ENDIF
 PROCadjust_browser_size
 PROCreset_alarm_status
ENDPROC
:
DEFPROCsave_alarms_to_disc(f$,selection%,safe%,give_error%)
 REM
 REM Save all of the alarms in the linked
 REM list to disc.
 REM
 LOCAL c%,p%,prev%,prev1%,prev2%,doit%
 LOCAL r0%,r2%,r3%,r4%,f%
 LOCAL o$
 autosaved%=FALSE
 IFf$="" ENDPROC
 
 o$=f$ : REM Save original file name
 
 REM if the filename begins "choices:" then we have
 REM to change to using "<choices$write>", and also
 REM check for the presence of a directory called
 REM Alarm in it...
 IF FNupper(f$)=FNupper(def_fn$) THEN
  f$="<Choices$Write>.Alarm"
  SYS"XOS_File",8,f$,0
  f$=f$+".Alarms"
 ENDIF
 
 REM since we are about to create a new Alarms file,
 REM stomp on the existing one first to see if we
 REM get a more interesting error
 SYS"XOS_File",17,f$ TO r0%,,r2%,r3%,r4%;f%
 IF(f%AND1) THEN
  IFgive_error% THEN
   null% =FNerr_box(1,FNmsg_1("File06",FNrtoz(r0%+4)),1)
  ENDIF
  ENDPROC
 ENDIF
 
 REM if we found a file with the same name, create
 REM a file with the same name, load/exec/length
 REM attributes
 
 REM if we DIDN'T find a file with the same name,
 REM try to create a typed empty file
 
 IF r0%=1 THEN
  SYS"XOS_File",7,f$,r2%,r3%,0,r4% TO r0%;f%
 ELSE
  SYS"XOS_File",11,f$,&AE9 TO r0%;f%
 ENDIF
 
 IF(f%AND1) THEN
  IFgive_error% THEN
   null% =FNerr_box(1,FNmsg_1("File06",FNrtoz(r0%+4)),1)
  ENDIF
  ENDPROC
 ENDIF
 
 SYS"Hourglass_On"
 c%=FNopen(f$,&80)
 IF c%>0 THEN
  SYS"OS_Args",254,c% TO p%
  IF(p% AND 1<<7)=0 THEN
   CLOSE#c%
   c%=-2
  ENDIF
 ENDIF
 IF c%>0 THEN
  IFNOT(selection%) AND (safe%) THEN
   modified%=FALSE
   PROCset_title(browser%,o$)
   ra$=o$:REM make this the main alarm file (use original file name)
  ENDIF
  BPUT#c%,&41
  BPUT#c%,&4C
  BPUT#c%,&52
  BPUT#c%,&4D
  IFalarm_head%=0 THEN
   PRINT#c%,-1
  ELSE
   PRINT#c%,14
  ENDIF
  PRINT#c%,-1
  p%=alarm_head%
 
  REM prev% is a pointer to the previous record written to
  prev%=-1
  WHILE p%
   REM IFFNcheck_pointer PROCcheck_pointer(p%,"PROCsave_alarms_to_disc")
   IF selection% THEN
    IFp%?alarm_selected% THEN
     doit%=TRUE
    ELSE
     doit%=FALSE
    ENDIF
   ELSE
    doit%=TRUE
   ENDIF
 
   IF doit% THEN
    prev1%=PTR#c%
    IFprev%<>-1 THEN
     PTR#c%=prev%+5
     PRINT#c%,prev1%
     PTR#c%=prev1%
    ENDIF
    PROCsave_record(c%,p%,-1,prev%)
    prev%=prev1%
   ENDIF
   p%=p%!alarm_next%
  ENDWHILE
  c%=FNclose(c%)
  IFc% THEN
   PROCwarning(FNmsg_1("File03",FNmsg_0("File01")))
  ELSE
   SYS"OS_File",18,f$,&AE9
   autosaved%=TRUE
  ENDIF
 ELSE
  IFc%=-2 THEN
   PROCwarning(FNmsg_1("File03",FNmsg_0("File04")))
  ELSE
   PROCwarning(FNmsg_1("File02", REPORT$))
  ENDIF
 ENDIF
 REM there won't be any instances of duplicated
 REM warnings here, so we can reset the flags now
 alarm_warned%=FALSE
 SYS"Hourglass_Off"
ENDPROC

REM *************************************************************************
REM Alarm actions
REM *************************************************************************

DEFPROCichang(i%)
 REM IFFNcheck_pointer PROCcheck_pointer(i%,"PROCichang")
 alarm_original_pointer%=i%
 IFalarms%(0)=0 alarms%(0)=FNheap_claim("ALRM",alarm_SIZE%)
 IFalarms%(0)=0 PROCout_of_memory
 PROCcopyalarm(alarm_original_pointer%,alarms%(0))
 !Q%=a_wind%:SYS"Wimp_CloseWindow",,Q%
 PROCcreate_alarm_wind(FNmsg_0("TitlA3"),TRUE,alarms%(0))
 PROCopen_alarm_wind
 IF NOT(alarm_applalarm%?alarms%(0)) THEN
  SYS"Wimp_SetCaretPosition",a_wind%,mess1%,-1,-1,-1,FNlength_icon(mess1%)
 ENDIF
 current_action%=changing%
ENDPROC
:
DEFPROCdefer(R%)
 LOCAL S%,e%,error%
 S%=VAL($deftime%)
 IF S%<=0 THEN ENDPROC
 e%=FNheap_claim("ALRM",alarm_SIZE%)
 IFe%=0 PROCout_of_memory
 PROCcopyalarm(alarms%(1),e%)
 REM if we are deferring by any amount less then
 REM a day, reset it to the current date and time
 IFR%<4 PROCread_date_and_time(e%)
 e%?alarm_repeating%=0
 e%?alarm_repeat_rate%=1
 e%?alarm_repeat_mult%=1
 PROCsave_repeating_alarm(e%,R%,S%,error%)
 REM we will report the error NOW so that
 REM the alarm message window does not get closed
 IFerror% PROCok(FNmsg_0("OkayC4"))
 alarm_warned%=FALSE
 PROCclosewindow(m_wind%)
ENDPROC

DEFPROCsave_repeating_alarm(I%,R%,S%,RETURN error%)
 LOCAL P%,Z%,ptr%, open%, dotpos%, left%
 P%=0:Z%=0:dotpos%=0
 open%=FALSE
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCsave_repeating_alarm")
 SYS"Hourglass_On"
 ptr%=FNheap_claim("ALRM",alarm_SIZE%)
 IFptr%=0 PROCout_of_memory
 PROCread_date_and_time(ptr%)
 CASE I%?alarm_repeating% OF
 WHEN 0,1:REPEAT
           P%=(P%+1)MOD 100
           IF P%=0 AND NOT open% PROCopen_slow_increment_warning:open%=TRUE
           PROCincrement_alarm(I%,R%,S%,error%)
          UNTIL FNrec1_less_than_rec2(ptr%,I%) OR error%
 WHEN   2:REPEAT
           P%=(P%+1)MOD 100
           IF P%=0 AND NOT open% PROCopen_slow_increment_warning:open%=TRUE
           PROCincrement_special_alarm(I%,R%,S%,error%)
          UNTIL FNrec1_less_than_rec2(ptr%,I%) OR error%
 ENDCASE
 IFNOT(error%) PROCsave_alarm(I%)
 PROCheap_free("ALRM",ptr%)
 SYS"Hourglass_Off"
 IFopen% THEN
  !Q%=slow%
  SYS"Wimp_CloseWindow",, Q%
  open%=FALSE
 ENDIF  
ENDPROC
:
DEFPROCuser_set_an_alarm
 alarm_original_pointer%=0
 IFalarms%(0)=0 alarms%(0)=FNheap_claim("ALRM",alarm_SIZE%)
 IFalarms%(0)=0 PROCout_of_memory
 alarm_prev%!alarms%(0)=0
 alarm_next%!alarms%(0)=0
 alarm_fileptr%!alarms%(0)=0
 PROCread_date_and_time(alarms%(0))
 $(alarms%(0)+alarm_line1%)=""
 $(alarms%(0)+alarm_line2%)=""
 $(alarms%(0)+alarm_line3%)=""
 alarm_urgent%?alarms%(0)=FALSE
 alarm_applalarm%?alarms%(0)=FALSE
 alarm_repeating%?alarms%(0)=0
 alarm_taskalarm%?alarms%(0)=FALSE
 alarm_fvdywk%?alarms%(0)=fivedayweek%
 alarm_repeat_mult%?alarms%(0)=1
 alarm_repeat_rate%?alarms%(0)=1
 alarm_selected%?alarms%(0)=0
 PROCcreate_alarm_wind(FNmsg_0("TitlA1"),TRUE,alarms%(0))
 PROCopen_alarm_wind
 SYS"Wimp_SetCaretPosition",a_wind%,mess1%,-1,-1,-1,FNlength_icon(mess1%)
 REM if we get this far, we must be setting an alarm :-)
 current_action%=setting%
ENDPROC
:
DEFPROCopen_slow_increment_warning
 LOCAL reason%
 PROCopen_window(slow%)
 SYS"Wimp_Poll", 932209, Q% TO reason%
 IF reason%=1 THEN
  SYS"Wimp_RedrawWindow",, Q% TO left%
  WHILE left%
   SYS"Wimp_GetRectangle",, Q% TO left%
  ENDWHILE
 ENDIF
ENDPROC
:
DEFPROCok_current_action
 LOCAL i%
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(0),"PROCok_current_action(0)")
 i%=current_action%:current_action%=-1:PROCclosewindow(a_wind%):current_action%=i%
 IF current_action%=setting% OR current_action%=changing% THEN
  IF current_action%=changing% THEN
   PROCremove_alarm_from_list(alarm_original_pointer%,FALSE)
   alarm_original_pointer%=0
  ENDIF
  i%=FNheap_claim("ALRM",alarm_SIZE%)
  IFi%=0 PROCout_of_memory
  PROCcopyalarm(alarms%(0),i%)
  PROCheap_free("ALRM",alarms%(0))
  alarms%(0)=0
  PROCstore_alarm_strings(i%)
  PROCsave_alarm(i%)
  alarm_warned%=FALSE
 ENDIF
 PROCreset_alarm_status
 IFcurrent_action%=changing% THEN
  REM see if there is another selected alarm
  i%=alarm_head%
  WHILE i%
   REM IFFNcheck_pointer PROCcheck_pointer(i%,"PROCok_current_action(i%)")
   IFi%?alarm_selected% THEN
    i%?alarm_selected%=0
    PROCredraw_alarm(i%)
    PROCichang(i%)
    ENDPROC
   ELSE
    i%=i%!alarm_next%
   ENDIF
  ENDWHILE
 ENDIF
 current_action%=-1
ENDPROC
:
DEFPROCcancel_current_action
 REM *always* free this alarm block as it was only a copy
 PROCheap_free("ALRM",alarms%(0))
 alarms%(0)=0
 alarm_original_pointer%=0
 IFcurrent_action%=changing% THEN
  REM see if there is another selected alarm
  i%=alarm_head%
  WHILE i%
   REM IFFNcheck_pointer PROCcheck_pointer(i%,"PROCcancel_current_action(i%)")
   IFi%?alarm_selected% THEN
    i%?alarm_selected%=0
    PROCredraw_alarm(i%)
    PROCichang(i%)
    ENDPROC
   ELSE
    i%=i%!alarm_next%
   ENDIF
  ENDWHILE
 ENDIF
 current_action%=-1
ENDPROC
:
DEFFNalarm_sounding(U%)
 IFNOTalarm_detected%             :=FALSE
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"FNalarm_sounding(1)")
 IFalarm_applalarm%?alarms%(1) :=FALSE
 IFsilent_alarm% AND (U%=0)       :=FALSE
 IFalarm_counter%=0               :=FALSE
=TRUE
:
DEFFNalarm_gone_off(ptr%)
 LOCAL hr%,mi%,da%,mo%,yr%
 REM IFFNcheck_pointer PROCcheck_pointer(ptr%,"FNalarm_gone_off")
 PROCfivebt_to_ordinals(cur_clock%,hr%,mi%,da%,mo%,yr%)
 IFyr% < ptr%!valid_year%    :=FALSE
 IFyr% > ptr%!valid_year%    :=TRUE
 IFmo% < ptr%!valid_month%   :=FALSE
 IFmo% > ptr%!valid_month%   :=TRUE
 IFda% < ptr%!valid_date%    :=FALSE
 IFda% > ptr%!valid_date%    :=TRUE
 IFhr% < ptr%!valid_hours%   :=FALSE
 IFhr% > ptr%!valid_hours%   :=TRUE
 IFmi% < ptr%!valid_minutes% :=FALSE
=TRUE
:
DEFPROCcheck_date_and_time(U%)
 LOCAL t$,Y%,y%,e%,error%
 REM IFFNcheck_pointer PROCcheck_pointer(alarms%(1),"PROCcheck_date_and_time(1)")
 
 IFNOT(FNalarm_gone_off(alarms%(1))) ENDPROC
 
 REM ensure that all of the icons are clear ... (#2 isn't used)
 PROCset_string(m_wind%,ic_message_at1%,"")
 PROCset_string(m_wind%,ic_message_at2%,"")
 PROCset_string(m_wind%,ic_message_msg1%,"")
 PROCset_string(m_wind%,ic_message_msg2%,"")
 PROCset_string(m_wind%,ic_message_msg3%,"")
 PROCset_string(m_wind%,ic_message_msg4%,"")
 PROCset_string(m_wind%,ic_message_msg5%,"")
 PROCset_string(m_wind%,ic_message_msg6%,"")
 alarm_detected%=TRUE
 alarm_counter%=global_timeout%
 IF alarm_applalarm%?alarms%(1) PROCbroadcast_appl_alarm:ENDPROC
 IF alarm_taskalarm%?alarms%(1) PROCactivate_task_alarm:ENDPROC
 Y%=92
 PROCalarm_rec_to_fivebt(alarms%(1),buffers%)
 t$=FNconverttime(buffers%,FNmsg_0("ActvA1"))
 PROCset_string(m_wind%,ic_message_at1%,t$)
 REM ***** buffers% shouldn't have been altered since three lines above
 t$=FNconverttime(buffers%,FNmsg_0("ActvA6"))
 PROCset_string(m_wind%,ic_message_at2%,t$)

 CASE alarm_repeating%?alarms%(1) OF
 WHEN 0:y%=ic_message_msg1%
 WHEN 1:e%=FNheap_claim("ALRM",alarm_SIZE%)
        IFe%=0 PROCout_of_memory
        PROCcopyalarm(alarms%(1),e%)
        PROCincrement_alarm(e%,e%?alarm_repeat_rate%,e%?alarm_repeat_mult%,error%)
        IFerror% THEN
         PROCset_string(m_wind%,ic_message_msg1%,FNmsg_0("OkayC7"))
         PROCset_string(m_wind%,ic_message_msg2%,FNmsg_0("OkayC8"))
         PROCset_string(m_wind%,ic_message_msg3%,"")
        ELSE
         PROCalarm_rec_to_fivebt(e%,buffers%)
         t$=FNconverttime(buffers%,FNmsg_0("ActvA2"))
         PROCset_string(m_wind%,ic_message_msg1%,t$)
         t$=FNconverttime(buffers%,FNmsg_0("ActvA6"))
         PROCset_string(m_wind%,ic_message_msg2%,t$)
         PROCset_string(m_wind%,ic_message_msg3%,"")
        ENDIF
        Y%+=120
        y%=ic_message_msg4%
        PROCheap_free("ALRM",e%)
        e%=0
 WHEN 2:e%=FNheap_claim("ALRM",alarm_SIZE%)
        IFe%=0 PROCout_of_memory
        PROCcopyalarm(alarms%(1),e%)
        PROCincrement_special_alarm(e%,e%?alarm_repeat_rate%,e%?alarm_repeat_mult%,error%)
        IFerror% THEN
         PROCset_string(m_wind%,ic_message_msg1%,FNmsg_0("OkayC7"))
         PROCset_string(m_wind%,ic_message_msg2%,FNmsg_0("OkayC8"))
         PROCset_string(m_wind%,ic_message_msg3%,"")
        ELSE
         PROCalarm_rec_to_fivebt(e%,buffers%)
         t$=FNconverttime(buffers%,FNmsg_0("ActvA2"))
         PROCset_string(m_wind%,ic_message_msg1%,t$)
         t$=FNconverttime(buffers%,FNmsg_0("ActvA6"))
         PROCset_string(m_wind%,ic_message_msg2%,t$)
         PROCset_string(m_wind%,ic_message_msg3%,"")
        ENDIF
        Y%+=120
        y%=ic_message_msg4%
        PROCheap_free("ALRM",e%)
        e%=0
 ENDCASE
 PROCset_string(m_wind%,y%+0,$(alarms%(1)+alarm_line1%))
 PROCset_string(m_wind%,y%+1,$(alarms%(1)+alarm_line2%))
 PROCset_string(m_wind%,y%+2,$(alarms%(1)+alarm_line3%))
 IF $(alarms%(1)+alarm_line3%)<>"" THEN
  Y%+=160
 ELSE
  IF $(alarms%(1)+alarm_line2%)<>"" THEN
   Y%+=120
  ELSE
   IF $(alarms%(1)+alarm_line1%)<>"" THEN Y%+=80
  ENDIF
 ENDIF
 IF U% THEN
  PROCset_title(m_wind%,FNmsg_0("ActvA3"))
 ELSE
  PROCset_title(m_wind%,FNmsg_0("ActvA4"))
 ENDIF
 
 REM allow for accept button and small gap
 Y% +=52+10

 REM delete former accept button and place new
 !Q%  =m_wind%
 Q%!4 =ic_message_accept%
 SYS"XWimp_GetIconState",,Q%
 SYS"XWimp_DeleteIcon",,Q%
 Q%!4 =m_wind%
 Q%!12= -(Y% -10)     : REM Min y
 Q%!20= -(Y% -10 -52) : REM Max y
 SYS"Wimp_CreateIcon",,Q%+4 TO ic_message_accept%

 PROCtell_pinboard(m_wind%)

 REM resize message window according to number of lines shown
 !Q%=m_wind%
 SYS"Wimp_GetWindowState",,Q%
 Q%!8=Q%!16-Y%
 Q%!28=-1
 SYS"Wimp_OpenWindow",,Q%
ENDPROC
:
DEFFNalarm_hit(y%)
 LOCAL p%,i%,q%
 !Q1%=browser%:SYS"Wimp_GetWindowState",,Q1%
 y%-=Q1%!16-Q1%!24-52
 i%=0
 q%=0
 p%=alarm_head%
 WHILE p%
  REM IFFNcheck_pointer PROCcheck_pointer(p%,"FNalarm_hit")
  i%-=48
  IF(y%>i%) AND (y%<i%+48) THEN
   q%=p%
   p%=0
  ELSE
   p%=p%!alarm_next%
  ENDIF
 ENDWHILE
=q%
:
DEFPROCset_repeat_flags(W%,Z%)
 REM W% is true if the user can manipulate the values
 REM Z% is the alarm index
 LOCAL I%,J%,A%,R%,S%
 REM IFFNcheck_pointer PROCcheck_pointer(Z%,"PROCset_repeat_flags")
 CASE Z%?alarm_repeating% OF
 WHEN 0:PROCsetstate(a_wind%,19,0,1<<21)
        PROCsetstate(a_wind%,32,0,1<<21)
        PROCsetstate(a_wind%,33,0,1<<21)
        FOR I%=20 TO 28
         PROCsetstate(a_wind%,I%,1<<22,3<<21)
        NEXT
        FOR I%=34 TO 42
         PROCsetstate(a_wind%,I%,1<<22,3<<21)
        NEXT
        PROCset_string(a_wind%,27,STR$(Z%?alarm_repeat_mult%))
        PROCset_string(a_wind%,35,FNmsg_0("SR"+STR$(FNread_repeat_offset(Z%))+"w"+STR$(FNread_repeat_day(Z%))))
        PROCset_string(a_wind%,38,FNmsg_0("WE"+STR$(FNread_repeat_day(Z%))+"a"+STR$(FNread_repeat_offset(Z%))))
        PROCset_string(a_wind%,41,FNmsg_0("MR"+STR$(Z%?alarm_repeat_mult%)))
 WHEN 1:PROCset(19)
        PROCset(32)
        S%=Z%?alarm_repeat_rate%
        J%=0
        FOR I%=20 TO 25
         IF W% A%=11<<12 ELSE A%=0
         IF S% AND (1<<J%) A%+=1<<21
         PROCsetstate(a_wind%,I%,A%,(3<<21)+(15<<12))
         J%+=1
        NEXT
        FOR I%=26 TO 28
         PROCsetstate(a_wind%,I%,0,3<<21)
        NEXT
        FOR I%=34 TO 42
         PROCsetstate(a_wind%,I%,1<<22,3<<21)
        NEXT
        PROCset_string(a_wind%,27,STR$(Z%?alarm_repeat_mult%))
 WHEN 2:PROCset(19)
        PROCset(33)
        FOR I%=20 TO 28
         PROCsetstate(a_wind%,I%,1<<22,3<<21)
        NEXT
        FOR I%=34 TO 42
         PROCsetstate(a_wind%,I%,0,3<<21)
        NEXT
        IFZ%?alarm_fvdywk% THEN
         PROCcheck_special_day(Z%)
        ELSE
         PROCset_string(a_wind%,38,FNmsg_0("WE"+STR$(FNread_repeat_day(Z%))+"a"+STR$(FNread_repeat_offset(Z%))))
        ENDIF
        PROCset_string(a_wind%,35,FNmsg_0("SR"+STR$(FNread_repeat_offset(Z%))+"w"+STR$(FNread_repeat_day(Z%))))
        PROCset_string(a_wind%,41,FNmsg_0("MR"+STR$(Z%?alarm_repeat_mult%)))
 ENDCASE
ENDPROC

REM *************************************************************************
REM Alarm time component manipulation
REM *************************************************************************

DEFPROCchange_hour(I%,V%,H%)
 LOCAL error%
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCchange_hour")
 I%!alarm_hours%+=V%
 PROCvalidate_alarm_rec(I%,error%)
 PROCrefresh_alarm_window(H%,I%)
ENDPROC
:
DEFPROCchange_min(I%,V%,H%)
 LOCAL error%
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCchange_min")
 I%!alarm_minutes%+=V%
 PROCvalidate_alarm_rec(I%,error%)
 PROCrefresh_alarm_window(H%,I%)
ENDPROC
:
DEFPROCchange_year(I%,V%,H%)
 LOCAL error%
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCchange_year")
 I%!alarm_year%+=V%
 PROCvalidate_alarm_rec(I%,error%)
 PROCrefresh_alarm_window(H%,I%)
ENDPROC
:
DEFPROCchange_month(I%,V%,H%)
 LOCAL error%
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCchange_month")
 I%!alarm_month%+=V%
 PROCvalidate_alarm_rec(I%,error%)
 PROCrefresh_alarm_window(H%,I%)
ENDPROC
:
DEFPROCchange_date(I%,V%,H%)
 LOCAL error%
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"PROCchange_date")
 I%!alarm_date%+=V%
 PROCvalidate_alarm_rec(I%,error%)
 PROCrefresh_alarm_window(H%,I%)
ENDPROC
:
DEFFNhour(I%)
 REM return the hours from the specified
 REM alarm record as a string formatted by Time10
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNtime")
 PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time10"))
:
DEFFNmin(I%)
 REM return the minutes from the specified
 REM alarm record as a string formatted by Time11
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNtime")
 PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time11"))
:
DEFFNam(I%)
 REM return the am/pm from the specified
 REM alarm record as a string formatted by Time13
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNtime")
 PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time13"))
:
DEFFNtime(I%)
 REM return the hours and minutes from the specified
 REM alarm record as a string formatted by Time01
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNtime")
 PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time01"))
:
DEFFNdate(I%)
 REM return the date from the specified alarm record
 REM as a string formatted by Time02
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNdate")
 PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time02"))
:
DEFFNday(I%)
 REM return the day of the month from the specified alarm record
 REM as a string formatted by Time12
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNdate")
 PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time12"))
:
DEFFNmonth(I%)
 REM return the month from the specified alarm record
 REM as a string formatted by Time03
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNmonth")
 PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time03"))
:
DEFFNdow(I%)
 REM return the day of the week from the specified alarm record
 REM as a string formatted by Time14
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNmonth")
 PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time14"))
:
DEFFNyear(I%)
 REM return the year from the specified alarm record
 REM as a string formatted by Time04
 REM IFFNcheck_pointer PROCcheck_pointer(I%,"FNyear")
 PROCalarm_rec_to_fivebt(I%,buffers%)
=FNconverttime(buffers%,FNmsg_0("Time04"))
