/*
 * Copyright (c) 2017, Colin Granville
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * The name Colin Granville may not be used to endorse or promote
 *       products derived from this software without specific prior written
 *       permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "sys/queue.h"
#include "Global/services.h"
#include "callx/callx.h"
#include "dci.h"

#include "swis.h"

#include "ModuleHdr.h"
#include "module.h"
#include "device.h"
#include "mii.h"
#include "debug.h"
#include "utils.h"
#include "dcierror.h"



/* This function is autogenerated by ResGen, and returns a pointer to a
 * ResourceFS resource file data block */
#ifdef STANDALONE
extern void *Resources(void);
#endif


static uint32_t module_init_flags;
#define MIF_INITIALISED         (1 << 0)
#define MIF_RESOURCES           (1 << 1)
#define MIF_CALLX               (1 << 2)
#define MIF_MBUF                (1 << 3)
#define MIF_UTILS               (1 << 4)
#define MIF_DCIERROR            (1 << 5)

static _kernel_oserror* module_destroy(_kernel_oserror* err)
{
        module_final(1,0,0);
        return err;
}

static _kernel_oserror* delayed_init(_kernel_swi_regs* r, void* pw, void* handle)
{
        IGNORE(r);
        IGNORE(handle);
        dprintf_here("\n");
        _kernel_oserror* err = NULL;

        /* swis should now be available */
        module_init_flags |= MIF_INITIALISED;

        for (int found = 0, unit = 0;;)
        {
                HalEtherDevice_t* hal_device;

                err = _swix(OS_Hardware, _INR(0,1) | _IN(8) | _OUTR(1,2),
                                        HALDeviceType_Comms | HALDeviceComms_EtherNIC,
                                        found,
                                        OSHW_DeviceEnumerate,
                                        &found,
                                        &hal_device);

                if (err || found == -1) break;

                if (hal_device->base.id != HALDeviceID_EtherNIC_IMX6 ||
                    hal_device->base.address == 0 ||
                    hal_device->base.devicenumber == -1) continue;

                err = device_new(unit, hal_device, pw);

                if (err) break;

                break; /* ***TEST*** THERE SHOULD BE ONLY 1 FOR IMX6 */

                unit++;
        }
        dprintf_here("Finished\n");
        return SLIST_EMPTY(&device_list) ? err : NULL;
}

_kernel_oserror* module_init(const char *cmd_tail, int podule_base, void *pw)
{
        IGNORE(cmd_tail);
        IGNORE(podule_base);

        _kernel_oserror* err = NULL;

#ifdef STANDALONE
        err = _swix(ResourceFS_RegisterFiles, _IN(0), Resources());
        if (err) return err;
        module_init_flags |= MIF_RESOURCES;
#else
        /* In ROM builds, all resource files live in the Messages module instead */
#endif

#ifdef DEBUGLIB
#       warning ********* DEBUG MODE ***********
        debug_initialise ("EtherTH", 0, 0);
        debug_set_device(DADEBUG_OUTPUT);
#endif

        err = dcierror_init();
        if (err) return module_destroy(err);
        module_init_flags |= MIF_DCIERROR;

        err = mb_entryinit();                   /* Initialise mbufs */
        if (err) return module_destroy(err);
        module_init_flags |= MIF_MBUF;

        err = utils_initialise();
        if (err) return module_destroy(err);
        module_init_flags |= MIF_UTILS;

        callx_init(pw);
        module_init_flags |= MIF_CALLX;


        /* Add devices on a callback so that the swis are available */
        callx_add_callback(delayed_init, 0);
        return err;
}

_kernel_oserror* module_final(int fatal, int podule, void *pw)
{
        IGNORE(fatal);
        IGNORE(podule);
        IGNORE(pw);

        uint32_t flags = module_init_flags;
        module_init_flags = 0;

        while (!SLIST_EMPTY(&device_list))
        {
                device_delete(SLIST_FIRST(&device_list));
        }

        if (flags & MIF_CALLX)
        {
                callx_remove_all_calleverys ();
                callx_remove_all_callafters ();
                callx_remove_all_callbacks ();
        }

        if (flags & MIF_MBUF) mb_closesession();        /* Close mbuf session */

        if (flags & MIF_DCIERROR) dcierror_final();

#ifdef STANDALONE
        if (flags & MIF_RESOURCES) _swix(ResourceFS_DeregisterFiles, _IN(0), Resources());
#endif
        dprintf_here("end\n");
        return NULL;
}


void module_service(int service_number, _kernel_swi_regs *r, void *pw)
{
        IGNORE(pw);

        if ((module_init_flags & MIF_INITIALISED) == 0)  return;        /* ignore until delayed initialisation is complete */

        dprintf_regs(r);

        switch (service_number)
        {
                case Service_PreReset:
                  {    /* shut down the module totally */
                       module_final(1,0,0);
                  }
                  break;
                case Service_MbufManagerStatus:
                        switch (r->r[0]) /* reason code */
                        {
                                case MbufManagerStatus_Started:
                                        /* todo */
                                        break;

                        }
                        break;

                case Service_EnumerateNetworkDrivers:
                {
                        struct
                        {
                                ChDibRef        list;
                                int             service_number;
                        }* args = (void*) r;
                        device_t* d;

                        SLIST_FOREACH(d, &device_list, next)
                        {
                                ChDibRef chd = malloc(sizeof(*chd));
                                if (chd == NULL)  break;                /* return with items already added to list */

                                chd->chd_dib = &d->dib;
                                chd->chd_next = args->list;
                                args->list = chd;
                        }
                        break;
                }

                case Service_DCIProtocolStatus:
                {
                        struct
                        {
                                void*           pw;
                                int             service_number;
                                int             reason_code;            /* see DCIPROTOCOL_ in dcistructs */
                                int             version;
                                const char*     protocol;
                        }* args = (void*) r;

                        if (args->reason_code == DCIPROTOCOL_DYING &&
                            args->version / 100 == DCIVERSION / 100)   /* Ensure same major version */
                        {
                                /* Release the filters associated with this DCI protocol module */
                                device_t* d;
                                SLIST_FOREACH(d, &device_list, next)
                                {
                                        dcifilter_release_module(d->dcifilter, args->pw);
                                }
                        }


                }
                        break;
#ifdef STANDALONE
                case Service_ResourceFSStarting:
                {
                        struct
                        {
                                int     unused;
                                int     service_number;
                                void (*initialise)(void *, void *, void *, void *);
                                void*   pw;
                        }* args = (void*) r;

                        args->initialise(Resources(), 0, 0, args->pw);
                        break;
                }
#endif
        }
}

#define SWI_OFF(name) EtherTH_##name - EtherTH_00

_kernel_oserror *module_swi(int swi_offset, _kernel_swi_regs *r, void *pw)
{
        IGNORE(pw);
        if (swi_offset != SWI_OFF(Transmit)) dprintf_here("swi=%d\n",swi_offset);

        if ((module_init_flags & MIF_INITIALISED) == 0)  return error_BAD_SWI; /* ignore until delayed initialisation is complete */

        if (swi_offset != SWI_OFF(Transmit)) dprintf_regs(r);

        device_t* device;

        switch (swi_offset)
        {

                case SWI_OFF(DCIVersion):
                {
                        dci_DCIVersionArgs_t* args = (void*) r;
                        args->DCIVersion_out = DCIVERSION;
                        return NULL;
                }
                case SWI_OFF(Inquire):
                        device = device_getFromUnit(((dci_InquireArgs_t*) r)->unit);
                        if (device == NULL) return dcierror(ENXIO);
                        return device_inquire(device, (void*) r);

                case SWI_OFF(GetNetworkMTU):
                        device = device_getFromUnit(((dci_GetNetworkMTUArgs_t*) r)->unit);
                        if (device == NULL) return dcierror(ENXIO);
                        return device_getNetworkMTU(device, (void*) r);

                case SWI_OFF(SetNetworkMTU):
                        device = device_getFromUnit(((dci_SetNetworkMTUArgs_t*) r)->unit);
                        if (device == NULL) return dcierror(ENXIO);
                        return device_setNetworkMTU(device, (void*) r);

                case SWI_OFF(Transmit):
                        device = device_getFromUnit(((dci_TransmitArgs_t*) r)->unit);
                        if (device == NULL) return dcierror(ENXIO);
                        return device_transmit(device, (void*) r);

                case SWI_OFF(Filter):
                        device = device_getFromUnit(((dci_FilterArgs_t*) r)->unit);
                        if (device == NULL) return dcierror(ENXIO);
                        return dcifilter_manage(device->dcifilter, (void*) r);

                case SWI_OFF(Stats):
                        device = device_getFromUnit(((dci_StatsArgs_t*) r)->unit);
                        if (device == NULL) return dcierror(ENXIO);
                        return device_stats(device, (void*) r);

                case SWI_OFF(MulticastRequest):
                        device = device_getFromUnit(((dci_MulticastRequestArgs_t*) r)->unit);
                        if (device == NULL) return dcierror(ENXIO);
                        return device_multicastRequest(device, (void*) r);
        }
        return error_BAD_SWI;
}

typedef struct
{
        const char*     desc;
        const char*     reg_name;
        uint32_t        reg;
} ethstat_t;

static const ethstat_t devstats[] =
{
        {"\neth0 statistics\n", 0, -2u},
        {"Transmit (tx) statistics\n", 0, -2u},
        {"Tx Packet Count", "ENET_RMON_T_PACKETS", 0x204},
        {"Tx Broadcast Packets", "ENET_RMON_T_BC_PKT", 0x208},
        {"Tx Multicast Packets", "ENET_RMON_T_MC_PKT", 0x20c},
        {"Tx Packets with CRC/Align Error", "ENET_RMON_T_CRC_ALIGN", 0x210},
        {"Tx Packets Less Than 64 Bytes and Good", "ENET_RMON_T_UNDERSIZE", 0x214},
        {"Tx Packets GT MAX_FL bytes And Good CRC", "ENET_RMON_T_OVERSIZE", 0x218},
        {"Tx Packets Less Than 64 Bytes and Bad CRC", "ENET_RMON_T_FRAG", 0x21c},
        {"Tx Packets GT MAX_FL bytes and Bad CRC", "ENET_RMON_T_JAB", 0x220},
        {"Tx Collision Count", "ENET_RMON_T_COL", 0x224},
        {"Tx 64-Byte Packets", "ENET_RMON_T_P64", 0x228},
        {"Tx 65-127 Byte Packets", "ENET_RMON_T_P65TO127", 0x22c},
        {"Tx 128-255 Byte Packets", "ENET_RMON_T_P128TO255", 0x230},
        {"Tx 256-511 Byte Packets", "ENET_RMON_T_P256TO511", 0x234},
        {"Tx 512-1023 Byte Packets", "ENET_RMON_T_P512TO1023", 0x238},
        {"Tx 1024-2047 Byte Packets", "ENET_RMON_T_P1024TO2047", 0x23c},
        {"Tx Packets Greater Than 2048 bytes","ENET_RMON_T_GTE2048", 0x240},
        {"Tx Octets", "ENET_RMON_T_OCTETS", 0x244},
        {"",0,-2u},
        {"Frames Transmitted OK", "ENET_IEEE_T_FRAME_OK", 0x24C},
        {"Frames Transmitted With Single Collision", "ENET_IEEE_T_1COL", 0x250},
        {"Frames Transmitted With Multiple Collisions", "ENET_IEEE_T_MCOL", 0x254},
        {"Frames Transmitted After Deferral Delay", "ENET_IEEE_T_DEF", 0x258},
        {"Frames Transmitted With Late Collision", "ENET_IEEE_T_LCOL", 0x25c},
        {"Frames Transmitted With Excessive Collisions", "ENET_IEEE_T_EXCOL", 0x260},
        {"Frames Transmitted With Tx FIFO Underrun", "ENET_IEEE_T_MACERR", 0x264},
        {"Frames Transmitted With Carrier Sense Error", "ENET_IEEE_T_CSERR", 0x268},
        {"Frames Transmitted With SQE Error", "ENET_IEEE_T_SQE", 0x26c},
        {"Flow Control Pause Frames Transmitted", "ENET_IEEE_T_FDXFC", 0x270},
        {"Octet Count for Frames Transmitted w/o Error", "ENET_IEEE_T_OCTETS_OK", 0x274},
        {"\nReceive (rx) statistics\n",0,-2u},
        {"Rx Packet Count", "ENET_RMON_R_PACKETS", 0x284},
        {"Rx Broadcast Packets", "ENET_RMON_R_BC_PKT", 0x288},
        {"Rx Multicast Packets", "ENET_RMON_R_MC_PKT", 0x28c},
        {"Rx Packets with CRC/Align Error", "ENET_RMON_R_CRC_ALIGN", 0x290},
        {"Rx Packets Less Than 64 Bytes and Good", "ENET_RMON_R_UNDERSIZE", 0x294},
        {"Rx Packets GT MAX_FL bytes And Good CRC", "ENET_RMON_R_OVERSIZE", 0x298},
        {"Rx Packets Less Than 64 Bytes and Bad CRC", "ENET_RMON_R_FRAG", 0x29c},
        {"Rx Packets GT MAX_FL bytes and Bad CRC", "ENET_RMON_R_JAB", 0x2a0},
        {"Rx 64-Byte Packets", "ENET_RMON_R_P64", 0x2a8},
        {"Rx 65-127 Byte Packets", "ENET_RMON_R_P65TO127", 0x2ac},
        {"Rx 128-255 Byte Packets", "ENET_RMON_R_P128TO255", 0x2b0},
        {"Rx 256-511 Byte Packets", "ENET_RMON_R_P256TO511", 0x2b4},
        {"Rx 512-1023 Byte Packets", "ENET_RMON_R_P512TO1023", 0x2b8},
        {"Rx 1024-2047 Byte Packets", "ENET_RMON_R_P1024TO2047", 0x2bc},
        {"Rx Packets Greater Than 2048 bytes", "ENET_RMON_R_GTE2048", 0x2c0},
        {"Rx Octets", "ENET_RMON_R_OCTETS", 0x2c4},
        {"",0,-2u},
        {"Frames Received not Counted Correctly", "ENET_IEEE_R_DROP", 0x2c8},
        {"Frames Received OK", "ENET_IEEE_R_FRAME_OK", 0x2cc},
        {"Frames Received With CRC Error", "ENET_IEEE_R_CRC", 0x2d0},
        {"Frames Received With Alignment Error", "ENET_IEEE_R_ALIGN", 0x2d4},
        {"Receive FIFO Overflow Count", "ENET_IEEE_R_MACERR", 0x2d8},
        {"Flow Control Pause Frames Received", "ENET_IEEE_R_FDXFC", 0x2dc},
        {"Octet count for frames received without error", "ENET_IEEE_R_OCTETS", 0x2e0},
        {0,0,-1u}
};

static _kernel_oserror* ethstats(const char *arg_string, int argc)
{
        IGNORE(argc);

        int unit = -1;
        bool reset = false;
        int count = 0;

        const char* argstr = arg_string;
        const char* arg;

        for (;;)
        {
                size_t size = utils_enumerate_args(&argstr, &arg);
                if (size == 0) break;

                if (arg[0] != '-')
                {
                        count++;
                        if (count == 1)
                        {
                                if (utils_match_arg("0", arg, size) || utils_match_arg("eth0", arg, size)) unit = 0;
                                else return dcierror(ENXIO);
                        }
                        else return dcierror(EINVAL);
                }
                else
                {
                        if (utils_match_arg("-c", arg, size)) reset = true;
                        else return dcierror(EINVAL);
                }
        }

        device_t* d = device_getFromUnit(unit);
        if (d == NULL) return dcierror(ENXIO);

        if (reset)
        {
                uint32_t reg = device_getReg(d, ENET_MIBC);
                device_setReg(d, ENET_MIBC, reg | ENET_MIBC__MIB_CLEAR);
                device_setReg(d, ENET_MIBC, reg &~ ENET_MIBC__MIB_CLEAR);
                printf("Statistics cleared\n");
                return NULL;
        }

        for (int i = 0; devstats[i].reg != -1u ; i++)
        {
                switch (devstats[i].reg)
                {
                        case -2u: printf("%s\n", devstats[i].desc); break;
                        default:
                                if (devstats[i].reg <= 0x2e0)
                                {
#ifndef DEBUGLIB
                                        printf("%-46s : %d\n", devstats[i].desc, device_getReg(d, devstats[i].reg));
#else
                                        printf("%-24s %-46s : %d\n", devstats[i].reg_name,
                                                                     devstats[i].desc,
                                                                     device_getReg(d, devstats[i].reg));
#endif
                                }
                                break;
                }
        }

        return NULL;
}

static _kernel_oserror* ethconfig(const char *arg_string, int argc)
{
        IGNORE(argc);

        int unit = -1;
        uint32_t speed = 0;
        uint32_t duplex = 0; /* full = 2, half = 1 */
        int count = 0;

        const char* argstr = arg_string;
        const char* arg;

        for (;;)
        {
                size_t size = utils_enumerate_args(&argstr, &arg);
                if (size == 0) break;

                if (arg[0] != '-')
                {
                        count++;
                        if (count == 1)
                        {
                                if (utils_match_arg("0", arg, size) || utils_match_arg("eth0", arg, size)) unit = 0;
                                else return dcierror(ENXIO);
                        }
                        else
                        {
                                if (utils_match_arg("auto", arg, size) && speed == 0) speed = 1;
                                else if (utils_match_arg("10", arg, size) && speed == 0)  speed = 10;
                                else if (utils_match_arg("100", arg, size) && speed == 0)  speed = 100;
                                else if (utils_match_arg("full", arg, size) && duplex == 0) duplex = 2;
                                else if (utils_match_arg("half", arg, size) && duplex == 0) duplex = 1;
                                else return dcierror(EINVAL);
                        }
                }
                else
                {
                        /* no flags */
                        return dcierror(EINVAL);
                }
        }

        if (unit == -1 || speed == 0 || (duplex == 0 && speed > 1) || (duplex && speed == 1)) return dcierror(EINVAL);

        device_t* d = device_getFromUnit(unit);
        if (d == NULL) return dcierror(ENXIO);

        uint32_t val = 0;
        if (speed == 1) val =  MII_BCR__AUTONEGEN | MII_BCR__REAUTONEG;
        else  val = (speed == 10 ? MII_BCR__SPEED_10 : MII_BCR__SPEED_100) |
                    (duplex == 1 ? MII_BCR__DUPLEX_HALF : MII_BCR__DUPLEX_FULL);
        uint32_t reg = mii_getReg(d, MII_BCR);
        reg &= ~(MII_BCR, MII_BCR__AUTONEGEN | MII_BCR__REAUTONEG | MII_BCR__SPEED | MII_BCR__DUPLEX);
        mii_setReg(d, MII_BCR, reg | val);

        return NULL;
}

static _kernel_oserror* ethtune(const char *arg_string, int argc)
{
        IGNORE(argc);

        int unit = -1;
        uint32_t threshold = 4096;
        uint32_t duration  = 0x10000;
        int count = 0;
        const char* argstr = arg_string;
        const char* arg;

        for (;;)
        {
                size_t size = utils_enumerate_args(&argstr, &arg);
                if (size == 0) break;

                if (arg[0] != '-')
                {
                        count++;
                        if (count == 1)
                        {
                                if (utils_match_arg("0", arg, size) || utils_match_arg("eth0", arg, size)) unit = 0;
                                else return dcierror(ENXIO);
                        }
                        else return dcierror(EINVAL);
                }
                else
                {
                        if (utils_match_arg("-thres", arg, size))
                        {
                                if (threshold < 4096) return dcierror(EINVAL);
                                uint32_t val;
                                size = utils_enumerate_args(&argstr, &arg);
                                if (size == 0 || !utils_get_arg_number(arg, size, &val) || val >= 4096) return dcierror(EINVAL);
                                threshold = val;
                        }
                        else if (utils_match_arg("-dur", arg, size))
                        {
                                if (duration < 0x10000) return dcierror(EINVAL);
                                uint32_t val;
                                size = utils_enumerate_args(&argstr, &arg);
                                if (size == 0 || !utils_get_arg_number(arg, size, &val) || val >= 0x10000) return dcierror(EINVAL);
                                duration = val;
                        }
                        else if (utils_match_arg("-default", arg, size))
                        {
                                threshold = PAUSE_THRESHOLD;
                                duration  = PAUSE_DURATION;
                        }
                        else return dcierror(EINVAL);
                }
        }

        device_t* d = device_getFromUnit(unit);
        if (d == NULL) return dcierror(ENXIO);

        if (threshold == 4096) threshold = device_getReg(d, ENET_RSEM) * 8;
        if (duration == 0x10000) duration = ENET_OPD__PAUSE_DURATION(device_getReg(d, ENET_OPD));

        device_setReg(d, ENET_RSEM, threshold/8);
        device_setReg(d, ENET_OPD, duration | ENET_OPD__OP_CODE);


        printf("Pause threshold=%d pause duration=%d\n", threshold, duration);

        return NULL;
}

_kernel_oserror *module_commands(const char *arg_string, int argc, int cmd_no, void *pw)
{
        IGNORE(pw);
        switch (cmd_no)
        {
                case CMD_ETHInfo:       return ethstats(arg_string, argc);
                case CMD_ETHConfig:     return ethconfig(arg_string, argc);
                case CMD_ETHTune:       return ethtune(arg_string, argc);
        }
        return NULL;
}

