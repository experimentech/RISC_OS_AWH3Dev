; This source code in this file is licensed to You by Castle Technology
; Limited ("Castle") and its licensors on contractual terms and conditions
; ("Licence") which entitle you freely to modify and/or to distribute this
; source code subject to Your compliance with the terms of the Licence.
;
; This source code has been made available to You without any warranties
; whatsoever. Consequently, Your use, modification and distribution of this
; source code is entirely at Your own risk and neither Castle, its licensors
; nor any other person who has contributed to this source code shall be
; liable to You for any loss or damage which You may suffer as a result of
; Your use, modification or distribution of this source code.
;
; Full details of Your rights and obligations are set out in the Licence.
; You should have received a copy of the Licence with this source code file.
; If You have not received a copy, the text of the Licence is available
; online at www.castle-technology.co.uk/riscosbaselicence.htm
;
; > Sources.SprTrans

 ^ 0,SP
trns_spr_xcoords                #       16      ;       Four x coordinates
trns_spr_ycoords                #       16      ;       Four y coordinates
trns_comp_spr_left              #       4       ;       Sprite left hand edge (bottom 16 bits)
trns_comp_spr_start             #       4       ;       Sprite start (accounting for internal coord block top)
trns_comp_spr_byte_width        #       4       ;       Sprite byte width << (3-sprite bpp) i.e. row pitch in pixels
trns_comp_spr_height            #       4       ;       Sprite height (top 16 bits) and right hand edge (bottom 16)
trns_comp_spr_ttr               #       4       ;       Translation table (if required)
trns_comp_spr_masko             #       4       ;       Sprite mask offset from image << (3-sprite bpp)
trns_comp_ecf_ora               #       4       ;       ECF OR word
trns_comp_ecf_eor               #       4       ;       ECF EOR word
trns_codebuffer                 #       4       ;       Pointer to codebuffer
trns_spr_X_x0_y                 #       4       ;       Sprite X,Y at top coordinate of area
trns_spr_Y_x0_y                 #       4       ;            in 16.16 fixed point
trns_spr_inc_X_x                #       4       ;       Sprite increments
trns_spr_inc_Y_x                #       4       ;          ( change induced by single
trns_spr_inc_Y_y                #       4       ;            increments in screen x,y on
trns_spr_inc_X_y                #       4       ;            sprite X,Y )
trns_spr_lineptr                #       4       ;       Line to output onto
trns_spr_edgeblock              #       6*4*4   ;       Edge blocks, in format as below
trns_spr_edgeblock_end          #       4*6     ;        -1, to denote end of edge block
trns_ecf_ptr                    #       4       ;       Ecf pointer
trns_masking_word               #       4       ;       Masking word for > eight bit per pixel
trns_comp_mask_offset           #       4       ;       used to point at 1bpp mask data
trns_comp_spr_mask_width        #       4       ;       1bpp mask equivalent of spr_width
trns_comp_mask_base             #       4       ;       1bpp mask adjustment to mask data
trns_asm_workspace              #       4       ;       assembler R12
trns_spr_vars_end               *       :INDEX:@

; The edge blocks are stored in a similar fashion to Draw Quick Fill, and the code is mainly a copy
; of that. The actual layout of the blocks is as follows:
;   Offset 0  : Flag word. Top two bits specify direction of line in the X-axis (01=positive,1x=negative)
;                          Bottom two bits specify whether edge is active (01), not yet active (00), or dead (11)
;      The next 5 words are dependent on the flags. For active edges:
;   Offset 4  : Lower Y coordinate (in 256ths pixels, bottom of screen is 0) of edge. The line is deactivated
;                 after reaching this Y coordinate
;   Offset 8  : ABS(deltaX) for the line, in 256ths of a pixel
;   Offset 12 : ABS(deltaY) for the line, in 256ths of a pixel
;   Offset 16 : Bresenham error value for the pixel
;   Offset 20 : Current X coordinate of the point (in pixels)
;       For inactive edges:
;   Offset 4  : Lower X coordinate (256ths of pixel)
;   Offset 8  : Lower Y coordinate
;   Offset 12 : Upper X coordinate
;   Offset 16 : Upper Y coordinate
trns_activated          *       2_0001
trns_deactivated        *       2_0010


trns_xsize              RN      0 ; Top 16 bits only.           Used throughout the compiled loop
trns_spr_left           RN      0 ; Bottom 16 bits only.        Used throughout the compiled loop
trns_scr_lx             RN      0 ;                             Used outside the loop
trns_spr_start          RN      1 ;                             Used throughout the loop
trns_scr_rx             RN      1 ;                             Used outside the loop
trns_offset             RN      2 ;                             Used throughout the loop
trns_scr_y              RN      2 ;                             Used outside the loop
trns_X                  RN      3 ;                             Used throughout the loop
trns_X_x0_y             RN      3 ;                             Used outside the loop
trns_Y                  RN      4 ;                             Used throughout the loop
trns_Y_x0_y             RN      4 ;                             Used outside the loop
trns_inc_X_x            RN      5 ;                             Used throughout the loop & outside the loop
trns_inc_Y_x            RN      6 ;                             Used throughout the loop & outside the loop
trns_byte_width         RN      7 ;                             Used throughout the loop
trns_inc_X_y            RN      7 ;                             Used outside the loop
trns_spr_height         RN      8 ; Top 16 bits only.           Used throughout the compiled loop
trns_spr_right          RN      8 ; Bottom 16 bits only.        Used throughout the compiled loop
trns_inc_Y_y            RN      8 ;                             Used outside the loop
trns_out_ptr            RN      9 ;                             Used throughout the loop
trns_line_ptr           RN      9 ;                             Used outside the loop
trns_out_word           RN      10;                             Used throughout the loop
trns_vertex_ptrs        RN      10;                             Used outside the loop
trns_out_mask           RN      11;                             Used throughout the loop
trns_dummy11            RN      11;                              (dummy register - used outside the loop)
trns_out_x              RN      12;                             Used on entry to the compiled loop
trns_workspace_ptr      RN      12;                             Workspace pointer
trns_dummy12            RN      12;                              (dummy register - used everywhere)
trns_in_pixel           RN      14;                             Used in the middle to end of loop
trns_dummy14            RN      14;                              (dummy register - used everywhere)

        MACRO
$label  DivRem2 $rc, $ra, $rb, $rtemp
$label
        [       debugtr
        TEQ     $rb,#0
        SWIEQ   OS_BreakPt
        ]
        MOV     $rtemp, $rb
        CMP     $rtemp, $ra, LSR #1
01
        MOVLS   $rtemp, $rtemp, LSL #1
        CMPLS   $rtemp, $ra, LSR #1
        BLS     %BT01
        MOV     $rc, #0
02
        CMP     $ra, $rtemp
        SUBCS   $ra, $ra, $rtemp
        ADC     $rc, $rc, $rc
        MOV     $rtemp, $rtemp, LSR #1
        CMP     $rtemp, $rb
        BCS     %BT02
        MEND

 [ usemull
        ! 0, "Using SMULL - StrongARM or later only"
 ]

        MACRO
        SSmultD $ra,$rb,$rl,$rh
        ; Asserts to check requirements always meet both options
        ASSERT  $rh = $rl + 1
        ASSERT  $ra <= R8
        ASSERT  $rb <= R8
        ASSERT  $rl <= R7
 [ usemull
    [ $ra = $rl :LOR: $ra = $rh
        ! 0, "Register clash avoided in SSmultD"
        MOV     R14, $ra
        SMULL   $rl,$rh,R14,$rb
    |
        SMULL   $rl,$rh,$ra,$rb
    ]
 |
        BL      arith_SSmultD
        DCB     $ra,$rb,$rl,0
 ]
        MEND


        MakeSpriteErrorBlock BadFlags,,BadFlgs
        MakeSpriteErrorBlock BadCoordBlock,,BadCBlk
        MakeSpriteErrorBlock BadSourceRectangle,,BadRect
        MakeSpriteErrorBlock BadTransformation,,BadTfrm

badcoordblock
        ADR     R0, ErrorBlock_BadCoordBlock
        addr    r1, Title
        BL      copy_error_one                  ; Always sets the V bit
        B       exitbiggie

nullareasource
        ADR     R0, ErrorBlock_BadSourceRectangle
        addr    r1, Title
        BL      copy_error_one                  ; Always sets the V bit
        B       exitbiggie

badtransformation
        ADR     R0, ErrorBlock_BadTransformation
        addr    r1, Title
        BL      copy_error_one                  ; Always sets the V bit
        B       exitbiggie

        GBLA    flg_matrix
        GBLA    flg_coordblock
flg_matrix      SETA    1
flg_coordblock  SETA    2

Go_PlotMaskTransformed
        Push    "R1-R9,LR"
; Pretend its a GCOL 8 - use sprite's mask if it has one
        MOV     R5,#8
; No colour translation
        MOV     R7,#0
        B       %FT01

Go_PutSpriteTransformed
        Push    "R1-R9,LR"
01
        Debug   tr,"Draw sprite: R0,R1,R2 =",R0,R1,R2
        Debug   tr,"Coords, gcol, &scale, &ttr =",R3,R4,R5,R6,R7

        CLRPSR  I_bit, R14              ; re-enable interrupts

        MOV     R14, R5, LSR #4
        STR     R14, trns_flags2
        BIC     R14, R14, #flg2_translucency
        BICS    R14, R14, #flg2_ignorettr + flg2_widetrans + flg2_ditheron + flg2_colourmap
        ADRNE   R0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one          ; Always sets the V bit
        BVS     exitbiggie

        AND     R5,R5,#&0F              ; only bottom 4 bits are interesting

        BICS    R14, R3, #flg_matrix:OR:flg_coordblock  ; Check for legal flags
        ADRNE   R0, ErrorBlock_BadFlags
        addr    r1, Title, NE
        BLNE    copy_error_one          ; Always sets the V bit
        BVS     exitbiggie

; see if reason code indicated a sprite name or sprite pointer in R2

        BL      findsprite              ; R2 --> sprite

        MOVVC   R1,R2                   ; now R1 --> sprite

; read input/output mode variables

        BLVC    readvduvars
        LDRVC   R0,[R1,#spMode]         ; get sprite's original mode
        STRVC   R0,save_mode            ; save mode for C code to use
        STRVC   R1,save_sprite          ; save sprite too
        MOVVC   R14,R0,LSR #27

        STRVC   R14,save_spr_type       ; and derive the sprite type from it
        BLVC    readspritevars
        BVS     exitbiggie

        MOV     R8,#0                   
        STR     R8,calibration_table    ; no printer calibration table
        LDR     r14, trns_flags2
        TST     r14, #flg2_translucency
        MOVEQ   r14, #0
        MOVNE   r14, #1                 ; set up translucency blending
        TST     r0, #&80000000          ; alpha mask?
        LDREQ   r0, save_inmodeflags
        TSTEQ   r0, #ModeFlag_DataFormatSub_Alpha ; or alpha channel?
        LDRNEB  r0, spritecode
        TSTNE   R5,#8                   ; and masking enabled?
        TEQNE   r0, #SpriteReason_PlotMaskTransformed ; and not plotting mask?
        ORRNE   r14, r14, #2            ; set up alpha channel/mask blending
        STR     r14, blending
        CMP     r14, #0                 ; blending enabled?
        BICNE   r5, r5, #7              ; then GCOL not allowed
        CMP     R7,R7,ASR #31           ; documented as <=0 being none - now accept 0 or -1
        MOVEQS  R7,#0                   ; 0 ==> no translation
        BL      preparettr

; adapt mode variables intelligently (account for double pixel modes)

        LDR     R8, Log2bpc
        LDR     R9, Log2bpp
        SUB     R8, R8, R9
        LDR     R0, gwx0
        MOV     R0, R0, ASL R8
        STR     R0, gwx0
        LDR     R0, gwx1
        ADD     R0, R0, #1
        MOV     R0, R0, ASL R8
        STR     R0, gwx1

; Valid registers: R1 - ptr to sprite?, R3 - flags, R4 -> coordinate block, R5 GCOL, R6->matrix/coords
;        Debug   tr,"Read VDU and sprite:",#gwx0,#gwy0,#gwx1,#gwy1,#orgx,#orgy
;        Debug   tr,"Pointer to sprite:",R1
; Get coordinate block

        LDR     R2, save_inlog2bpp
        TST     R3, #flg_coordblock
        BNE     %FT01

; (whole sprite R0 - left, R8 - top y, R9 - right, R14 - bottom)

        LDR     R14, save_spr_type
        CMP     R14, #0
        LDREQ   R0, [R1, #spLBit]
        MOVEQ   R0, R0, ASR R2
        MOVNE   R0, #0                  ; new format sprites don't have any lh wastage
        LDR     R8, [R1, #spHeight]
        ADD     R8, R8, #1
        LDR     R9, [R1, #spRBit]
        RSB     R9, R9, #31
        LDR     R4, [R1, #spWidth]
        ADD     R4, R4, #1
        RSB     R9, R9, R4, LSL#5
        MOV     R9, R9, ASR R2
        MOV     R14, #0
        B       %FT02
01

; Check area passed in

        LDMIA   R4, {R0,R8,R9,R14}

; If using a matrix then clip source rectangle to sprite

        TST     R3, #flg_matrix
        BNE     %FT03
        CMP     R8, #0
        MOVLT   R8, #0
        CMP     R14, #0
        MOVLT   R14, #0
        LDR     R4, [R1, #spHeight]
        ADD     R4, R4, #1
        CMP     R8, R4
        MOVGT   R8, R4
        CMP     R14, R4
        MOVGT   R14, R4
        CMP     R0, #0
        MOVLT   R0, #0
        CMP     R9, #0
        MOVLT   R9, #0

        LDR     R4, [R1, #spLBit]
        ADD     R0, R0, R4, LSR R2
        ADD     R9, R9, R4, LSR R2
        LDR     R4, [R1, #spRBit]
        RSB     R4, R4, #31
        LDR     R10, [R1, #spWidth]
        ADD     R10, R10, #1
        RSB     R4, R4, R10, LSL#5

        CMP     R0, R4, LSR R2
        MOVGT   R0, R4, LSR R2
        CMP     R9, R4, LSR R2
        MOVGT   R9, R4, LSR R2
        CMP     R0, R9
        CMPNE   R8, R14
        BEQ     nullareasource
        B       %FT02
03

; If not using a matrix then check valid source area

        CMP     R0, R9
        CMPNE   R8, R14
        BEQ     nullareasource
        CMP     R8, #0
        CMPGE   R14, #0
        BLT     badcoordblock
        LDR     R4, [R1, #spHeight]
        ADD     R4, R4, #1
        CMP     R8, R4
        CMPLE   R14, R4
        BGT     badcoordblock
        CMP     R0, #0
        CMPGE   R9, #0
        BLT     badcoordblock

        LDR     R4, [R1, #spLBit]
        ADD     R0, R0, R4, LSR R2
        ADD     R9, R9, R4, LSR R2
        LDR     R4, [R1, #spRBit]
        RSB     R4, R4, #31
        LDR     R10, [R1, #spWidth]
        ADD     R10, R10, #1
        RSB     R4, R4, R10, LSL#5

        CMP     R0, R4, LSR R2
        CMPLE   R9, R4, LSR R2
        BGT     badcoordblock
02
        TST     R3, #flg_matrix
        BNE     coords_passed_in

; Valid registers: R0,R8,R9,R14 - source rect, R1 - ptr to sprite, R5 GCOL, R6->matrix/coords
; Set up input path for draw - move to R0,R8, move to R9,R14, end path

        Push    "R0,R1,R2,R3,R4,R5,R7,R8,R9,R10,R11,R12,R14"

; The X min/max coordinates generated above are pixel offsets into the sprite
; data, including any required lefthand wastage offset. But when generating
; the path block we want to ignore lefthand wastage to avoid sprites with
; wastage being rendered at an offset.

        LDR     R11, save_spr_type
        CMP     R11, #0
        LDREQ   R11, [R1, #spLBit]
        SUBEQ   R0, R0, R11, ASR R2     ; adjust left edge by wastage
        SUBEQ   R9, R9, R11, ASR R2     ; adjust right edge by wastage

        LDR     R11, inlog2px
        ADD     R11, R11, #8
        MOV     R1, R0, ASL R11         ; R1 = R0 scaled x
        MOV     R9, R9, ASL R11         ; R9 = R9 scaled x

        LDR     R11, inlog2py
        ADD     R11, R11, #8
        MOV     R8, R8, ASL R11         ; R8 = R8 scaled y
        MOV     R3, R14, ASL R11        ; R3 = R14 scaled y

        SUB     sp, sp, #64             ; Space for a path block
        MOV     R10, SP

        MOV     R11, #2
        MOV     R0, #2
        STMIA   R10!, {R0,R1,R8}        ; Move R1, R8.
        STMIA   R10!, {R0,R9}           ; Move R9,
        STMIA   R10!, {R8,R11}          ; R8. Move
        MOV     R11, #0
        STMIA   R10!, {R1,R3,R11}       ; R1, R3. End.

; Transform the path

        MOV     R0, SP
        MOV     R1, #0
        MOV     R2, R6
        MOV     R3, #0
        SWI     XDraw_TransformPath
        ADDVS   sp, sp, #64+4
        Pull    "R1,R2,R3,R4,R5,R7,R8,R9,R10,R11,R12,R14",VS
        BVS     exitbiggie

        ADD     R10, SP, #4             ; Get the transformed path (skipping 'Move')
        LDMIA   R10!, {R0,R3,R4,R6,R8,R9,R11,R14}
        ADR     R10, save_outoffset
        STMIA   R10!, {R0,R3,R6,R8}
        ADD     R6, R6, R11
        ADD     R8, R8, R14
        SUB     R6, R6, R0
        SUB     R8, R8, R3
        STMIA   R10!,{R6,R8,R11,R14}

; Recover R6
        ADR     R6, save_outoffset
        ADD     sp, sp, #64
        Pull    "R0,R1,R2,R3,R4,R5,R7,R8,R9,R10,R11,R12,R14"

; Make Y values offset from the top of the sprite, not the bottom

coords_passed_in
        LDR     R2, [R1, #spHeight]
        ADD     R2, R2, #1
        SUB     R8, R2, R8
        SUB     R14, R2, R14

; Get R4 = distance from top of sprite, R2 = height of sprite, and set R8,R14 to be offset from R4

        SUBS    R2, R8, R14
        RSBMI   R2, R2, #0
        MOVMI   R4, R8
        MOVPL   R4, R14
        SUB     R8, R8, R4
        SUB     R14, R14, R4

; Store height, left, right of sprite for inner loop

        SUB     sp, sp, #trns_spr_vars_end
        STR     R12, trns_asm_workspace
        CMP     R9, R0
        ORRGT   R10, R9, R2, LSL#16
        ORRLE   R10, R0, R2, LSL#16
        STR     R10, trns_comp_spr_height  ;       Height in top 16 bits, right side in bottom 16 bits
        STRGT   R0, trns_comp_spr_left    ;       Left side in bottom 16 bits (measurements in pixels)
        STRLE   R9, trns_comp_spr_left    ;       Left side in bottom 16 bits (measurements in pixels)

; Add R4*sprite_byte_width to sprite_pixel_data_start to give top of sprite, and store for loop


        LDR     R2, [R1, #spImage]
        LDR     R10, [R1, #spWidth]
        Debug   ag,"spWidth is",R10
        Debug   ag,"sprite is at",R1
        ADD     R10, R10, #1
        MOV     R10, R10, LSL#2
        MLA     R11, R10, R4, R2
        ADD     R11, R11, R1
        STR     R11, trns_comp_spr_start

        LDR     R2,[r1,#spMode]
        Debug   ag,"spMode is",R2

; and we have to do the same for the mask data now
; for now we just save the R4 value and deal with it once we have the mask
; equivalent of spWidth computed for the mask

        STR     R4, trns_comp_mask_base

; Work out byte width << 3-input_bpp, and store for loop

        LDR     R4, save_inlog2bpp
        CMP     R4, #4
        BCC     %FT89

        SUB     R4, R4, #3
        MOV     R11, R10, LSL #3
        MOV     R10, R10, LSR R4
        B       %FT88
89
        RSB     R4, R4, #3
        MOV     R11, R10, LSL #3
        MOV     R10, R10, LSL R4
88

        STR     R10, trns_comp_spr_byte_width

        TST     R2, #&80000000
        MOVNE   R10, R10, LSL #3

        ANDS    R11, R10, #&1F
        MOVNE   R11, #32
        ADD     R11, R11, R10
        BIC     R11, R11, #&1F

        TST     R2, #&80000000
        MOVNE   R11, R11, LSR #3
        Debug   ag,"mask_width is",R11

        STR     R11, trns_comp_spr_mask_width   ; used only for 1bpp/8bpp masks

        ;the mask_base was used earlier for the number of rows to go into the
        ;data, so now we turn that into a byte offset

        LDR     R10, trns_comp_mask_base        ; recover row number
        MUL     R10, R11, R10                   ; convert to offset (pixels)
        MOVEQ   R10, R10, LSR #3                ; convert to bytes for 1bpp
        STR     R10, trns_comp_mask_base

; Get mask offset and store ttr pointer (clear mask GCOL bit if there is no mask)

        LDR     R10, BPP
        LDR     R7, ColourTTR
        STR     R7, trns_comp_spr_ttr

        SUB     R10, R10,#1
        MOV     R11, #1:SHL:31
        MOV     R11, R11, ASR R10
        STR     R11, trns_masking_word                  ; suitable mask for pixels
        Debug   tr,"trns_masking_word",R11

        LDR     R10, [R1, #spTrans]
        LDR     R11, [R1, #spImage]

        Debug   ag,"trans and image offsets",R10,R11

        SUBS    R11, R10, R11
        BICEQ   R5, R5, #8                 ; no mask, so can't do a plot with b3 set

        Debug   ag,"trans minus image",R11

        LDR     R4, save_inlog2bpp
        CMP     R4, #4
        RSBCC   R4, R4, #3
        SUBCS   R4, R4, #3
        MOVCC   R11, R11, LSL R4
        MOVCS   R11, R11, LSR R4

        ; R4 is finished with now, so used as a working register for the mask stuff

        LDR     R10,[R1,#spTrans]             ; re-fetch offset to mask
        ADD     R10,R10,R1                    ; turn into absolute address
        LDR     R4, trns_comp_mask_base       ; fetch byte offset within 1bpp mask data
        ADD     R10,R10,R4                    ; include it
        STR     R10,trns_comp_mask_base       ; and store back the final result
        Debug   ag,"mask_base is",R10

        STR     R11, trns_comp_spr_masko
        Debug   ag,"stored masko as",R11

        Debug   tr,"Coordinate block:",R0,R8,R9,R14
        Debug   tr,"Mask offset:",#trns_comp_spr_masko
        Debug   tr,"Flags, GCOL, &Screen block, &TTR",R3, R5, R6, R7
        Debug   tr,"Height/right, left, spr_start, spr_byte_width",#trns_comp_spr_height,#trns_comp_spr_left,#trns_comp_spr_start,#trns_comp_spr_byte_width

; Copy the coordinate block
; Valid registers: R0,R8,R9,R14 - source rect, R1 - ptr to sprite, R5 GCOL, R6->matrix/coords, R7->ttr
; copy coordinates, adding graphics origin

        Push    "R1,R5,R7,R12"
        Push    "R0,R8,R9,R14"
        ADR     R0, trns_spr_xcoords + 4*8

; get O.S. to pixel shift (account for double pixel modes)

        LDR     R1, log2px
        LDR     R2, Log2bpp
        ADD     R1, R1, R2
        LDR     R2, Log2bpc
        SUB     R1, R1, R2
        LDR     R2, log2py

; get graphics origin

        LDR     R3, orgx
        LDR     R4, orgy

; get coordinates

        LDMIA   R6, {R5,R6,R7,R8,R9,R10,R11,R12}

; x coords

        ADD     R14, R7, R11
        SUB     R14, R14, R5
        CMP     R14, R9
        Pull    "R0,R8,R9,R14",NE
        Pull    "R1,R5,R7,R12",NE
        ADDNE   sp, sp, #trns_spr_vars_end
        BNE     badtransformation
        ADD     R5, R5, R3, LSL#8
        ADD     R7, R7, R3, LSL#8
        ADD     R9, R9, R3, LSL#8
        ADD     R11, R11, R3, LSL#8
        MOV     R5, R5, ASR R1
        MOV     R7, R7, ASR R1
        MOV     R9, R9, ASR R1
        MOV     R11, R11, ASR R1
        STMIA   R0!, {R5,R7,R9,R11}

; y coordinates

        ADD     R14, R8, R12
        SUB     R14, R14, R6
        CMPNE   R14, R10
        Pull    "R0,R8,R9,R14",NE
        Pull    "R1,R5,R7,R12",NE
        ADDNE   sp, sp, #trns_spr_vars_end
        BNE     badtransformation
        ADD     R6, R6, R4, LSL#8
        ADD     R8, R8, R4, LSL#8
        ADD     R10, R10, R4, LSL#8
        ADD     R12, R12, R4, LSL#8
        MOV     R6, R6, ASR R2
        MOV     R8, R8, ASR R2
        MOV     R10, R10, ASR R2
        MOV     R12, R12, ASR R2
        STMIA   R0!, {R6,R8,R10,R12}

        Debug tr,"Transformed coords are:",R5,R6,R7,R8
        Debug tr,"Transformed coords are:",R9,R10,R11,R12

; Get determinant

        SUB     R9, R7, R5      ; x1
        SUB     R10, R11, R5     ; x2
        SUB     R11, R8, R6      ; y1
        SUB     R12, R12, R6     ; y2

        Debug tr,"x1,x2,y1,y2",R9,R10,R11,R12

; R4,5 = x1 * y2

        MOV     R0, R9
        MOV     R1, R12
        SSmultD R0,R1,R4,R5

; R6,7 = x2 * y1

        MOV     R0, R10
        MOV     R1, R11
        SSmultD R0,R1,R6,R7

; R4,R5 = x1*y2 - x2*y1 (48.16 precision)

        SUBS    R4, R4, R6
        SBC     R5, R5, R7

        Debug tr,"R4,R5,R6,R7:",R4,R5,R6,R7
; R4,R5 = x1*y2 - x2*y1 / 4 (48.14 precision)

        MOV     R4, R4, LSR#2
        ORR     R4, R4, R5,LSL#30
        MOV     R5, R5, ASR#2

; R6,R7 = 1 / (x1*y2 - x2*y1) (16.48 precision)

        TEQ     R4, #0
        TEQEQ   R5, #0
        MOVEQ   R6, #0
        MOVEQ   R7, #0
        BEQ     trns_division_by_zero
        MOV     R0, #0
        MOV     R1, #&40000000
        Debug tr,"Dividing:",R0,R1,R4,R5
        mextralong_divide R6,R7,R0,R1,R4,R5,R2,R3,R8
        Debug tr,"Gives:",R6,R7

trns_division_by_zero
        LDMFD   sp, {R0,R1,R2,R3}
        SUBS    R2, R2, R0
;        RSBMI   R2, R2, #0
        SUBS    R3, R3, R1
;        RSBMI   R3, R3, #0

; spr_inc_X_x = det*y2 [ * xsize ]

        MOV     R0, R12
        MOV     R1, R2
        BL      produce_increment
        MOV     R12, R4

; spr_inc_Y_x = det*-y1 [ * ysize ]

        RSB     R0, R11, #0
        MOV     R1, R3
        BL      produce_increment
        MOV     R11, R4

; spr_inc_X_y = det*-x2 [ * xsize ]

        RSB     R0, R10, #0
        MOV     R1, R2
        BL      produce_increment
        MOV     R10, R4

; spr_inc_Y_y = det*x1 [ * ysize ]

        MOV     R0, R9
        MOV     R1, R3
        BL      produce_increment
        MOV     R9, R4

; Store increments

        STR     R12, trns_spr_inc_X_x + 8*4
        STR     R11, trns_spr_inc_Y_x + 8*4
        STR     R10, trns_spr_inc_X_y + 8*4
        STR     R9, trns_spr_inc_Y_y + 8*4
        Pull    "R0,R8,R9,R14"
        Pull    "R1,R5,R7,R12"
        Debug   tr,"Coordinate block:",R0,R8,R9,R14

; thats all the horrid fixed point stuff out of the way
; Find the top y coordinate

        ADR     R3, trns_spr_ycoords
        LDMIA   R3!, {R4,R6,R10,R11}
        CMP     R6, R4
        MOVGT   R4, R6
        CMP     R10, R4
        MOVGT   R4, R10
        CMP     R11, R4
        MOVGT   R4, R11
        MOV     R2, R8

; Valid registers: R5 GCOL, R7->ttr, R4 - maximum ycoordinate of area
;                                       Get top y coordinate of centre of line being drawn in R1

        SUB     R1, R4, #128
        MOV     R1, R1, ASR#8
        LDR     R3, gwy1
        CMP     R1, R3
        MOVGT   R1, R3
        STR     R1, save_ycoord
        Debug tr,"Top coordinate on screen (PIXELS) is:",R1

;                                       Get address of line on screen

        LDR     R3, ywindlimit
        SUB     R3, R3, R1
        LDR     R8, screenstart
        LDR     R6, linelength
        MLA     R6, R3, R6, R8
        STR     R6, trns_spr_lineptr
;                                       Get ECF pointer
        LDR     R6, vdu_bgecforaeor
        AND     R3, R3, #7
        ADD     R6, R6, R3,LSL#3
;        Debug   tr, "Ecf pointer is:",R6
        STR     R6, trns_ecf_ptr

;spr_X_x0_y% += ((screen_y%-y(0)) * (!asm_spr_inc_X_y)) / 256
; screen_y%-y(0) = R6.R4

        MOV     R1, R1, ASL#8
        ADD     R1, R1, #128
        LDR     R4, trns_spr_ycoords
        SUB     R4, R1, R4
;        Debug tr,"scry%-y0:",R4
        MOV     R6, R4, ASR#16
        BIC     R4, R4, R6, LSL#16

; inc_X_y = R8.R9

        LDR     R14, trns_spr_inc_X_x
;        Debug tr,"IncXx",R14
        LDR     R14, trns_spr_inc_X_y
;        Debug tr,"incXy,Xx0",R14,R0
        MOV     R8, R14, ASR#16
        BIC     R9, R14, R8, LSL#16

; multiply

        MUL     R10, R9, R6
        MLA     R10, R8, R4, R10
        MUL     R11, R6, R8
        MUL     R14, R9, R4
        MOV     R14, R14, LSR#8
        ADD     R10, R14, R10,LSL #8
        ADD     R0, R10, R0,LSL #16
        ADD     R0, R0, R11,LSL#24

        Debug tr,"Xx0y:",R0
;spr_Y_x0_y% += ((screen_y%-y(0)) * (!asm_spr_inc_Y_y)) / 256
; inc_Y_y = R8.R9

        LDR     R14, trns_spr_inc_Y_y
        Debug tr,"incYy=",R14
        MOV     R8, R14, ASR#16
        BIC     R9, R14, R8, LSL#16
        MUL     R10, R9, R6
        MLA     R10, R8, R4, R10
        MUL     R11, R6, R8
        MUL     R14, R9, R4
        MOV     R14, R14, LSR#8
        ADD     R10, R14, R10,LSL #8
        ADD     R2, R10, R2,LSL#16
        ADD     R2, R2, R11,LSL#24

; Valid registers: R0,R2 - X_x0_y/Y_x0_y, R5 GCOL, R7->ttr

        STR     R0, trns_spr_X_x0_y
        STR     R2, trns_spr_Y_x0_y
        Debug tr,"Top corner (w.r.t. sprite) is:",R0,R2

; Now compile the code

        BL      compile_transform_code
return_from_sprtrans_compiler      
        MOV     R10, R0
        STR     R10, trns_codebuffer
        Debug tr,"Code compiled:",R10

; Now, set up the edges in the edge block

        ADR     R0, trns_spr_edgeblock
        MOV     R1, #0
        ADR     R2, trns_spr_xcoords
        LDMIA   R2, {R2,R3,R4,R5, R6,R7,R8,R9}

; Edge 0->1

        CMP     R6, R7
        STMGTIA R0!,{R1,R3,R7}
        STMGTIA R0!,{R2,R6}
        STMLEIA R0!,{R1,R2,R6}
        STMLEIA R0!,{R3,R7}

; Edge 1->2

        ADD     R0, R0, #8
        CMP     R7, R8
        STMGTIA R0!,{R1,R4,R8}
        STMGTIA R0!,{R3,R7}
        STMLEIA R0!,{R1,R3,R7}
        STMLEIA R0!,{R4,R8}

; Edge 0->3

        ADD     R0, R0, #8
        CMP     R6, R9
        STMGTIA R0!,{R1,R5,R9}
        STMGTIA R0!,{R2,R6}
        STMLEIA R0!,{R1,R2,R6}
        STMLEIA R0!,{R5,R9}

; Edge 3->2

        ADD     R0, R0, #8
        CMP     R9, R8
        STMGTIA R0!,{R1,R4,R8}
        STMGTIA R0!,{R5,R9}
        STMLEIA R0!,{R1,R5,R9}
        STMLEIA R0!,{R4,R8}
        ADD     R0, R0, #8
        MVN     R1, #0
        STR     R1, [R0]

;;        Debug tr,"Active edge list:",#trns_spr_edgeblock,#trns_spr_edgeblock+4,#trns_spr_edgeblock+8,#trns_spr_edgeblock+12,#trns_spr_edgeblock+16,#trns_spr_edgeblock+20,#trns_spr_edgeblock+24
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+28,#trns_spr_edgeblock+32,#trns_spr_edgeblock+36,#trns_spr_edgeblock+40,#trns_spr_edgeblock+44,#trns_spr_edgeblock+48,#trns_spr_edgeblock+52
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+56,#trns_spr_edgeblock+60,#trns_spr_edgeblock+64,#trns_spr_edgeblock+68,#trns_spr_edgeblock+72,#trns_spr_edgeblock+76,#trns_spr_edgeblock+80
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+84,#trns_spr_edgeblock+88,#trns_spr_edgeblock+92,#trns_spr_edgeblock+96,#trns_spr_edgeblock+100,#trns_spr_edgeblock+104,#trns_spr_edgeblock+108

; Get top Y coordinate

        LDR     R1, save_ycoord
        MOV     R11, #3

; Start loop - looping until all edges are deactivated or below Y coord

00
        LDR     R14, gwy0
        CMP     R1, R14
        BLT     trns_completed_drawing

; Activate any new edges, deactivate old ones (R11 = count of deactivated edges)

        ADR     R10, trns_spr_edgeblock
01
        LDMIA   R10, {R0,R5,R6,R7,R8,R9,R14}

; Checked all the edges?

        CMN     R0, #1
        BEQ     activated_all_edges

; If dead then ignore

        TST     R0, #trns_deactivated
        BNE     edge_inactive

; If active then shoule we deactivate it?

        TST     R0, #trns_activated
        BNE     edge_active

; Test for activation

        SUB     R14, R8, #128
        CMP     R1, R14, ASR #8
        BGT     edge_inactive

; Activate an edge

        SUB     R8, R8, #128
        SUB     R6, R6, #128
        ORR     R0, R0, #trns_activated

; Calculate R3=ABS(deltaX) and R4=ABS(deltaY).

        SUBS    R3,R7,R5
        RSBLT   R3,R3,#0
        SUB     R4,R8,R6                ;Must be correct sign already - lines are sorted wrt Y coords.

; Record direction of line as 1 or -1 in top two bits of flags

        ORR     R0,R0,#&40000000        ;line goes rightwards
        ORRGE   R0,R0,#&80000000        ;Processor Status preserved from above - GE if line goes leftwards

; Now calculate target Y co-ordinate - the line must stop after this Y value is reached.

        MOV     R2,R6,ASR #8
        ADD     R2,R2,#1
        CMP     R1, R2
        MOVLT   R0, #trns_deactivated
        BLT     edge_inactive

; Valid registers: R0-flags, R1-current Y, R2-target Y, R3,R4-dX,dY,
;                  R7,R8-Upper x,y, R10-store for edge, R11-count of deactivated edges
; Now get Bresenham error in R6.

        AND     R14,R7,#&FF
        MOV     R7,R7,ASR #8
        ADD     R6,R3,R4                ;ABS(deltaX)+ABS(deltaY)
        CMP     R6,#&80000000:SHR:8
        BLO     out_qfill_spbres

; Only do complicated stuff if simple stuff will overflow

out_qfill_dpbres
        Push    "R0,R4,R5,R7"

; R7=-1,C=1 for leftward lines, R7=0,C=0 for rightward lines.

        MOVS    R7,R0,ASR #32

; Get R0=real sub-X coordinate on screen (R14=subpixel now)

        SUB     R0,R14,#128
        RSBCS   R0,R0,#0

; R4,R5 = R0*dY , R6,R7=R4,R5 -1 if leftward,+0 i rightward

        SSmultD R0,R4,R4,R5             ;subpixelX * ABS(deltaY) into R4,R5
        ADDS    R6,R4,R7                ;Accumulate into R6,R7
        ADC     R7,R5,R7

; R6,R7 += R0*dX

        AND     R0,R8,#255
        SSmultD R0,R3,R4,R5
        ADDS    R6,R4,R6
        ADC     R7,R5,R7

; Change error to full pixel instead of 256ths pixels

        MOV     R6,R6,LSR #8
        ORR     R6,R6,R7,LSL #24
        Pull    "R0,R4,R5,R7"
        B       out_qfill_bresdone

; Do simple stuff

out_qfill_spbres

; R6=-1,C=1 for leftward lines, R6=0,C=0 for rightward lines.

        MOVS    R6,R0,ASR #32

; Get R0=real sub-X coordinate on screen (R14=subpixel now)

        SUB     R14,R14,#128
        RSBCS   R14,R14,#0
        MLA     R6,R14,R4,R6            ;Accumulate subpixelX * ABS(deltaY)
        AND     R14,R8,#255
        MLA     R6,R14,R3,R6            ;Accumulate subpixelY * ABS(deltaX)
        MOV     R6,R6,ASR #8            ;Change units to full pixels

; Now R6=Bresenham value

out_qfill_bresdone
        MOV     R8,R8,ASR #8

; Now advance the edge until we're on the right scan line and the Bresenham
; value is negative.

        CMP     R1,R2                   ;Don't bother if we're below target Y
        BLT     out_qfill_doneclip
        SUBS    R8,R8,R1                ;Must set GT or EQ
        BLGT    out_qfill_fastclip
        CMP     R6,#0                   ;So this can only happen if R1 >= R2
out_qfill_Xcliploop
        ADDGE   R7,R7,R0,ASR #30        ;Advance in X direction as far as
        SUBGES  R6,R6,R4                ;  possible
        BGE     out_qfill_Xcliploop
out_qfill_doneclip
        ADD     R6,R6,R3

; Store flags,targetY,deltaX,deltaY

        STMIA   R10!,{R0,R2,R3,R4}
        STMIA   R10!, {R6,R7,R8}
        B       edge_no_store
edge_active

; If now below it then kill it

        CMP     R1, R5                  ; Check for deactivating the edge
        MOVLT   R0, #trns_deactivated
        SUBLT   R11, R11, #1
        ADD     R8,R8,R6                ;Adjust Bresenham value for Y move
edge_inactive
        STMIA   R10!, {R0,R5,R6,R7,R8,R9,R14}
edge_no_store
        B       %BT01
activated_all_edges
        CMP     R11, #0
        BLT     trns_completed_drawing

;;        Debug tr,"Active edge list:",#trns_spr_edgeblock,#trns_spr_edgeblock+4,#trns_spr_edgeblock+8,#trns_spr_edgeblock+12,#trns_spr_edgeblock+16,#trns_spr_edgeblock+20,#trns_spr_edgeblock+24
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+28,#trns_spr_edgeblock+32,#trns_spr_edgeblock+36,#trns_spr_edgeblock+40,#trns_spr_edgeblock+44,#trns_spr_edgeblock+48,#trns_spr_edgeblock+52
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+56,#trns_spr_edgeblock+60,#trns_spr_edgeblock+64,#trns_spr_edgeblock+68,#trns_spr_edgeblock+72,#trns_spr_edgeblock+76,#trns_spr_edgeblock+80
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+84,#trns_spr_edgeblock+88,#trns_spr_edgeblock+92,#trns_spr_edgeblock+96,#trns_spr_edgeblock+100,#trns_spr_edgeblock+104,#trns_spr_edgeblock+108
;;        Debug tr,"Number of active/not yet activated edges:",R11

; Move on all active lines

        ADR     R10, trns_spr_edgeblock
01
        LDMIA   R10!, {R0,R2,R3,R4,R6,R7,R8}
        CMN     R0, #1
        BEQ     trns_draw_line
        TST     R0, #trns_activated
        BEQ     %BT01

; R0-flags, R2 - target Y, R3 - deltaX, R4-deltaY
; R6-Bresenham error value, R7-current X

        SUB     R8,R7,R0,ASR #31        ;Calculate crossing X
        CMP     R1,R2                   ;Stop if already below target
        BLT     trns_deactivate_2
;        CMP     R4,R6,ASR #3            ;Use fast code?
;        BLLE    out_qfill_fasthoriz
        CMP     R6,#0                   ;Are we still below the edge?
02
        ADDGE   R7,R7,R0,ASR #30        ;Make X moves until we're above the
        SUBGES  R6,R6,R4                ;  edge, adjusting Bresenham value
        BGE     %BT02                   ;  for them
        STMDB   R10, {R0,R2,R3,R4,R6,R7,R8}
        B       %BT01

trns_deactivate_2
        MOV     R0, #trns_deactivated
        STMDB   R10, {R0,R2,R3,R4,R6,R7,R8}
        B       %BT01

; Now find the pair of lines which are active

trns_draw_line
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock,#trns_spr_edgeblock+4,#trns_spr_edgeblock+8,#trns_spr_edgeblock+12,#trns_spr_edgeblock+16,#trns_spr_edgeblock+20,#trns_spr_edgeblock+24
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+28,#trns_spr_edgeblock+32,#trns_spr_edgeblock+36,#trns_spr_edgeblock+40,#trns_spr_edgeblock+44,#trns_spr_edgeblock+48,#trns_spr_edgeblock+52
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+56,#trns_spr_edgeblock+60,#trns_spr_edgeblock+64,#trns_spr_edgeblock+68,#trns_spr_edgeblock+72,#trns_spr_edgeblock+76,#trns_spr_edgeblock+80
;;        Debug tr,"Active edge list:",#trns_spr_edgeblock+84,#trns_spr_edgeblock+88,#trns_spr_edgeblock+92,#trns_spr_edgeblock+96,#trns_spr_edgeblock+100,#trns_spr_edgeblock+104,#trns_spr_edgeblock+108
;;        Debug tr,"Number of active/not yet activated edges:",R11
        ADR     R10, trns_spr_edgeblock
01
        LDMIA   R10!, {R0,R2,R3,R4,R5,R6,R7}
        CMN     R0, #1
        BEQ     trns_completed_drawing
        TST     R0, #1
        BEQ     %BT01
01
        LDMIA   R10!, {R0,R2,R3,R4,R5,R6,R8}
        CMN     R0, #1
        BEQ     trns_completed_drawing
        TST     R0, #1
        BEQ     %BT01

; R6,R7 are x coords to plot between at current Y

        Push    "R1,R11,R12"
        MOV     trns_scr_lx, R7
        MOV     trns_scr_rx, R8
        ASSERT trns_scr_lx<>R6
        ASSERT trns_scr_y<>R6
        ASSERT trns_scr_y<>R7
        LDR     R14, trns_ecf_ptr + 3*4
        LDMIA   R14!, {trns_X_x0_y, trns_Y_x0_y}
        STR     trns_X_x0_y, trns_comp_ecf_ora + 3*4
        STR     trns_Y_x0_y, trns_comp_ecf_eor + 3*4
        LDR     trns_scr_y, vdu_bgecforaeor
        ADD     trns_scr_y, trns_scr_y, #64
        CMP     R14, trns_scr_y
        SUBGE   R14, trns_scr_y, #64
        MOV     trns_scr_y, R1
        STR     R14, trns_ecf_ptr + 3*4
        ADR     R14, trns_spr_X_x0_y + 3*4
        LDMIA   R14, {trns_X_x0_y,trns_Y_x0_y,trns_inc_X_x,trns_inc_Y_x,trns_inc_X_y,trns_inc_Y_y,trns_line_ptr}

;;        Debug tr,"Calling plotting routine: lx,rx,ty",trns_scr_lx, trns_scr_rx, trns_scr_y
;;        Debug tr,"incXx,Yx,Xy,Yy,lineptr",trns_inc_X_x,trns_inc_Y_x,trns_inc_X_y,trns_inc_Y_y,trns_line_ptr
;;        Debug tr,"X0Y0",trns_X_x0_y,trns_Y_x0_y

        BL      plot_and_calculate_row
        Pull    "R1,R11,R12"
        LDR     R14, linelength
        LDR     trns_line_ptr, trns_spr_lineptr
        ADD     trns_line_ptr, trns_line_ptr, R14
        STR     trns_line_ptr, trns_spr_lineptr
        LDR     trns_X_x0_y, trns_spr_X_x0_y
        LDR     trns_Y_x0_y, trns_spr_Y_x0_y
        LDR     trns_inc_X_y, trns_spr_inc_X_y
        LDR     trns_inc_Y_y, trns_spr_inc_Y_y
        SUB     trns_X_x0_y, trns_X_x0_y, trns_inc_X_y
        SUB     trns_Y_x0_y, trns_Y_x0_y, trns_inc_Y_y
        STR     trns_X_x0_y, trns_spr_X_x0_y
        STR     trns_Y_x0_y, trns_spr_Y_x0_y
        SUB     R1, R1, #1
        B       %BT00

trns_completed_drawing

; Update changed coordinate block?

        LDR     R14, changedbox
        LDR     R0, [R14], #4
        TST     R0, #1
        BEQ     trns_no_changed_box

; Get R6 = top y, R4 = bottom y

        LDR     R6, save_ycoord
        MOV     R4, R1

; Check top y was above gwy0, else no change to box

        LDR     R0, gwy0
        CMP     R6, R0
        BLT     trns_no_changed_box

; Find R3 = left x, R5 = right x

        ADR     R0, trns_spr_xcoords
        LDMIA   R0, {R3,R7,R8,R9}
        MOV     R5, R3
        CMP     R3, R7
        MOVGT   R3, R7
        CMP     R3, R8
        MOVGT   R3, R8
        CMP     R3, R9
        MOVGT   R3, R9
        CMP     R5, R7
        MOVLT   R5, R7
        CMP     R5, R8
        MOVLT   R5, R8
        CMP     R5, R9
        MOVLT   R5, R9

; Now convert from 256ths pixels to pixels, and clip to graphics window

        ADD     R3, R3, #128
        MOV     R3, R3, ASR #8
        ADD     R5, R5, #128
        MOV     R5, R5, ASR #8
        LDR     R0, gwx0
        LDR     R1, gwx1
        CMP     R3, R0
        MOVLT   R3, R0
        CMP     R5, R1
        MOVGT   R5, R1
        CMP     R3, R5
        BGT     trns_no_changed_box

; Unbodge double pixels

        LDR     R7, Log2bpc
        LDR     R8, Log2bpp
        SUB     R7, R7, R8
        MOVNE   R3, R3, LSL R7
        MOVNE   R5, R5, LSL R7
        ADD     R4, R4, #1

; Get original box and update it

        LDMIA   R14, {R0,R1,R2,R7}
        CMP     R0, R3
        MOVGT   R0, R3
        CMP     R1, R4
        MOVGT   R1, R4
        CMP     R2, R5
        MOVLT   R2, R5
        CMP     R7, R6
        MOVLT   R7, R6
        STMIA   R14, {R0,R1,R2,R7}

trns_no_changed_box
        ADD     sp, sp, #trns_spr_vars_end
        CLRV
        B       exitbiggie


; -------------------------------------------------------------
; - Routine to get increment in sprite due to x or y movement -
; -------------------------------------------------------------
; R0 - x or y distance
; R1 - size of sprite (width or height)
; R6,7 - 64 bit determinant (16.48 format)
; Result in R4

produce_increment
        Push    "R0-R3,R5-R12,R14"
        Debug tr,"Inputs:",R0,R1,R6,R7

; First split R6/7 into R4-R7

        MOVS    R3, R7, ASR #32
        BEQ     %FT01
        RSBS    R6, R6, #0
        RSC     R7, R7, #0
01
        MOV     R4, R7, LSR #16
        BIC     R5, R7, R4, LSL #16
        MOV     R7, R6, LSR #16
        BIC     R6, R6, R7, LSL #16

; Now check sign of R0, R3 = sign of product

        EORS    R3, R3, R0, ASR #32

; If R3<0 (i.e. product<0) then R1=-R1

        RSBMI   R1, R1, #0

; If R0<0 then R0=-R0

        RSBCS   R0, R0, #0

; Split R0

        MOV     R2, R0, LSR #16
        BIC     R0, R0, R2, LSL #16
        Debug tr,"Premultiply values:R0,R2,R1,R3:",R0,R2,R1,R3
        Debug tr,"Premultiply values:R4,R5,R7,R6:",R4,R5,R7,R6

; Now produce R8 = U0.6 + L2.6 + L0.7, R6 = U2.6 + U0.7 (inc. carries)

        MUL     R8, R0, R6
        MUL     R6, R2, R6
        MUL     R3, R0, R7
        ADDS    R3, R3, R6
        MOV     R6, R3, LSR #16
        ADDCS   R6, R6, #&10000
        ADDS    R8, R8, R3, LSL #16
        MOV     R8, R8, LSR #16
        ADC     R6, R6, #0
        Debug tr,"Stage 1:R6,R8",R6,R8

; Now produce R9 = L6 + L2.7 + L0.5, R7 = U6 + U2.7 + U0.5 (inc carries)

        MUL     R9, R0, R5
        MUL     R7, R2, R7
        ADDS    R3, R7, R9
        MOV     R7, R3, LSR #16
        ADDCS   R7, R7, #&10000
        ADD     R7, R7, R6, LSR #16
        MOV     R9, R3, LSL #16
        ADDS    R9, R9, R6, LSL #16
        MOV     R9, R9, LSR #16
        ADC     R7, R7, #0
        Debug tr,"Stage 2:R7,R9",R7,R9

; Now produce R10 = L7 + L2.5 + L0.4, R5 = U7 + U2.5 + U0.4 (inc. carries)

        MUL     R10, R0, R4
        MUL     R5, R2, R5
        ADDS    R3, R5, R10
        MOV     R5, R3, LSR #16
        ADDCS   R5, R5, #&10000
        ADD     R5, R5, R7, LSR #16
        MOV     R10, R3, LSL #16
        ADDS    R10, R10, R7, LSL #16
        MOV     R10, R10, LSR #16
        ADC     R5, R5, #0
        Debug tr,"Stage 3:R10,R5",R10,R5

; Now produce R11 = L5 + L2.4

        MLA     R11, R2, R4, R5
        MOV     R3, R11, LSR #16
        BIC     R11, R11, R3, LSL #16

; Now R11.R10.R9.R8 (sixteen bits each) = 256/Det*Size in 32.32 form
; So get R1 * R11.R10.R9.R8 into R4

        MUL     R8, R1, R8
        MUL     R9, R1, R9
        MUL     R10, R1, R10
        MUL     R11, R1, R11
        MOV     R4, R8, ASR #24
        ADD     R4, R4, R9, ASR #8
        ADD     R4, R4, R10, ASL #8
        ADD     R4, R4, R11, ASL #24

        ;bug fix, round up if necessary
        TST     R9,#&80
        ADDNE   R4,R4,#1

        Debug tr,"Output:R4",R4

        Pull    "R0-R3,R5-R12,PC"



; -----------------------------------
; - DrQfill routines required above -
; -----------------------------------
; Fast Y clipping routine

out_qfill_fastclip
        Push    "R1,R2,R7,LR"
        MOV     R7,R6,ASR #31           ;Sign-extend Bresenham value
        SSmultD R8,R3,R1,R2             ;(no. Y steps) * deltaX into R1,R2
        ADDS    R6,R6,R1                ;Accumulate into Bresenham value
        ADCS    R7,R7,R2
        MOVMI   R8,#0                   ;Check for still being to the right
        BMI     out_qfill_fastclipdone  ;  of the edge
        BL      arith_DSdivS            ;Divide by deltaY
        DCB     R6,R4,R8,0
        SSmultD R8,R4,R1,R2             ;(no. X steps) * deltaY into R1,R2
        SUB     R6,R6,R1                ;Not interested in high word!

out_qfill_fastclipdone
        Pull    "R1,R2,R7,LR"
        TEQ     R0,#0                   ;Move X co-ord. in right direction
        ADDPL   R7,R7,R8
        SUBMI   R7,R7,R8
        MOV     PC,LR

; Subroutine to advance an edge horizontally fast (i.e. using long division
; rather than division by repeated subtraction!)
;   Updates R6 and R7, corrupts R2 and R3, preserves flags & other registers

out_qfill_fasthoriz
        DivRem  R2,R6,R4,R3
        TEQ     R0,#0
        ADDPL   R7,R7,R2
        SUBMI   R7,R7,R2
        MOV     PC,LR

 [ :LNOT:usemull
; Subroutine to multiply two single precision signed numbers together and
; get a double precision result. The word following the BL should contain
; the numbers of the two operand registers in its bottom two bytes and the
; number of the register to take the ls part of the result in the next byte.
; The ms part of the result will go into the next register.
;   This routine will only work on registers R0-R8.

arith_SSmultD
        Push    "R0-R8"                 ;REMEMBER: need to stack R0-R8 so they can hold results
        RSB     R8,PC,PC                ;get embedded PSR flags into R8 - 26/32-bit mode neutral
        LDRB    R0,[R14,-R8]!           ;Get first operand; R14 := (R14 - PSR)
        LDR     R0,[R13,R0,LSL #2]
        LDRB    R1,[R14,#1]             ;Get second operand
        LDR     R1,[R13,R1,LSL #2]
        MOV     R4,R0,LSR #16           ;Split first operand into halves
        BIC     R3,R0,R4,LSL #16
        MOVS    R6,R1,LSR #16           ;Split second operand into halves
        BIC     R5,R1,R6,LSL #16
        MUL     R2,R3,R5                ;Produce low partial product
        MUL     R3,R6,R3                ;And middle partial products
        MUL     R5,R4,R5
        MULNE   R6,R4,R6                ;And high partial product
        ADDS    R3,R3,R5                ;Add middle partial products, dealing
        ADDCS   R6,R6,#&10000           ;  with overflow
        ADDS    R2,R2,R3,LSL #16        ;Add middle partial product sum into
        ADC     R6,R6,R3,LSR #16        ;  result
        TEQ     R0,#0                   ;Add cross products of operands and
        SUBMI   R6,R6,R1                ;  operand sign extensions into
        TEQ     R1,#0                   ;  result
        SUBMI   R6,R6,R0
        LDRB    R0,[R14,#2]             ;Store the result on the stack, to be
        ADD     R0,R13,R0,LSL #2        ;  picked up by the correct registers
        STMIA   R0,{R2,R6}
        Pull    "R0-R8"
        ADD     PC,R14,#4               ;Skip the argument word on return (don't use ADDS!)
 ]

; Subroutine to divide a double precision unsigned number by a single
; precision unsigned number, yielding a single precision unsigned result.
; The word following the BL should contain the number of the register holding
; the ls part of the dividend in its bottom byte; the ms part of the dividend
; is in the next register. The next byte of the word contains the number of
; the divisor register, and the next byte the number of the register in which
; to deposit the quotient.
;   This routine will only work on registers R0-R8. It assumes that the
; divisor is not zero, and that the quotient will not overflow.

arith_DSdivS
        Push    "R0-R8"
        RSB     R8,PC,PC                ;get embedded PSR flags into R8 - 26/32-bit mode neutral
        LDRB    R0,[R14,-R8]!           ;Get first operand; R14 := (R14 - PSR)
        ADD     R0,R13,R0,LSL #2
        LDMIA   R0,{R0,R1}
        LDRB    R2,[R14,#1]             ;Get second operand
        LDR     R2,[R13,R2,LSL #2]
        MOV     R3,#1                   ;Init. quotient with a sentinel bit

arith_DSdivS_loop
        ADDS    R0,R0,R0                ;Shift a bit up into the ms half of
        ADC     R1,R1,R1                ;  the dividend
        CMP     R1,R2                   ;Do trial subtraction, producing
        SUBCS   R1,R1,R2                ;  result bit in C
        ADCS    R3,R3,R3                ;Result bit into result, then loop
        BCC     arith_DSdivS_loop       ;  unless sentinel bit shifted out
        LDRB    R0,[R14,#2]             ;Store the result on the stack, to be
        STR     R3,[R13,R0,LSL #2]      ;  picked up by the correct registers
        Pull    "R0-R8"
        ADD     PC,R14,#4               ;Skip the argument word on return (don't use ADDS!)


; ---------------------------------------------
; - Routine to compile the code specified by  -
; - the GCOL action, in_bpp, out_bpp          -
; - translation table, and plotmask/putsprite -
; - options                                   -
; ---------------------------------------------
        IMPORT  sprtrans_compiler
compile_transform_code
; R5 = GCOL value (including mask bit)
        MOV     R0,R12              ; assembler workspace pointer
        ADRL    R1,ccompiler_space  ; above R12, space for me.
        ADRL    R2,ccompiler_end    ; end of space for me.
        MOV     R3,R5               ; GCOL action and mask bit

        Debug   gs,"R1,R5,R12 = ",R1,R5,R12
        MOV     R4,#0
        STR     R4,ccompiler_errptr ; in case of error exit
        ADD     R4,SP,#trns_spr_vars_end
        STR     R4,ccompiler_sp     ; in case of unexpected exit

        Debug   cc,"entering c code"
        MOV     SL,R12              ; will be left alone by compiled C - for debug routines above.
        BL      sprtrans_compiler   ; dive into the C (returns r0=compiled code)
        MOV     R12,SL              ; R12 is ip to a C prog, will have been trampled on - restore it.
        B       return_from_sprtrans_compiler

calc_row_stacked        *       4*4    ;       Number of bytes stacked in plot_and_calculate_row
plot_and_calculate_row
        Push    "R14"
        CMP     trns_scr_lx, trns_scr_rx
        Swap    trns_scr_lx, trns_scr_rx, GT
        LDR     trns_dummy14, gwx0
        CMP     trns_scr_lx, trns_dummy14
        MOVLT   trns_scr_lx, trns_dummy14
        LDR     trns_dummy14, gwx1
        CMP     trns_scr_rx, trns_dummy14
        MOVGT   trns_scr_rx, trns_dummy14
        CMP     trns_scr_lx, trns_scr_rx
        Pull    "PC",GE
;                                       Get sprite offsets for left of current y line
;                                       First get dummy11 = scr_lx - x(0)
        LDR     trns_dummy11, trns_spr_xcoords + calc_row_stacked
;        Debug tr,"X,Y(x0,y0), incXx, incYy",trns_X_x0_y,trns_Y_x0_y,trns_inc_X_x,trns_inc_Y_x
;        Debug tr,"coords:",trns_scr_lx, trns_scr_rx,trns_scr_y,trns_dummy11
        MOV     trns_dummy11, trns_dummy11, ASR#8
        SUB     trns_dummy11, trns_scr_lx, trns_dummy11
; X = ((screen_lx%-x(0)) * (inc_X_x)) + X_x0_y
        MLA     trns_X, trns_dummy11, trns_inc_X_x, trns_X_x0_y
; Y = ((screen_lx%-x(0)) * (spr_inc_Y_x)) + Y_x0_y
        MLA     trns_Y, trns_inc_Y_x, trns_dummy11, trns_Y_x0_y
;                                       Get the x posn and x size for the plot
        SUB     trns_dummy14, trns_scr_rx, trns_scr_lx
        MOV     trns_out_x, trns_scr_lx
;                                       Load the compile routine registers - HERE
        ADR     trns_spr_start, trns_comp_spr_left + calc_row_stacked
        LDMIA   trns_spr_start, {trns_xsize, trns_spr_start, trns_byte_width, trns_spr_height}
        ORR     trns_xsize, trns_xsize, trns_dummy14,LSL#16
;                               Plot the row (call compiled code)
        Pull    "R14"
        LDR     PC, trns_codebuffer + calc_row_stacked -4

        END
